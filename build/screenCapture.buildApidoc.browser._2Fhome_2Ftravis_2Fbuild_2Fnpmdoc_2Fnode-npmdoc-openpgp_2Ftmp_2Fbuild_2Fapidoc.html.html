<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://openpgpjs.org/">openpgp (v2.5.4)</a>
</h1>
<h4>OpenPGP.js is a Javascript implementation of the OpenPGP protocol. This is defined in RFC 4880.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp">module openpgp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.AsyncProxy">
            function <span class="apidocSignatureSpan">openpgp.</span>AsyncProxy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.HKP">
            function <span class="apidocSignatureSpan">openpgp.</span>HKP
            <span class="apidocSignatureSpan">(keyServerBaseUrl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyid">
            function <span class="apidocSignatureSpan">openpgp.</span>Keyid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring">
            function <span class="apidocSignatureSpan">openpgp.</span>Keyring
            <span class="apidocSignatureSpan">(storeHandler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring.localstore">
            function <span class="apidocSignatureSpan">openpgp.</span>Keyring.localstore
            <span class="apidocSignatureSpan">(prefix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.MPI">
            function <span class="apidocSignatureSpan">openpgp.</span>MPI
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.S2K">
            function <span class="apidocSignatureSpan">openpgp.</span>S2K
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.cleartext.CleartextMessage">
            function <span class="apidocSignatureSpan">openpgp.</span>cleartext.CleartextMessage
            <span class="apidocSignatureSpan">(text, signature)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.decrypt">
            function <span class="apidocSignatureSpan">openpgp.</span>decrypt
            <span class="apidocSignatureSpan">(_ref6)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.decryptKey">
            function <span class="apidocSignatureSpan">openpgp.</span>decryptKey
            <span class="apidocSignatureSpan">(_ref4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.decryptSessionKey">
            function <span class="apidocSignatureSpan">openpgp.</span>decryptSessionKey
            <span class="apidocSignatureSpan">(_ref10)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.destroyWorker">
            function <span class="apidocSignatureSpan">openpgp.</span>destroyWorker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.encrypt">
            function <span class="apidocSignatureSpan">openpgp.</span>encrypt
            <span class="apidocSignatureSpan">(_ref5)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.encryptSessionKey">
            function <span class="apidocSignatureSpan">openpgp.</span>encryptSessionKey
            <span class="apidocSignatureSpan">(_ref9)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.generateKey">
            function <span class="apidocSignatureSpan">openpgp.</span>generateKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.getWorker">
            function <span class="apidocSignatureSpan">openpgp.</span>getWorker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.initWorker">
            function <span class="apidocSignatureSpan">openpgp.</span>initWorker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key">
            function <span class="apidocSignatureSpan">openpgp.</span>key.Key
            <span class="apidocSignatureSpan">(packetlist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message">
            function <span class="apidocSignatureSpan">openpgp.</span>message.Message
            <span class="apidocSignatureSpan">(packetlist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Compressed">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.Compressed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.List
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Literal">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.Literal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Marker">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.Marker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.OnePassSignature">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.OnePassSignature
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKey">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.PublicKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.PublicKeyEncryptedSessionKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicSubkey">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.PublicSubkey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretKey">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.SecretKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretSubkey">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.SecretSubkey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Signature">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.Signature
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.SymEncryptedAEADProtected
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.SymEncryptedIntegrityProtected
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.SymEncryptedSessionKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.SymmetricallyEncrypted
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Trust">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.Trust
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.UserAttribute">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.UserAttribute
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Userid">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.Userid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.reformatKey">
            function <span class="apidocSignatureSpan">openpgp.</span>reformatKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.sign">
            function <span class="apidocSignatureSpan">openpgp.</span>sign
            <span class="apidocSignatureSpan">(_ref7)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.signature.Signature">
            function <span class="apidocSignatureSpan">openpgp.</span>signature.Signature
            <span class="apidocSignatureSpan">(packetlist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.verify">
            function <span class="apidocSignatureSpan">openpgp.</span>verify
            <span class="apidocSignatureSpan">(_ref8)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>AsyncProxy.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>HKP.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>Keyid.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>Keyring.localstore.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>Keyring.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>MPI.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>S2K.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>armor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>cleartext</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>cleartext.CleartextMessage.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>crypto</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>crypto.cfb</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>crypto.cipher</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>crypto.gcm</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>crypto.hash</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>crypto.publicKey</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>crypto.random</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>crypto.signature</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>default</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>enums</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>key</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>key.Key.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>message</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>message.Message.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.Compressed.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.List.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.Literal.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.Marker.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.OnePassSignature.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.PublicKey.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.PublicKeyEncryptedSessionKey.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.PublicSubkey.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.SecretKey.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.SecretSubkey.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.Signature.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.SymEncryptedAEADProtected.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.SymEncryptedIntegrityProtected.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.SymEncryptedSessionKey.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.SymmetricallyEncrypted.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.Trust.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.UserAttribute.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.Userid.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.clone</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>signature</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>signature.Signature.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>util</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.AsyncProxy">module openpgp.AsyncProxy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.AsyncProxy.AsyncProxy">
            function <span class="apidocSignatureSpan">openpgp.</span>AsyncProxy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.AsyncProxy.prototype">module openpgp.AsyncProxy.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.AsyncProxy.prototype.delegate">
            function <span class="apidocSignatureSpan">openpgp.AsyncProxy.prototype.</span>delegate
            <span class="apidocSignatureSpan">(method, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.AsyncProxy.prototype.getID">
            function <span class="apidocSignatureSpan">openpgp.AsyncProxy.prototype.</span>getID
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.AsyncProxy.prototype.getRandomBuffer">
            function <span class="apidocSignatureSpan">openpgp.AsyncProxy.prototype.</span>getRandomBuffer
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.AsyncProxy.prototype.onMessage">
            function <span class="apidocSignatureSpan">openpgp.AsyncProxy.prototype.</span>onMessage
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.AsyncProxy.prototype.seedRandom">
            function <span class="apidocSignatureSpan">openpgp.AsyncProxy.prototype.</span>seedRandom
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.AsyncProxy.prototype.terminate">
            function <span class="apidocSignatureSpan">openpgp.AsyncProxy.prototype.</span>terminate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.HKP">module openpgp.HKP</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.HKP.HKP">
            function <span class="apidocSignatureSpan">openpgp.</span>HKP
            <span class="apidocSignatureSpan">(keyServerBaseUrl)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.HKP.prototype">module openpgp.HKP.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.HKP.prototype.lookup">
            function <span class="apidocSignatureSpan">openpgp.HKP.prototype.</span>lookup
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.HKP.prototype.upload">
            function <span class="apidocSignatureSpan">openpgp.HKP.prototype.</span>upload
            <span class="apidocSignatureSpan">(publicKeyArmored)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.Keyid">module openpgp.Keyid</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyid.Keyid">
            function <span class="apidocSignatureSpan">openpgp.</span>Keyid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyid.fromClone">
            function <span class="apidocSignatureSpan">openpgp.Keyid.</span>fromClone
            <span class="apidocSignatureSpan">(clone)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyid.fromId">
            function <span class="apidocSignatureSpan">openpgp.Keyid.</span>fromId
            <span class="apidocSignatureSpan">(hex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyid.mapToHex">
            function <span class="apidocSignatureSpan">openpgp.Keyid.</span>mapToHex
            <span class="apidocSignatureSpan">(keyId)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.Keyid.prototype">module openpgp.Keyid.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyid.prototype.equals">
            function <span class="apidocSignatureSpan">openpgp.Keyid.prototype.</span>equals
            <span class="apidocSignatureSpan">(keyid)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyid.prototype.isNull">
            function <span class="apidocSignatureSpan">openpgp.Keyid.prototype.</span>isNull
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyid.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.Keyid.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyid.prototype.toHex">
            function <span class="apidocSignatureSpan">openpgp.Keyid.prototype.</span>toHex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyid.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.Keyid.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.Keyring">module openpgp.Keyring</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring.Keyring">
            function <span class="apidocSignatureSpan">openpgp.</span>Keyring
            <span class="apidocSignatureSpan">(storeHandler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring.localstore">
            function <span class="apidocSignatureSpan">openpgp.Keyring.</span>localstore
            <span class="apidocSignatureSpan">(prefix)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.Keyring.localstore">module openpgp.Keyring.localstore</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring.localstore.localstore">
            function <span class="apidocSignatureSpan">openpgp.Keyring.</span>localstore
            <span class="apidocSignatureSpan">(prefix)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.Keyring.localstore.prototype">module openpgp.Keyring.localstore.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring.localstore.prototype.loadPrivate">
            function <span class="apidocSignatureSpan">openpgp.Keyring.localstore.prototype.</span>loadPrivate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring.localstore.prototype.loadPublic">
            function <span class="apidocSignatureSpan">openpgp.Keyring.localstore.prototype.</span>loadPublic
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring.localstore.prototype.storePrivate">
            function <span class="apidocSignatureSpan">openpgp.Keyring.localstore.prototype.</span>storePrivate
            <span class="apidocSignatureSpan">(keys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring.localstore.prototype.storePublic">
            function <span class="apidocSignatureSpan">openpgp.Keyring.localstore.prototype.</span>storePublic
            <span class="apidocSignatureSpan">(keys)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">openpgp.Keyring.localstore.prototype.</span>privateKeysItem</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">openpgp.Keyring.localstore.prototype.</span>publicKeysItem</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.Keyring.prototype">module openpgp.Keyring.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring.prototype.clear">
            function <span class="apidocSignatureSpan">openpgp.Keyring.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring.prototype.getAllKeys">
            function <span class="apidocSignatureSpan">openpgp.Keyring.prototype.</span>getAllKeys
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring.prototype.getKeysForId">
            function <span class="apidocSignatureSpan">openpgp.Keyring.prototype.</span>getKeysForId
            <span class="apidocSignatureSpan">(keyId, deep)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring.prototype.removeKeysForId">
            function <span class="apidocSignatureSpan">openpgp.Keyring.prototype.</span>removeKeysForId
            <span class="apidocSignatureSpan">(keyId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring.prototype.store">
            function <span class="apidocSignatureSpan">openpgp.Keyring.prototype.</span>store
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.MPI">module openpgp.MPI</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.MPI.MPI">
            function <span class="apidocSignatureSpan">openpgp.</span>MPI
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.MPI.fromClone">
            function <span class="apidocSignatureSpan">openpgp.MPI.</span>fromClone
            <span class="apidocSignatureSpan">(clone)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.MPI.prototype">module openpgp.MPI.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.MPI.prototype.byteLength">
            function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>byteLength
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.MPI.prototype.fromBigInteger">
            function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>fromBigInteger
            <span class="apidocSignatureSpan">(bn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.MPI.prototype.fromBytes">
            function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>fromBytes
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.MPI.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.MPI.prototype.toBigInteger">
            function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>toBigInteger
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.MPI.prototype.toBytes">
            function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>toBytes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.MPI.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.S2K">module openpgp.S2K</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.S2K.S2K">
            function <span class="apidocSignatureSpan">openpgp.</span>S2K
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.S2K.fromClone">
            function <span class="apidocSignatureSpan">openpgp.S2K.</span>fromClone
            <span class="apidocSignatureSpan">(clone)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.S2K.prototype">module openpgp.S2K.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.S2K.prototype.get_count">
            function <span class="apidocSignatureSpan">openpgp.S2K.prototype.</span>get_count
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.S2K.prototype.produce_key">
            function <span class="apidocSignatureSpan">openpgp.S2K.prototype.</span>produce_key
            <span class="apidocSignatureSpan">(passphrase, numBytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.S2K.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.S2K.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.S2K.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.S2K.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.armor">module openpgp.armor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.armor.decode">
            function <span class="apidocSignatureSpan">openpgp.armor.</span>decode
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.armor.encode">
            function <span class="apidocSignatureSpan">openpgp.armor.</span>encode
            <span class="apidocSignatureSpan">(messagetype, body, partindex, parttotal)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.cleartext">module openpgp.cleartext</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.cleartext.CleartextMessage">
            function <span class="apidocSignatureSpan">openpgp.cleartext.</span>CleartextMessage
            <span class="apidocSignatureSpan">(text, signature)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.cleartext.readArmored">
            function <span class="apidocSignatureSpan">openpgp.cleartext.</span>readArmored
            <span class="apidocSignatureSpan">(armoredText)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.cleartext.CleartextMessage">module openpgp.cleartext.CleartextMessage</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.cleartext.CleartextMessage.CleartextMessage">
            function <span class="apidocSignatureSpan">openpgp.cleartext.</span>CleartextMessage
            <span class="apidocSignatureSpan">(text, signature)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.cleartext.CleartextMessage.prototype">module openpgp.cleartext.CleartextMessage.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.armor">
            function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>armor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.getSigningKeyIds">
            function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>getSigningKeyIds
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.getText">
            function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>getText
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.sign">
            function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>sign
            <span class="apidocSignatureSpan">(privateKeys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.signDetached">
            function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>signDetached
            <span class="apidocSignatureSpan">(privateKeys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.verify">
            function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>verify
            <span class="apidocSignatureSpan">(keys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.verifyDetached">
            function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>verifyDetached
            <span class="apidocSignatureSpan">(signature, keys)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.crypto">module openpgp.crypto</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.generateMpi">
            function <span class="apidocSignatureSpan">openpgp.crypto.</span>generateMpi
            <span class="apidocSignatureSpan">(algo, bits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.generateSessionKey">
            function <span class="apidocSignatureSpan">openpgp.crypto.</span>generateSessionKey
            <span class="apidocSignatureSpan">(algo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.getPrefixRandom">
            function <span class="apidocSignatureSpan">openpgp.crypto.</span>getPrefixRandom
            <span class="apidocSignatureSpan">(algo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.getPrivateMpiCount">
            function <span class="apidocSignatureSpan">openpgp.crypto.</span>getPrivateMpiCount
            <span class="apidocSignatureSpan">(algo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.getPublicMpiCount">
            function <span class="apidocSignatureSpan">openpgp.crypto.</span>getPublicMpiCount
            <span class="apidocSignatureSpan">(algo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.publicKeyDecrypt">
            function <span class="apidocSignatureSpan">openpgp.crypto.</span>publicKeyDecrypt
            <span class="apidocSignatureSpan">(algo, keyIntegers, dataIntegers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.publicKeyEncrypt">
            function <span class="apidocSignatureSpan">openpgp.crypto.</span>publicKeyEncrypt
            <span class="apidocSignatureSpan">(algo, publicMPIs, data)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.crypto.</span>cfb</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.crypto.</span>cipher</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.crypto.</span>gcm</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.crypto.</span>hash</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.crypto.</span>pkcs1</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.crypto.</span>publicKey</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.crypto.</span>random</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.crypto.</span>signature</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.crypto.cfb">module openpgp.crypto.cfb</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cfb.decrypt">
            function <span class="apidocSignatureSpan">openpgp.crypto.cfb.</span>decrypt
            <span class="apidocSignatureSpan">(cipherfn, key, ciphertext, resync)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cfb.encrypt">
            function <span class="apidocSignatureSpan">openpgp.crypto.cfb.</span>encrypt
            <span class="apidocSignatureSpan">(prefixrandom, cipherfn, plaintext, key, resync)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cfb.mdc">
            function <span class="apidocSignatureSpan">openpgp.crypto.cfb.</span>mdc
            <span class="apidocSignatureSpan">(cipherfn, key, ciphertext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cfb.normalDecrypt">
            function <span class="apidocSignatureSpan">openpgp.crypto.cfb.</span>normalDecrypt
            <span class="apidocSignatureSpan">(cipherfn, key, ciphertext, iv)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cfb.normalEncrypt">
            function <span class="apidocSignatureSpan">openpgp.crypto.cfb.</span>normalEncrypt
            <span class="apidocSignatureSpan">(cipherfn, key, plaintext, iv)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.crypto.cipher">module openpgp.crypto.cipher</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cipher.aes128">
            function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>aes128
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cipher.aes192">
            function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>aes192
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cipher.aes256">
            function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>aes256
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cipher.blowfish">
            function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>blowfish
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cipher.cast5">
            function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>cast5
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cipher.des">
            function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>des
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cipher.idea">
            function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>idea
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cipher.tripledes">
            function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>tripledes
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cipher.twofish">
            function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>twofish
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.crypto.gcm">module openpgp.crypto.gcm</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.gcm.decrypt">
            function <span class="apidocSignatureSpan">openpgp.crypto.gcm.</span>decrypt
            <span class="apidocSignatureSpan">(cipher, ciphertext, key, iv)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.gcm.encrypt">
            function <span class="apidocSignatureSpan">openpgp.crypto.gcm.</span>encrypt
            <span class="apidocSignatureSpan">(cipher, plaintext, key, iv)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">openpgp.crypto.gcm.</span>ivLength</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.crypto.hash">module openpgp.crypto.hash</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.hash.digest">
            function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>digest
            <span class="apidocSignatureSpan">(algo, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.hash.getHashByteLength">
            function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>getHashByteLength
            <span class="apidocSignatureSpan">(algo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.hash.md5">
            function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>md5
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.hash.ripemd">
            function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>ripemd
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.hash.sha1">
            function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>sha1
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.hash.sha224">
            function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>sha224
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.hash.sha256">
            function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>sha256
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.hash.sha384">
            function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>sha384
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.hash.sha512">
            function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>sha512
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.crypto.publicKey">module openpgp.crypto.publicKey</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.publicKey.dsa">
            function <span class="apidocSignatureSpan">openpgp.crypto.publicKey.</span>dsa
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.publicKey.elgamal">
            function <span class="apidocSignatureSpan">openpgp.crypto.publicKey.</span>elgamal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.publicKey.rsa">
            function <span class="apidocSignatureSpan">openpgp.crypto.publicKey.</span>rsa
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.crypto.random">module openpgp.crypto.random</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.random.getRandomBigInteger">
            function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getRandomBigInteger
            <span class="apidocSignatureSpan">(bits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.random.getRandomBigIntegerInRange">
            function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getRandomBigIntegerInRange
            <span class="apidocSignatureSpan">(min, max)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.random.getRandomBytes">
            function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getRandomBytes
            <span class="apidocSignatureSpan">(length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.random.getRandomValues">
            function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getRandomValues
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.random.getSecureRandom">
            function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getSecureRandom
            <span class="apidocSignatureSpan">(from, to)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.random.getSecureRandomOctet">
            function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getSecureRandomOctet
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.random.getSecureRandomUint">
            function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getSecureRandomUint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.crypto.random.</span>randomBuffer</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.crypto.signature">module openpgp.crypto.signature</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.signature.sign">
            function <span class="apidocSignatureSpan">openpgp.crypto.signature.</span>sign
            <span class="apidocSignatureSpan">(hash_algo, algo, keyIntegers, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.signature.verify">
            function <span class="apidocSignatureSpan">openpgp.crypto.signature.</span>verify
            <span class="apidocSignatureSpan">(algo, hash_algo, msg_MPIs, publickey_MPIs, data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.default">module openpgp.default</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.default.decrypt">
            function <span class="apidocSignatureSpan">openpgp.default.</span>decrypt
            <span class="apidocSignatureSpan">(_ref6)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.default.decryptKey">
            function <span class="apidocSignatureSpan">openpgp.default.</span>decryptKey
            <span class="apidocSignatureSpan">(_ref4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.default.decryptSessionKey">
            function <span class="apidocSignatureSpan">openpgp.default.</span>decryptSessionKey
            <span class="apidocSignatureSpan">(_ref10)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.default.destroyWorker">
            function <span class="apidocSignatureSpan">openpgp.default.</span>destroyWorker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.default.encrypt">
            function <span class="apidocSignatureSpan">openpgp.default.</span>encrypt
            <span class="apidocSignatureSpan">(_ref5)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.default.encryptSessionKey">
            function <span class="apidocSignatureSpan">openpgp.default.</span>encryptSessionKey
            <span class="apidocSignatureSpan">(_ref9)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.default.generateKey">
            function <span class="apidocSignatureSpan">openpgp.default.</span>generateKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.default.getWorker">
            function <span class="apidocSignatureSpan">openpgp.default.</span>getWorker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.default.initWorker">
            function <span class="apidocSignatureSpan">openpgp.default.</span>initWorker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.default.reformatKey">
            function <span class="apidocSignatureSpan">openpgp.default.</span>reformatKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.default.sign">
            function <span class="apidocSignatureSpan">openpgp.default.</span>sign
            <span class="apidocSignatureSpan">(_ref7)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.default.verify">
            function <span class="apidocSignatureSpan">openpgp.default.</span>verify
            <span class="apidocSignatureSpan">(_ref8)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.enums">module openpgp.enums</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.enums.read">
            function <span class="apidocSignatureSpan">openpgp.enums.</span>read
            <span class="apidocSignatureSpan">(type, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.enums.write">
            function <span class="apidocSignatureSpan">openpgp.enums.</span>write
            <span class="apidocSignatureSpan">(type, e)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.enums.</span>armor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.enums.</span>compression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.enums.</span>hash</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.enums.</span>keyFlags</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.enums.</span>keyStatus</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.enums.</span>literal</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.enums.</span>packet</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.enums.</span>publicKey</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.enums.</span>s2k</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.enums.</span>signature</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.enums.</span>signatureSubpacket</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.enums.</span>symmetric</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.key">module openpgp.key</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key">
            function <span class="apidocSignatureSpan">openpgp.key.</span>Key
            <span class="apidocSignatureSpan">(packetlist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.generate">
            function <span class="apidocSignatureSpan">openpgp.key.</span>generate
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.getPreferredSymAlgo">
            function <span class="apidocSignatureSpan">openpgp.key.</span>getPreferredSymAlgo
            <span class="apidocSignatureSpan">(keys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.readArmored">
            function <span class="apidocSignatureSpan">openpgp.key.</span>readArmored
            <span class="apidocSignatureSpan">(armoredText)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.reformat">
            function <span class="apidocSignatureSpan">openpgp.key.</span>reformat
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.key.Key">module openpgp.key.Key</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.Key">
            function <span class="apidocSignatureSpan">openpgp.key.</span>Key
            <span class="apidocSignatureSpan">(packetlist)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.key.Key.prototype">module openpgp.key.Key.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.armor">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>armor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.decrypt">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(passphrase)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.decryptKeyPacket">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>decryptKeyPacket
            <span class="apidocSignatureSpan">(keyIds, passphrase)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.encrypt">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(passphrase)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.getAllKeyPackets">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getAllKeyPackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.getEncryptionKeyPacket">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getEncryptionKeyPacket
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.getExpirationTime">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getExpirationTime
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.getKeyIds">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getKeyIds
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.getKeyPacket">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getKeyPacket
            <span class="apidocSignatureSpan">(keyIds)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.getPreferredHashAlgorithm">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getPreferredHashAlgorithm
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.getPrimaryUser">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getPrimaryUser
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.getSigningKeyPacket">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getSigningKeyPacket
            <span class="apidocSignatureSpan">(keyId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.getSubkeyPackets">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getSubkeyPackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.getUserIds">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getUserIds
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.isPrivate">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>isPrivate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.isPublic">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>isPublic
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.packetlist2structure">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>packetlist2structure
            <span class="apidocSignatureSpan">(packetlist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.revoke">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>revoke
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.signAllUsers">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>signAllUsers
            <span class="apidocSignatureSpan">(privateKeys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.signPrimaryUser">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>signPrimaryUser
            <span class="apidocSignatureSpan">(privateKeys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.toPacketlist">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>toPacketlist
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.toPublic">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>toPublic
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.update">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>update
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.verifyAllUsers">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>verifyAllUsers
            <span class="apidocSignatureSpan">(keys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.verifyPrimaryKey">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>verifyPrimaryKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.verifyPrimaryUser">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>verifyPrimaryUser
            <span class="apidocSignatureSpan">(keys)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.message">module openpgp.message</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message">
            function <span class="apidocSignatureSpan">openpgp.message.</span>Message
            <span class="apidocSignatureSpan">(packetlist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.encryptSessionKey">
            function <span class="apidocSignatureSpan">openpgp.message.</span>encryptSessionKey
            <span class="apidocSignatureSpan">(sessionKey, symAlgo, publicKeys, passwords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.fromBinary">
            function <span class="apidocSignatureSpan">openpgp.message.</span>fromBinary
            <span class="apidocSignatureSpan">(bytes, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.fromText">
            function <span class="apidocSignatureSpan">openpgp.message.</span>fromText
            <span class="apidocSignatureSpan">(text, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.read">
            function <span class="apidocSignatureSpan">openpgp.message.</span>read
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.readArmored">
            function <span class="apidocSignatureSpan">openpgp.message.</span>readArmored
            <span class="apidocSignatureSpan">(armoredText)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.readSignedContent">
            function <span class="apidocSignatureSpan">openpgp.message.</span>readSignedContent
            <span class="apidocSignatureSpan">(content, detachedSignature)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.message.Message">module openpgp.message.Message</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.Message">
            function <span class="apidocSignatureSpan">openpgp.message.</span>Message
            <span class="apidocSignatureSpan">(packetlist)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.message.Message.prototype">module openpgp.message.Message.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.armor">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>armor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.decrypt">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(privateKey, sessionKey, password)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.decryptSessionKey">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>decryptSessionKey
            <span class="apidocSignatureSpan">(privateKey, password)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.encrypt">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(keys, passwords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.getEncryptionKeyIds">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>getEncryptionKeyIds
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.getFilename">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>getFilename
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.getLiteralData">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>getLiteralData
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.getSigningKeyIds">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>getSigningKeyIds
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.getText">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>getText
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.sign">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>sign
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.signDetached">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>signDetached
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.unwrapCompressed">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>unwrapCompressed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.verify">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>verify
            <span class="apidocSignatureSpan">(keys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.verifyDetached">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>verifyDetached
            <span class="apidocSignatureSpan">(signature, keys)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet">module openpgp.packet</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Compressed">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>Compressed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>List
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Literal">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>Literal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Marker">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>Marker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.OnePassSignature">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>OnePassSignature
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKey">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>PublicKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>PublicKeyEncryptedSessionKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicSubkey">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>PublicSubkey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretKey">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>SecretKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretSubkey">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>SecretSubkey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Signature">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>Signature
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>SymEncryptedAEADProtected
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>SymEncryptedIntegrityProtected
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>SymEncryptedSessionKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>SymmetricallyEncrypted
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Trust">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>Trust
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.UserAttribute">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>UserAttribute
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Userid">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>Userid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.fromStructuredClone">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>fromStructuredClone
            <span class="apidocSignatureSpan">(packetClone)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.newPacketFromTag">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>newPacketFromTag
            <span class="apidocSignatureSpan">(tag)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.</span>clone</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.Compressed">module openpgp.packet.Compressed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Compressed.Compressed">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>Compressed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.Compressed.prototype">module openpgp.packet.Compressed.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Compressed.prototype.compress">
            function <span class="apidocSignatureSpan">openpgp.packet.Compressed.prototype.</span>compress
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Compressed.prototype.decompress">
            function <span class="apidocSignatureSpan">openpgp.packet.Compressed.prototype.</span>decompress
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Compressed.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.Compressed.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Compressed.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.Compressed.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.List">module openpgp.packet.List</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List.List">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>List
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List.fromStructuredClone">
            function <span class="apidocSignatureSpan">openpgp.packet.List.</span>fromStructuredClone
            <span class="apidocSignatureSpan">(packetlistClone)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.List.prototype">module openpgp.packet.List.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List.prototype.concat">
            function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>concat
            <span class="apidocSignatureSpan">(packetlist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List.prototype.filter">
            function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>filter
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List.prototype.filterByTag">
            function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>filterByTag
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List.prototype.findPacket">
            function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>findPacket
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List.prototype.forEach">
            function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List.prototype.indexOfTag">
            function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>indexOfTag
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List.prototype.pop">
            function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>pop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List.prototype.push">
            function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>push
            <span class="apidocSignatureSpan">(packet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List.prototype.slice">
            function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>slice
            <span class="apidocSignatureSpan">(begin, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.Literal">module openpgp.packet.Literal</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Literal.Literal">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>Literal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.Literal.prototype">module openpgp.packet.Literal.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Literal.prototype.getBytes">
            function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>getBytes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Literal.prototype.getFilename">
            function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>getFilename
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Literal.prototype.getText">
            function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>getText
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Literal.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Literal.prototype.setBytes">
            function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>setBytes
            <span class="apidocSignatureSpan">(bytes, format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Literal.prototype.setFilename">
            function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>setFilename
            <span class="apidocSignatureSpan">(filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Literal.prototype.setText">
            function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>setText
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Literal.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.Marker">module openpgp.packet.Marker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Marker.Marker">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>Marker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.Marker.prototype">module openpgp.packet.Marker.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Marker.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.Marker.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.OnePassSignature">module openpgp.packet.OnePassSignature</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.OnePassSignature.OnePassSignature">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>OnePassSignature
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.OnePassSignature.prototype">module openpgp.packet.OnePassSignature.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.OnePassSignature.prototype.postCloneTypeFix">
            function <span class="apidocSignatureSpan">openpgp.packet.OnePassSignature.prototype.</span>postCloneTypeFix
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.OnePassSignature.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.OnePassSignature.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.OnePassSignature.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.OnePassSignature.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.PublicKey">module openpgp.packet.PublicKey</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKey.PublicKey">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>PublicKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.PublicKey.prototype">module openpgp.packet.PublicKey.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKey.prototype.getBitSize">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>getBitSize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKey.prototype.getFingerprint">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>getFingerprint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKey.prototype.getKeyId">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>getKeyId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKey.prototype.postCloneTypeFix">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>postCloneTypeFix
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKey.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKey.prototype.readPublicKey">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>readPublicKey
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKey.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKey.prototype.writeOld">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>writeOld
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKey.prototype.writePublicKey">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>writePublicKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.PublicKeyEncryptedSessionKey">module openpgp.packet.PublicKeyEncryptedSessionKey</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.PublicKeyEncryptedSessionKey">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>PublicKeyEncryptedSessionKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.PublicKeyEncryptedSessionKey.prototype">module openpgp.packet.PublicKeyEncryptedSessionKey.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.decrypt">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKeyEncryptedSessionKey.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.encrypt">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKeyEncryptedSessionKey.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.postCloneTypeFix">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKeyEncryptedSessionKey.prototype.</span>postCloneTypeFix
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKeyEncryptedSessionKey.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKeyEncryptedSessionKey.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.PublicSubkey">module openpgp.packet.PublicSubkey</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicSubkey.PublicSubkey">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>PublicSubkey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.PublicSubkey.prototype">module openpgp.packet.PublicSubkey.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicSubkey.prototype.constructor">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicSubkey.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">openpgp.packet.PublicSubkey.prototype.</span>expirationTimeV3</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">openpgp.packet.PublicSubkey.prototype.</span>tag</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">openpgp.packet.PublicSubkey.prototype.</span>version</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.PublicSubkey.prototype.</span>created</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.PublicSubkey.prototype.</span>fingerprint</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.PublicSubkey.prototype.</span>keyid</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.PublicSubkey.prototype.</span>mpi</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">openpgp.packet.PublicSubkey.prototype.</span>algorithm</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.SecretKey">module openpgp.packet.SecretKey</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretKey.SecretKey">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>SecretKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.SecretKey.prototype">module openpgp.packet.SecretKey.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretKey.prototype.clearPrivateMPIs">
            function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>clearPrivateMPIs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretKey.prototype.constructor">
            function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretKey.prototype.decrypt">
            function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(passphrase)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretKey.prototype.encrypt">
            function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(passphrase)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretKey.prototype.generate">
            function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>generate
            <span class="apidocSignatureSpan">(bits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretKey.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretKey.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>expirationTimeV3</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>tag</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>version</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>created</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>fingerprint</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>keyid</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>mpi</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>algorithm</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.SecretSubkey">module openpgp.packet.SecretSubkey</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretSubkey.SecretSubkey">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>SecretSubkey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.SecretSubkey.prototype">module openpgp.packet.SecretSubkey.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">openpgp.packet.SecretSubkey.prototype.</span>isDecrypted</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretSubkey.prototype.constructor">
            function <span class="apidocSignatureSpan">openpgp.packet.SecretSubkey.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">openpgp.packet.SecretSubkey.prototype.</span>expirationTimeV3</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">openpgp.packet.SecretSubkey.prototype.</span>tag</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">openpgp.packet.SecretSubkey.prototype.</span>version</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.SecretSubkey.prototype.</span>created</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.SecretSubkey.prototype.</span>encrypted</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.SecretSubkey.prototype.</span>fingerprint</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.SecretSubkey.prototype.</span>keyid</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.SecretSubkey.prototype.</span>mpi</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">openpgp.packet.SecretSubkey.prototype.</span>algorithm</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.Signature">module openpgp.packet.Signature</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Signature.Signature">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>Signature
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.Signature.prototype">module openpgp.packet.Signature.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Signature.prototype.calculateTrailer">
            function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>calculateTrailer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Signature.prototype.isExpired">
            function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>isExpired
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Signature.prototype.postCloneTypeFix">
            function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>postCloneTypeFix
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Signature.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Signature.prototype.read_sub_packet">
            function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>read_sub_packet
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Signature.prototype.sign">
            function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>sign
            <span class="apidocSignatureSpan">(key, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Signature.prototype.toSign">
            function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>toSign
            <span class="apidocSignatureSpan">(type, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Signature.prototype.verify">
            function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>verify
            <span class="apidocSignatureSpan">(key, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Signature.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Signature.prototype.write_all_sub_packets">
            function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>write_all_sub_packets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.SymEncryptedAEADProtected">module openpgp.packet.SymEncryptedAEADProtected</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected.SymEncryptedAEADProtected">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>SymEncryptedAEADProtected
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.SymEncryptedAEADProtected.prototype">module openpgp.packet.SymEncryptedAEADProtected.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected.prototype.decrypt">
            function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedAEADProtected.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(sessionKeyAlgorithm, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected.prototype.encrypt">
            function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedAEADProtected.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(sessionKeyAlgorithm, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedAEADProtected.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedAEADProtected.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.SymEncryptedIntegrityProtected">module openpgp.packet.SymEncryptedIntegrityProtected</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.SymEncryptedIntegrityProtected">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>SymEncryptedIntegrityProtected
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.SymEncryptedIntegrityProtected.prototype">module openpgp.packet.SymEncryptedIntegrityProtected.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.prototype.decrypt">
            function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedIntegrityProtected.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(sessionKeyAlgorithm, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.prototype.encrypt">
            function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedIntegrityProtected.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(sessionKeyAlgorithm, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedIntegrityProtected.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedIntegrityProtected.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.SymEncryptedSessionKey">module openpgp.packet.SymEncryptedSessionKey</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey.SymEncryptedSessionKey">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>SymEncryptedSessionKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.SymEncryptedSessionKey.prototype">module openpgp.packet.SymEncryptedSessionKey.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.decrypt">
            function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedSessionKey.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(passphrase)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.encrypt">
            function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedSessionKey.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(passphrase)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.postCloneTypeFix">
            function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedSessionKey.prototype.</span>postCloneTypeFix
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedSessionKey.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedSessionKey.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.SymmetricallyEncrypted">module openpgp.packet.SymmetricallyEncrypted</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted.SymmetricallyEncrypted">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>SymmetricallyEncrypted
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.SymmetricallyEncrypted.prototype">module openpgp.packet.SymmetricallyEncrypted.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted.prototype.decrypt">
            function <span class="apidocSignatureSpan">openpgp.packet.SymmetricallyEncrypted.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(sessionKeyAlgorithm, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted.prototype.encrypt">
            function <span class="apidocSignatureSpan">openpgp.packet.SymmetricallyEncrypted.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(algo, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.SymmetricallyEncrypted.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.SymmetricallyEncrypted.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.Trust">module openpgp.packet.Trust</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Trust.Trust">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>Trust
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.Trust.prototype">module openpgp.packet.Trust.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Trust.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.Trust.prototype.</span>read
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.UserAttribute">module openpgp.packet.UserAttribute</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.UserAttribute.UserAttribute">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>UserAttribute
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.UserAttribute.prototype">module openpgp.packet.UserAttribute.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.UserAttribute.prototype.equals">
            function <span class="apidocSignatureSpan">openpgp.packet.UserAttribute.prototype.</span>equals
            <span class="apidocSignatureSpan">(usrAttr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.UserAttribute.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.UserAttribute.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.UserAttribute.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.UserAttribute.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.Userid">module openpgp.packet.Userid</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Userid.Userid">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>Userid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.Userid.prototype">module openpgp.packet.Userid.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Userid.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.Userid.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Userid.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.Userid.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.clone">module openpgp.packet.clone</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.clone.clonePackets">
            function <span class="apidocSignatureSpan">openpgp.packet.clone.</span>clonePackets
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.clone.parseClonedPackets">
            function <span class="apidocSignatureSpan">openpgp.packet.clone.</span>parseClonedPackets
            <span class="apidocSignatureSpan">(options, method)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.signature">module openpgp.signature</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.signature.Signature">
            function <span class="apidocSignatureSpan">openpgp.signature.</span>Signature
            <span class="apidocSignatureSpan">(packetlist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.signature.read">
            function <span class="apidocSignatureSpan">openpgp.signature.</span>read
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.signature.readArmored">
            function <span class="apidocSignatureSpan">openpgp.signature.</span>readArmored
            <span class="apidocSignatureSpan">(armoredText)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.signature.Signature">module openpgp.signature.Signature</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.signature.Signature.Signature">
            function <span class="apidocSignatureSpan">openpgp.signature.</span>Signature
            <span class="apidocSignatureSpan">(packetlist)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.signature.Signature.prototype">module openpgp.signature.Signature.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.signature.Signature.prototype.armor">
            function <span class="apidocSignatureSpan">openpgp.signature.Signature.prototype.</span>armor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.util">module openpgp.util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.Uint8Array2str">
            function <span class="apidocSignatureSpan">openpgp.util.</span>Uint8Array2str
            <span class="apidocSignatureSpan">(bin)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.bin2str">
            function <span class="apidocSignatureSpan">openpgp.util.</span>bin2str
            <span class="apidocSignatureSpan">(bin)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.calc_checksum">
            function <span class="apidocSignatureSpan">openpgp.util.</span>calc_checksum
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.collectBuffers">
            function <span class="apidocSignatureSpan">openpgp.util.</span>collectBuffers
            <span class="apidocSignatureSpan">(obj, collection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.concatUint8Array">
            function <span class="apidocSignatureSpan">openpgp.util.</span>concatUint8Array
            <span class="apidocSignatureSpan">(arrays)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.copyUint8Array">
            function <span class="apidocSignatureSpan">openpgp.util.</span>copyUint8Array
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.decode_utf8">
            function <span class="apidocSignatureSpan">openpgp.util.</span>decode_utf8
            <span class="apidocSignatureSpan">(utf8)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.detectNode">
            function <span class="apidocSignatureSpan">openpgp.util.</span>detectNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.encode_utf8">
            function <span class="apidocSignatureSpan">openpgp.util.</span>encode_utf8
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.equalsUint8Array">
            function <span class="apidocSignatureSpan">openpgp.util.</span>equalsUint8Array
            <span class="apidocSignatureSpan">(array1, array2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.getLeftNBits">
            function <span class="apidocSignatureSpan">openpgp.util.</span>getLeftNBits
            <span class="apidocSignatureSpan">(string, bitcount)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.getNodeBuffer">
            function <span class="apidocSignatureSpan">openpgp.util.</span>getNodeBuffer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.getNodeCrypto">
            function <span class="apidocSignatureSpan">openpgp.util.</span>getNodeCrypto
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.getTransferables">
            function <span class="apidocSignatureSpan">openpgp.util.</span>getTransferables
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.getWebCrypto">
            function <span class="apidocSignatureSpan">openpgp.util.</span>getWebCrypto
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.getWebCryptoAll">
            function <span class="apidocSignatureSpan">openpgp.util.</span>getWebCryptoAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.get_hashAlgorithmString">
            function <span class="apidocSignatureSpan">openpgp.util.</span>get_hashAlgorithmString
            <span class="apidocSignatureSpan">(algo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.hex2bin">
            function <span class="apidocSignatureSpan">openpgp.util.</span>hex2bin
            <span class="apidocSignatureSpan">(hex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.hexdump">
            function <span class="apidocSignatureSpan">openpgp.util.</span>hexdump
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.hexidump">
            function <span class="apidocSignatureSpan">openpgp.util.</span>hexidump
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.hexstrdump">
            function <span class="apidocSignatureSpan">openpgp.util.</span>hexstrdump
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.isArray">
            function <span class="apidocSignatureSpan">openpgp.util.</span>isArray
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.isEmailAddress">
            function <span class="apidocSignatureSpan">openpgp.util.</span>isEmailAddress
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.isString">
            function <span class="apidocSignatureSpan">openpgp.util.</span>isString
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.isUint8Array">
            function <span class="apidocSignatureSpan">openpgp.util.</span>isUint8Array
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.isUserId">
            function <span class="apidocSignatureSpan">openpgp.util.</span>isUserId
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.print_debug">
            function <span class="apidocSignatureSpan">openpgp.util.</span>print_debug
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.print_debug_hexstr_dump">
            function <span class="apidocSignatureSpan">openpgp.util.</span>print_debug_hexstr_dump
            <span class="apidocSignatureSpan">(str, strToHex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.promisify">
            function <span class="apidocSignatureSpan">openpgp.util.</span>promisify
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.promisifyIE11Op">
            function <span class="apidocSignatureSpan">openpgp.util.</span>promisifyIE11Op
            <span class="apidocSignatureSpan">(cryptoOp, errmsg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.readDate">
            function <span class="apidocSignatureSpan">openpgp.util.</span>readDate
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.readNumber">
            function <span class="apidocSignatureSpan">openpgp.util.</span>readNumber
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.shiftRight">
            function <span class="apidocSignatureSpan">openpgp.util.</span>shiftRight
            <span class="apidocSignatureSpan">(value, bitcount)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.str2Uint8Array">
            function <span class="apidocSignatureSpan">openpgp.util.</span>str2Uint8Array
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.str2bin">
            function <span class="apidocSignatureSpan">openpgp.util.</span>str2bin
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.writeDate">
            function <span class="apidocSignatureSpan">openpgp.util.</span>writeDate
            <span class="apidocSignatureSpan">(time)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.writeNumber">
            function <span class="apidocSignatureSpan">openpgp.util.</span>writeNumber
            <span class="apidocSignatureSpan">(n, bytes)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp" id="apidoc.module.openpgp">module openpgp</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.AsyncProxy" id="apidoc.element.openpgp.AsyncProxy">
        function <span class="apidocSignatureSpan">openpgp.</span>AsyncProxy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AsyncProxy() {
  var _ref = arguments.length &lt;= 0 || arguments[0] === undefined ? {} : arguments[0];

  var _ref$path = _ref.path;
  var path = _ref$path === undefined ? 'openpgp.worker.js' : _ref$path;
  var worker = _ref.worker;
  var config = _ref.config;

  this.worker = worker || new Worker(path);
  this.worker.onmessage = this.onMessage.bind(this);
  this.worker.onerror = function (e) {
    throw new Error('Unhandled error in openpgp worker: ' + e.message + ' (' + e.filename + ':' + e.lineno + ')');
  };
  this.seedRandom(INITIAL_RANDOM_SEED);

  if (config) {
    this.worker.postMessage({ event: 'configure', config: config });
  }

  // Cannot rely on task order being maintained, use object keyed by request ID to track tasks
  this.tasks = {};
  this.currentID = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.HKP" id="apidoc.element.openpgp.HKP">
        function <span class="apidocSignatureSpan">openpgp.</span>HKP
        <span class="apidocSignatureSpan">(keyServerBaseUrl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HKP(keyServerBaseUrl) {
  this._baseUrl = keyServerBaseUrl ? keyServerBaseUrl : _config2.default.keyserver;
  this._fetch = typeof window !== 'undefined' ? window.fetch : _dereq_('node-fetch');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var pubkey = key.publicKeyArmored;   // '-----BEGIN PGP PUBLIC KEY BLOCK ... '
});
```

#### Lookup public key on HKP server

```js
var hkp = new openpgp.<span class="apidocCodeKeywordSpan">HKP</span>('https://pgp.mit.edu');

var options = {
query: 'alice@example.com'
};

hkp.lookup(options).then(function(key) {
var pubkey = openpgp.key.readArmored(key);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyid" id="apidoc.element.openpgp.Keyid">
        function <span class="apidocSignatureSpan">openpgp.</span>Keyid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Keyid() {
  this.bytes = '';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyring" id="apidoc.element.openpgp.Keyring">
        function <span class="apidocSignatureSpan">openpgp.</span>Keyring
        <span class="apidocSignatureSpan">(storeHandler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Keyring(storeHandler) {
  this.storeHandler = storeHandler || new _localstore2.default();
  this.publicKeys = new KeyArray(this.storeHandler.loadPublic());
  this.privateKeys = new KeyArray(this.storeHandler.loadPrivate());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyring.localstore" id="apidoc.element.openpgp.Keyring.localstore">
        function <span class="apidocSignatureSpan">openpgp.</span>Keyring.localstore
        <span class="apidocSignatureSpan">(prefix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LocalStore(prefix) {
  prefix = prefix || 'openpgp-';
  this.publicKeysItem = prefix + this.publicKeysItem;
  this.privateKeysItem = prefix + this.privateKeysItem;
  if (typeof window !== 'undefined' &amp;&amp; window.localStorage) {
    this.storage = window.localStorage;
  } else {
    this.storage = new (_dereq_('node-localstorage').LocalStorage)(_config2.default.node_store);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.MPI" id="apidoc.element.openpgp.MPI">
        function <span class="apidocSignatureSpan">openpgp.</span>MPI
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MPI() {
<span class="apidocCodeCommentSpan">  /** An implementation dependent integer */
</span>  this.data = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.S2K" id="apidoc.element.openpgp.S2K">
        function <span class="apidocSignatureSpan">openpgp.</span>S2K
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function S2K() {
<span class="apidocCodeCommentSpan">  /** @type {module:enums.hash} */
</span>  this.algorithm = 'sha256';
  /** @type {module:enums.s2k} */
  this.type = 'iterated';
  this.c = 96;
  /** Eight bytes of salt in a binary string.
   * @type {String}
   */
  this.salt = _crypto2.default.random.getRandomBytes(8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.cleartext.CleartextMessage" id="apidoc.element.openpgp.cleartext.CleartextMessage">
        function <span class="apidocSignatureSpan">openpgp.</span>cleartext.CleartextMessage
        <span class="apidocSignatureSpan">(text, signature)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CleartextMessage(text, signature) {
  if (!(this instanceof CleartextMessage)) {
    return new CleartextMessage(text, signature);
  }
  // normalize EOL to canonical form &lt;CR&gt;&lt;LF&gt;
  this.text = text.replace(/\r/g, '').replace(/[\t ]+\n/g, "\n").replace(/\n/g, "\r\n");
  if (signature &amp;&amp; !(signature instanceof sigModule.Signature)) {
    throw new Error('Invalid signature input');
  }
  this.signature = signature || new sigModule.Signature(new _packet2.default.List());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.decrypt" id="apidoc.element.openpgp.decrypt">
        function <span class="apidocSignatureSpan">openpgp.</span>decrypt
        <span class="apidocSignatureSpan">(_ref6)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decrypt(_ref6) {
  var message = _ref6.message;
  var privateKey = _ref6.privateKey;
  var publicKeys = _ref6.publicKeys;
  var sessionKey = _ref6.sessionKey;
  var password = _ref6.password;
  var _ref6$format = _ref6.format;
  var format = _ref6$format === undefined ? 'utf8' : _ref6$format;
  var _ref6$signature = _ref6.signature;
  var signature = _ref6$signature === undefined ? null : _ref6$signature;

  checkMessage(message);publicKeys = toArray(publicKeys);

  if (!nativeAEAD() &amp;&amp; asyncProxy) {
    // use web worker if web crypto apis are not supported
    return asyncProxy.delegate('decrypt', { message: message, privateKey: privateKey, publicKeys: publicKeys, sessionKey: sessionKey
, password: password, format: format, signature: signature });
  }

  return message.decrypt(privateKey, sessionKey, password).then(function (message) {

    var result = parseMessage(message, format);
    if (result.data) {
      // verify
      if (!publicKeys) {
        publicKeys = [];
      }
      if (signature) {
        //detached signature
        result.signatures = message.verifyDetached(signature, publicKeys);
      } else {
        result.signatures = message.verify(publicKeys);
      }
    }
    return result;
  }).catch(onError.bind(null, 'Error decrypting message'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
options = {
    message: openpgp.message.read(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.<span class="apidocCodeKeywordSpan">decrypt</span>(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
```

#### Encrypt and decrypt *String* data with PGP keys

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.decryptKey" id="apidoc.element.openpgp.decryptKey">
        function <span class="apidocSignatureSpan">openpgp.</span>decryptKey
        <span class="apidocSignatureSpan">(_ref4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decryptKey(_ref4) {
  var privateKey = _ref4.privateKey;
  var passphrase = _ref4.passphrase;

  if (asyncProxy) {
    // use web worker if available
    return asyncProxy.delegate('decryptKey', { privateKey: privateKey, passphrase: passphrase });
  }

  return execute(function () {

    if (!privateKey.decrypt(passphrase)) {
      throw new Error('Invalid passphrase');
    }
    return {
      key: privateKey
    };
  }, 'Error decrypting private key');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.decryptSessionKey" id="apidoc.element.openpgp.decryptSessionKey">
        function <span class="apidocSignatureSpan">openpgp.</span>decryptSessionKey
        <span class="apidocSignatureSpan">(_ref10)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decryptSessionKey(_ref10) {
  var message = _ref10.message;
  var privateKey = _ref10.privateKey;
  var password = _ref10.password;

  checkMessage(message);

  if (asyncProxy) {
    // use web worker if available
    return asyncProxy.delegate('decryptSessionKey', { message: message, privateKey: privateKey, password: password });
  }

  return execute(function () {
    return message.decryptSessionKey(privateKey, password);
  }, 'Error decrypting session key');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.destroyWorker" id="apidoc.element.openpgp.destroyWorker">
        function <span class="apidocSignatureSpan">openpgp.</span>destroyWorker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyWorker() {
  asyncProxy = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.encrypt" id="apidoc.element.openpgp.encrypt">
        function <span class="apidocSignatureSpan">openpgp.</span>encrypt
        <span class="apidocSignatureSpan">(_ref5)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encrypt(_ref5) {
  var data = _ref5.data;
  var publicKeys = _ref5.publicKeys;
  var privateKeys = _ref5.privateKeys;
  var passwords = _ref5.passwords;
  var filename = _ref5.filename;
  var _ref5$armor = _ref5.armor;
  var armor = _ref5$armor === undefined ? true : _ref5$armor;
  var _ref5$detached = _ref5.detached;
  var detached = _ref5$detached === undefined ? false : _ref5$detached;
  var _ref5$signature = _ref5.signature;
  var signature = _ref5$signature === undefined ? null : _ref5$signature;

  checkData(data);publicKeys = toArray(publicKeys);privateKeys = toArray(privateKeys);passwords = toArray(passwords);

  if (!nativeAEAD() &amp;&amp; asyncProxy) {
    // use web worker if web crypto apis are not supported
    return asyncProxy.delegate('encrypt', { data: data, publicKeys: publicKeys, privateKeys: privateKeys, passwords: passwords,
filename: filename, armor: armor, detached: detached, signature: signature });
  }
  var result = {};
  return Promise.resolve().then(function () {

    var message = createMessage(data, filename);
    if (!privateKeys) {
      privateKeys = [];
    }
    if (privateKeys.length || signature) {
      // sign the message only if private keys or signature is specified
      if (detached) {
        var detachedSignature = message.signDetached(privateKeys, signature);
        if (armor) {
          result.signature = detachedSignature.armor();
        } else {
          result.signature = detachedSignature;
        }
      } else {
        message = message.sign(privateKeys, signature);
      }
    }
    return message.encrypt(publicKeys, passwords);
  }).then(function (message) {
    if (armor) {
      result.data = message.armor();
    } else {
      result.message = message;
    }
    return result;
  }).catch(onError.bind(null, 'Error encrypting message'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.<span class="apidocCodeKeywordSpan">encrypt</span>(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.encryptSessionKey" id="apidoc.element.openpgp.encryptSessionKey">
        function <span class="apidocSignatureSpan">openpgp.</span>encryptSessionKey
        <span class="apidocSignatureSpan">(_ref9)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encryptSessionKey(_ref9) {
  var data = _ref9.data;
  var algorithm = _ref9.algorithm;
  var publicKeys = _ref9.publicKeys;
  var passwords = _ref9.passwords;

  checkbinary(data);checkString(algorithm, 'algorithm');publicKeys = toArray(publicKeys);passwords = toArray(passwords);

  if (asyncProxy) {
    // use web worker if available
    return asyncProxy.delegate('encryptSessionKey', { data: data, algorithm: algorithm, publicKeys: publicKeys, passwords: passwords
 });
  }

  return execute(function () {
    return {

      message: messageLib.encryptSessionKey(data, algorithm, publicKeys, passwords)

    };
  }, 'Error encrypting session key');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.generateKey" id="apidoc.element.openpgp.generateKey">
        function <span class="apidocSignatureSpan">openpgp.</span>generateKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generateKey() {
  var _ref2 = arguments.length &lt;= 0 || arguments[0] === undefined ? {} : arguments[0];

  var _ref2$userIds = _ref2.userIds;
  var userIds = _ref2$userIds === undefined ? [] : _ref2$userIds;
  var passphrase = _ref2.passphrase;
  var _ref2$numBits = _ref2.numBits;
  var numBits = _ref2$numBits === undefined ? 2048 : _ref2$numBits;
  var _ref2$unlocked = _ref2.unlocked;
  var unlocked = _ref2$unlocked === undefined ? false : _ref2$unlocked;
  var _ref2$keyExpirationTi = _ref2.keyExpirationTime;
  var keyExpirationTime = _ref2$keyExpirationTi === undefined ? 0 : _ref2$keyExpirationTi;

  var options = formatUserIds({ userIds: userIds, passphrase: passphrase, numBits: numBits, unlocked: unlocked, keyExpirationTime
: keyExpirationTime });

  if (!_util2.default.getWebCryptoAll() &amp;&amp; asyncProxy) {
    // use web worker if web crypto apis are not supported
    return asyncProxy.delegate('generateKey', options);
  }

  return key.generate(options).then(function (newKey) {
    return {

      key: newKey,
      privateKeyArmored: newKey.armor(),
      publicKeyArmored: newKey.toPublic().armor()

    };
  }).catch(onError.bind(null, 'Error generating keypair'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var options = {
    userIds: [{ name:'Jon Smith', email:'jon@example.com' }], // multiple user IDs
    numBits: 4096,                                            // RSA key size
    passphrase: 'super long and hard to guess secret'         // protects the private key
};

openpgp.<span class="apidocCodeKeywordSpan">generateKey</span>(options).then(function(key) {
    var privkey = key.privateKeyArmored; // '-----BEGIN PGP PRIVATE KEY BLOCK ... '
    var pubkey = key.publicKeyArmored;   // '-----BEGIN PGP PUBLIC KEY BLOCK ... '
});
```

#### Lookup public key on HKP server
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.getWorker" id="apidoc.element.openpgp.getWorker">
        function <span class="apidocSignatureSpan">openpgp.</span>getWorker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getWorker() {
  return asyncProxy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.initWorker" id="apidoc.element.openpgp.initWorker">
        function <span class="apidocSignatureSpan">openpgp.</span>initWorker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function initWorker() {
  var _ref = arguments.length &lt;= 0 || arguments[0] === undefined ? {} : arguments[0];

  var _ref$path = _ref.path;
  var path = _ref$path === undefined ? 'openpgp.worker.js' : _ref$path;
  var worker = _ref.worker;

  if (worker || typeof window !== 'undefined' &amp;&amp; window.Worker) {
    asyncProxy = new _async_proxy2.default({ path: path, worker: worker, config: _config2.default });
    return true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Here are some examples of how to use the v2.x api. For more elaborate examples and working code, please check out the [public api
 unit tests](https://github.com/openpgpjs/openpgpjs/blob/master/test/general/openpgp.js). If you're upgrading from v1.x it
might help to check out the [documentation](https://github.com/openpgpjs/openpgpjs#documentation).

#### Set up

```js
var openpgp = require('openpgp'); // use as CommonJS, AMD, ES6 module or via window.openpgp

openpgp.<span class="apidocCodeKeywordSpan">initWorker</span>({ path:'openpgp.worker.js' }) // set the relative web worker
 path

openpgp.config.aead_protect = true // activate fast AES-GCM mode (not yet OpenPGP standard)
```

#### Encrypt and decrypt *Uint8Array* data with a password

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key" id="apidoc.element.openpgp.key.Key">
        function <span class="apidocSignatureSpan">openpgp.</span>key.Key
        <span class="apidocSignatureSpan">(packetlist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Key(packetlist) {
  if (!(this instanceof Key)) {
    return new Key(packetlist);
  }
  // same data as in packetlist but in structured form
  this.primaryKey = null;
  this.revocationSignature = null;
  this.directSignatures = null;
  this.users = null;
  this.subKeys = null;
  this.packetlist2structure(packetlist);
  if (!this.primaryKey || !this.users) {
    throw new Error('Invalid key: need at least key and user ID packet');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message" id="apidoc.element.openpgp.message.Message">
        function <span class="apidocSignatureSpan">openpgp.</span>message.Message
        <span class="apidocSignatureSpan">(packetlist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Message(packetlist) {
  if (!(this instanceof Message)) {
    return new Message(packetlist);
  }
  this.packets = packetlist || new _packet2.default.List();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Compressed" id="apidoc.element.openpgp.packet.Compressed">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.Compressed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Compressed() {
<span class="apidocCodeCommentSpan">  /**
   * Packet type
   * @type {module:enums.packet}
   */
</span>  this.tag = _enums2.default.packet.compressed;
  /**
   * List of packets
   * @type {module:packet/packetlist}
   */
  this.packets = null;
  /**
   * Compression algorithm
   * @type {compression}
   */
  this.algorithm = 'zip';

  /**
   * Compressed packet data
   * @type {String}
   */
  this.compressed = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.List" id="apidoc.element.openpgp.packet.List">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.List
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Packetlist() {
<span class="apidocCodeCommentSpan">  /** The number of packets contained within the list.
   * @readonly
   * @type {Integer} */
</span>  this.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Literal" id="apidoc.element.openpgp.packet.Literal">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.Literal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Literal() {
  this.tag = _enums2.default.packet.literal;
  this.format = 'utf8'; // default format for literal data packets
  this.date = new Date();
  this.data = new Uint8Array(0); // literal data representation
  this.filename = 'msg.txt';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Marker" id="apidoc.element.openpgp.packet.Marker">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.Marker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Marker() {
  this.tag = _enums2.default.packet.marker;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.OnePassSignature" id="apidoc.element.openpgp.packet.OnePassSignature">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.OnePassSignature
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OnePassSignature() {
  this.tag = _enums2.default.packet.onePassSignature; // The packet type
  this.version = null; // A one-octet version number.  The current version is 3.
  this.type = null; // A one-octet signature type.  Signature types are described in {@link http://tools.ietf.org/html/rfc4880#section
-5.2.1|RFC4880 Section 5.2.1}.
  this.hashAlgorithm = null; // A one-octet number describing the hash algorithm used. (See {@link http://tools.ietf.org/html/rfc4880
#section-9.4|RFC4880 9.4})
  this.publicKeyAlgorithm = null; // A one-octet number describing the public-key algorithm used. (See {@link http://tools.ietf.
org/html/rfc4880#section-9.1|RFC4880 9.1})
  this.signingKeyId = null; // An eight-octet number holding the Key ID of the signing key.
  this.flags = null; //  A one-octet number holding a flag showing whether the signature is nested.  A zero value indicates that
 the next packet is another One-Pass Signature packet that describes another signature to be applied to the same message data.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKey" id="apidoc.element.openpgp.packet.PublicKey">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.PublicKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PublicKey() {
  this.tag = _enums2.default.packet.publicKey;
  this.version = 4;
<span class="apidocCodeCommentSpan">  /** Key creation date.
   * @type {Date} */
</span>  this.created = new Date();
  /** A list of multiprecision integers
   * @type {module:type/mpi} */
  this.mpi = [];
  /** Public key algorithm
   * @type {module:enums.publicKey} */
  this.algorithm = 'rsa_sign';
  // time in days (V3 only)
  this.expirationTimeV3 = 0;
  /**
   * Fingerprint in lowercase hex
   * @type {String}
   */
  this.fingerprint = null;
  /**
   * Keyid
   * @type {module:type/keyid}
   */
  this.keyid = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey" id="apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.PublicKeyEncryptedSessionKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PublicKeyEncryptedSessionKey() {
  this.tag = _enums2.default.packet.publicKeyEncryptedSessionKey;
  this.version = 3;

  this.publicKeyId = new _keyid2.default();
  this.publicKeyAlgorithm = 'rsa_encrypt';

  this.sessionKey = null;
  this.sessionKeyAlgorithm = 'aes256';

<span class="apidocCodeCommentSpan">  /** @type {Array&lt;module:type/mpi&gt;} */
</span>  this.encrypted = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicSubkey" id="apidoc.element.openpgp.packet.PublicSubkey">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.PublicSubkey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PublicSubkey() {
  _public_key2.default.call(this);
  this.tag = _enums2.default.packet.publicSubkey;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretKey" id="apidoc.element.openpgp.packet.SecretKey">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.SecretKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SecretKey() {
  _public_key2.default.call(this);
  this.tag = _enums2.default.packet.secretKey;
  // encrypted secret-key data
  this.encrypted = null;
  // indicator if secret-key data is available in decrypted form
  this.isDecrypted = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretSubkey" id="apidoc.element.openpgp.packet.SecretSubkey">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.SecretSubkey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SecretSubkey() {
  _secret_key2.default.call(this);
  this.tag = _enums2.default.packet.secretSubkey;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Signature" id="apidoc.element.openpgp.packet.Signature">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.Signature
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Signature() {
  this.tag = _enums2.default.packet.signature;
  this.version = 4;
  this.signatureType = null;
  this.hashAlgorithm = null;
  this.publicKeyAlgorithm = null;

  this.signatureData = null;
  this.unhashedSubpackets = null;
  this.signedHashValue = null;

  this.created = new Date();
  this.signatureExpirationTime = null;
  this.signatureNeverExpires = true;
  this.exportable = null;
  this.trustLevel = null;
  this.trustAmount = null;
  this.regularExpression = null;
  this.revocable = null;
  this.keyExpirationTime = null;
  this.keyNeverExpires = null;
  this.preferredSymmetricAlgorithms = null;
  this.revocationKeyClass = null;
  this.revocationKeyAlgorithm = null;
  this.revocationKeyFingerprint = null;
  this.issuerKeyId = new _keyid2.default();
  this.notation = null;
  this.preferredHashAlgorithms = null;
  this.preferredCompressionAlgorithms = null;
  this.keyServerPreferences = null;
  this.preferredKeyServer = null;
  this.isPrimaryUserID = null;
  this.policyURI = null;
  this.keyFlags = null;
  this.signersUserId = null;
  this.reasonForRevocationFlag = null;
  this.reasonForRevocationString = null;
  this.features = null;
  this.signatureTargetPublicKeyAlgorithm = null;
  this.signatureTargetHashAlgorithm = null;
  this.signatureTargetHash = null;
  this.embeddedSignature = null;

  this.verified = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected" id="apidoc.element.openpgp.packet.SymEncryptedAEADProtected">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.SymEncryptedAEADProtected
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymEncryptedAEADProtected() {
  this.tag = _enums2.default.packet.symEncryptedAEADProtected;
  this.version = VERSION;
  this.iv = null;
  this.encrypted = null;
  this.packets = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected" id="apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.SymEncryptedIntegrityProtected
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymEncryptedIntegrityProtected() {
  this.tag = _enums2.default.packet.symEncryptedIntegrityProtected;
  this.version = VERSION;
<span class="apidocCodeCommentSpan">  /** The encrypted payload. */
</span>  this.encrypted = null; // string
  /**
   * If after decrypting the packet this is set to true,
   * a modification has been detected and thus the contents
   * should be discarded.
   * @type {Boolean}
   */
  this.modification = false;
  this.packets = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey" id="apidoc.element.openpgp.packet.SymEncryptedSessionKey">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.SymEncryptedSessionKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymEncryptedSessionKey() {
  this.tag = _enums2.default.packet.symEncryptedSessionKey;
  this.version = 4;
  this.sessionKey = null;
  this.sessionKeyEncryptionAlgorithm = null;
  this.sessionKeyAlgorithm = 'aes256';
  this.encrypted = null;
  this.s2k = new _s2k2.default();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted" id="apidoc.element.openpgp.packet.SymmetricallyEncrypted">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.SymmetricallyEncrypted
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymmetricallyEncrypted() {
  this.tag = _enums2.default.packet.symmetricallyEncrypted;
  this.encrypted = null;
<span class="apidocCodeCommentSpan">  /** Decrypted packets contained within.
   * @type {module:packet/packetlist} */
</span>  this.packets = null;
  this.ignore_mdc_error = _config2.default.ignore_mdc_error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Trust" id="apidoc.element.openpgp.packet.Trust">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.Trust
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Trust() {
  this.tag = _enums2.default.packet.trust;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.UserAttribute" id="apidoc.element.openpgp.packet.UserAttribute">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.UserAttribute
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UserAttribute() {
  this.tag = _enums2.default.packet.userAttribute;
  this.attributes = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Userid" id="apidoc.element.openpgp.packet.Userid">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.Userid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Userid() {
  this.tag = _enums2.default.packet.userid;
<span class="apidocCodeCommentSpan">  /** A string containing the user id. Usually in the form
   * John Doe &lt;john@example.com&gt;
   * @type {String}
   */
</span>  this.userid = '';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.reformatKey" id="apidoc.element.openpgp.reformatKey">
        function <span class="apidocSignatureSpan">openpgp.</span>reformatKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reformatKey() {
  var _ref3 = arguments.length &lt;= 0 || arguments[0] === undefined ? {} : arguments[0];

  var privateKey = _ref3.privateKey;
  var _ref3$userIds = _ref3.userIds;
  var userIds = _ref3$userIds === undefined ? [] : _ref3$userIds;
  var _ref3$passphrase = _ref3.passphrase;
  var passphrase = _ref3$passphrase === undefined ? "" : _ref3$passphrase;
  var _ref3$unlocked = _ref3.unlocked;
  var unlocked = _ref3$unlocked === undefined ? false : _ref3$unlocked;
  var _ref3$keyExpirationTi = _ref3.keyExpirationTime;
  var keyExpirationTime = _ref3$keyExpirationTi === undefined ? 0 : _ref3$keyExpirationTi;

  var options = formatUserIds({ privateKey: privateKey, userIds: userIds, passphrase: passphrase, unlocked: unlocked, keyExpirationTime
: keyExpirationTime });

  if (asyncProxy) {
    return asyncProxy.delegate('reformatKey', options);
  }

  return key.reformat(options).then(function (newKey) {
    return {

      key: newKey,
      privateKeyArmored: newKey.armor(),
      publicKeyArmored: newKey.toPublic().armor()

    };
  }).catch(onError.bind(null, 'Error reformatting keypair'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.sign" id="apidoc.element.openpgp.sign">
        function <span class="apidocSignatureSpan">openpgp.</span>sign
        <span class="apidocSignatureSpan">(_ref7)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sign(_ref7) {
  var data = _ref7.data;
  var privateKeys = _ref7.privateKeys;
  var _ref7$armor = _ref7.armor;
  var armor = _ref7$armor === undefined ? true : _ref7$armor;
  var _ref7$detached = _ref7.detached;
  var detached = _ref7$detached === undefined ? false : _ref7$detached;

  checkString(data);
  privateKeys = toArray(privateKeys);

  if (asyncProxy) {
    // use web worker if available
    return asyncProxy.delegate('sign', { data: data, privateKeys: privateKeys, armor: armor, detached: detached });
  }

  var result = {};
  return execute(function () {

    var cleartextMessage = new cleartext.CleartextMessage(data);

    if (detached) {
      var signature = cleartextMessage.signDetached(privateKeys);
      if (armor) {
        result.signature = signature.armor();
      } else {
        result.signature = signature;
      }
    } else {
      cleartextMessage.sign(privateKeys);
    }

    if (armor) {
      result.data = cleartextMessage.armor();
    } else {
      result.message = cleartextMessage;
    }
    return result;
  }, 'Error signing cleartext message');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
options = {
data: 'Hello, World!',                             // input as String (or Uint8Array)
privateKeys: privKeyObj // for signing
};

openpgp.<span class="apidocCodeKeywordSpan">sign</span>(options).then(function(signed) {
cleartext = signed.data; // '-----BEGIN PGP SIGNED MESSAGE ... END PGP SIGNATURE-----'
});
```

```js
options = {
message: openpgp.cleartext.readArmored(cleartext), // parse armored message
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.signature.Signature" id="apidoc.element.openpgp.signature.Signature">
        function <span class="apidocSignatureSpan">openpgp.</span>signature.Signature
        <span class="apidocSignatureSpan">(packetlist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Signature(packetlist) {
  if (!(this instanceof Signature)) {
    return new Signature(packetlist);
  }
  this.packets = packetlist || new _packet2.default.List();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.verify" id="apidoc.element.openpgp.verify">
        function <span class="apidocSignatureSpan">openpgp.</span>verify
        <span class="apidocSignatureSpan">(_ref8)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function verify(_ref8) {
  var message = _ref8.message;
  var publicKeys = _ref8.publicKeys;
  var _ref8$signature = _ref8.signature;
  var signature = _ref8$signature === undefined ? null : _ref8$signature;

  checkCleartextMessage(message);
  publicKeys = toArray(publicKeys);

  if (asyncProxy) {
    // use web worker if available
    return asyncProxy.delegate('verify', { message: message, publicKeys: publicKeys, signature: signature });
  }

  var result = {};
  return execute(function () {
    result.data = message.getText();

    if (signature) {
      //detached signature
      result.signatures = message.verifyDetached(signature, publicKeys);
    } else {
      result.signatures = message.verify(publicKeys);
    }
    return result;
  }, 'Error verifying cleartext signed message');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
options = {
    message: openpgp.cleartext.readArmored(cleartext), // parse armored message
    publicKeys: openpgp.key.readArmored(pubkey).keys   // for verification
};

openpgp.<span class="apidocCodeKeywordSpan">verify</span>(options).then(function(verified) {
	validity = verified.signatures[0].valid; // true
	if (validity) {
		console.log('signed by key id ' + verified.signatures[0].keyid.toHex());
	}
});
```
...</pre></li>
    </ul>


































































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.AsyncProxy" id="apidoc.module.openpgp.AsyncProxy">module openpgp.AsyncProxy</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.AsyncProxy.AsyncProxy" id="apidoc.element.openpgp.AsyncProxy.AsyncProxy">
        function <span class="apidocSignatureSpan">openpgp.</span>AsyncProxy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AsyncProxy() {
  var _ref = arguments.length &lt;= 0 || arguments[0] === undefined ? {} : arguments[0];

  var _ref$path = _ref.path;
  var path = _ref$path === undefined ? 'openpgp.worker.js' : _ref$path;
  var worker = _ref.worker;
  var config = _ref.config;

  this.worker = worker || new Worker(path);
  this.worker.onmessage = this.onMessage.bind(this);
  this.worker.onerror = function (e) {
    throw new Error('Unhandled error in openpgp worker: ' + e.message + ' (' + e.filename + ':' + e.lineno + ')');
  };
  this.seedRandom(INITIAL_RANDOM_SEED);

  if (config) {
    this.worker.postMessage({ event: 'configure', config: config });
  }

  // Cannot rely on task order being maintained, use object keyed by request ID to track tasks
  this.tasks = {};
  this.currentID = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.AsyncProxy.prototype" id="apidoc.module.openpgp.AsyncProxy.prototype">module openpgp.AsyncProxy.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.AsyncProxy.prototype.delegate" id="apidoc.element.openpgp.AsyncProxy.prototype.delegate">
        function <span class="apidocSignatureSpan">openpgp.AsyncProxy.prototype.</span>delegate
        <span class="apidocSignatureSpan">(method, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delegate = function (method, options) {
  var _this = this;

  var id = this.getID();

  return new Promise(function (_resolve, reject) {
    // clone packets (for web worker structured cloning algorithm)
    _this.worker.postMessage({ id: id, event: method, options: _packet2.default.clone.clonePackets(options) }, _util2.default.getTransferables
.call(_util2.default, options));

    // remember to handle parsing cloned packets from worker
    _this.tasks[id] = { resolve: function resolve(data) {
        return _resolve(_packet2.default.clone.parseClonedPackets(data, method));
      }, reject: reject };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.AsyncProxy.prototype.getID" id="apidoc.element.openpgp.AsyncProxy.prototype.getID">
        function <span class="apidocSignatureSpan">openpgp.AsyncProxy.prototype.</span>getID
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getID = function () {
  return this.currentID++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.AsyncProxy.prototype.getRandomBuffer" id="apidoc.element.openpgp.AsyncProxy.prototype.getRandomBuffer">
        function <span class="apidocSignatureSpan">openpgp.AsyncProxy.prototype.</span>getRandomBuffer
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRandomBuffer = function (size) {
  if (!size) {
    return null;
  }
  var buf = new Uint8Array(size);
  _crypto2.default.random.getRandomValues(buf);
  return buf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.AsyncProxy.prototype.onMessage" id="apidoc.element.openpgp.AsyncProxy.prototype.onMessage">
        function <span class="apidocSignatureSpan">openpgp.AsyncProxy.prototype.</span>onMessage
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onMessage = function (event) {
  var msg = event.data;
  switch (msg.event) {
    case 'method-return':
      if (msg.err) {
        // fail
        this.tasks[msg.id].reject(new Error(msg.err));
      } else {
        // success
        this.tasks[msg.id].resolve(msg.data);
      }
      delete this.tasks[msg.id];
      break;
    case 'request-seed':
      this.seedRandom(RANDOM_SEED_REQUEST);
      break;
    default:
      throw new Error('Unknown Worker Event.');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.AsyncProxy.prototype.seedRandom" id="apidoc.element.openpgp.AsyncProxy.prototype.seedRandom">
        function <span class="apidocSignatureSpan">openpgp.AsyncProxy.prototype.</span>seedRandom
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">seedRandom = function (size) {
  var buf = this.getRandomBuffer(size);
  this.worker.postMessage({ event: 'seed-random', buf: buf }, _util2.default.getTransferables.call(_util2.default, buf));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.AsyncProxy.prototype.terminate" id="apidoc.element.openpgp.AsyncProxy.prototype.terminate">
        function <span class="apidocSignatureSpan">openpgp.AsyncProxy.prototype.</span>terminate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">terminate = function () {
  this.worker.terminate();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.HKP" id="apidoc.module.openpgp.HKP">module openpgp.HKP</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.HKP.HKP" id="apidoc.element.openpgp.HKP.HKP">
        function <span class="apidocSignatureSpan">openpgp.</span>HKP
        <span class="apidocSignatureSpan">(keyServerBaseUrl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HKP(keyServerBaseUrl) {
  this._baseUrl = keyServerBaseUrl ? keyServerBaseUrl : _config2.default.keyserver;
  this._fetch = typeof window !== 'undefined' ? window.fetch : _dereq_('node-fetch');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var pubkey = key.publicKeyArmored;   // '-----BEGIN PGP PUBLIC KEY BLOCK ... '
});
```

#### Lookup public key on HKP server

```js
var hkp = new openpgp.<span class="apidocCodeKeywordSpan">HKP</span>('https://pgp.mit.edu');

var options = {
query: 'alice@example.com'
};

hkp.lookup(options).then(function(key) {
var pubkey = openpgp.key.readArmored(key);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.HKP.prototype" id="apidoc.module.openpgp.HKP.prototype">module openpgp.HKP.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.HKP.prototype.lookup" id="apidoc.element.openpgp.HKP.prototype.lookup">
        function <span class="apidocSignatureSpan">openpgp.HKP.prototype.</span>lookup
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookup = function (options) {
  var uri = this._baseUrl + '/pks/lookup?op=get&amp;options=mr&amp;search=',
      fetch = this._fetch;

  if (options.keyId) {
    uri += '0x' + encodeURIComponent(options.keyId);
  } else if (options.query) {
    uri += encodeURIComponent(options.query);
  } else {
    throw new Error('You must provide a query parameter!');
  }

  return fetch(uri).then(function (response) {
    if (response.status === 200) {
      return response.text();
    }
  }).then(function (publicKeyArmored) {
    if (!publicKeyArmored || publicKeyArmored.indexOf('-----END PGP PUBLIC KEY BLOCK-----') &lt; 0) {
      return;
    }
    return publicKeyArmored.trim();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var hkp = new openpgp.HKP('https://pgp.mit.edu');

var options = {
    query: 'alice@example.com'
};

hkp.<span class="apidocCodeKeywordSpan">lookup</span>(options).then(function(key) {
    var pubkey = openpgp.key.readArmored(key);
});
```

#### Upload public key to HKP server

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.HKP.prototype.upload" id="apidoc.element.openpgp.HKP.prototype.upload">
        function <span class="apidocSignatureSpan">openpgp.HKP.prototype.</span>upload
        <span class="apidocSignatureSpan">(publicKeyArmored)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">upload = function (publicKeyArmored) {
  var uri = this._baseUrl + '/pks/add',
      fetch = this._fetch;

  return fetch(uri, {
    method: 'post',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
    },
    body: 'keytext=' + encodeURIComponent(publicKeyArmored)
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### Upload public key to HKP server

```js
var hkp = new openpgp.HKP('https://pgp.mit.edu');

var pubkey = '-----BEGIN PGP PUBLIC KEY BLOCK ... END PGP PUBLIC KEY BLOCK-----';

hkp.<span class="apidocCodeKeywordSpan">upload</span>(pubkey).then(function() { ... });
```

#### Sign and verify cleartext messages

```js
var options, cleartext, validity;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.Keyid" id="apidoc.module.openpgp.Keyid">module openpgp.Keyid</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.Keyid.Keyid" id="apidoc.element.openpgp.Keyid.Keyid">
        function <span class="apidocSignatureSpan">openpgp.</span>Keyid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Keyid() {
  this.bytes = '';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyid.fromClone" id="apidoc.element.openpgp.Keyid.fromClone">
        function <span class="apidocSignatureSpan">openpgp.Keyid.</span>fromClone
        <span class="apidocSignatureSpan">(clone)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromClone = function (clone) {
  var keyid = new Keyid();
  keyid.bytes = clone.bytes;
  return keyid;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyid.fromId" id="apidoc.element.openpgp.Keyid.fromId">
        function <span class="apidocSignatureSpan">openpgp.Keyid.</span>fromId
        <span class="apidocSignatureSpan">(hex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromId = function (hex) {
  var keyid = new Keyid();
  keyid.read(_util2.default.str2Uint8Array(_util2.default.hex2bin(hex)));
  return keyid;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyid.mapToHex" id="apidoc.element.openpgp.Keyid.mapToHex">
        function <span class="apidocSignatureSpan">openpgp.Keyid.</span>mapToHex
        <span class="apidocSignatureSpan">(keyId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapToHex = function (keyId) {
  return keyId.toHex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.Keyid.prototype" id="apidoc.module.openpgp.Keyid.prototype">module openpgp.Keyid.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.Keyid.prototype.equals" id="apidoc.element.openpgp.Keyid.prototype.equals">
        function <span class="apidocSignatureSpan">openpgp.Keyid.prototype.</span>equals
        <span class="apidocSignatureSpan">(keyid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equals = function (keyid) {
  return this.bytes === keyid.bytes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyid.prototype.isNull" id="apidoc.element.openpgp.Keyid.prototype.isNull">
        function <span class="apidocSignatureSpan">openpgp.Keyid.prototype.</span>isNull
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNull = function () {
  return this.bytes === '';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyid.prototype.read" id="apidoc.element.openpgp.Keyid.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.Keyid.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  this.bytes = _util2.default.Uint8Array2str(bytes.subarray(0, 8));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyid.prototype.toHex" id="apidoc.element.openpgp.Keyid.prototype.toHex">
        function <span class="apidocSignatureSpan">openpgp.Keyid.prototype.</span>toHex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toHex = function () {
  return _util2.default.hexstrdump(this.bytes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    message: openpgp.cleartext.readArmored(cleartext), // parse armored message
    publicKeys: openpgp.key.readArmored(pubkey).keys   // for verification
};

openpgp.verify(options).then(function(verified) {
	validity = verified.signatures[0].valid; // true
	if (validity) {
		console.log('signed by key id ' + verified.signatures[0].keyid.<span class="apidocCodeKeywordSpan">toHex</span>());
	}
});
```

#### Create and verify *detached* signatures

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyid.prototype.write" id="apidoc.element.openpgp.Keyid.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.Keyid.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  return _util2.default.str2Uint8Array(this.bytes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.Keyring" id="apidoc.module.openpgp.Keyring">module openpgp.Keyring</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.Keyring.Keyring" id="apidoc.element.openpgp.Keyring.Keyring">
        function <span class="apidocSignatureSpan">openpgp.</span>Keyring
        <span class="apidocSignatureSpan">(storeHandler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Keyring(storeHandler) {
  this.storeHandler = storeHandler || new _localstore2.default();
  this.publicKeys = new KeyArray(this.storeHandler.loadPublic());
  this.privateKeys = new KeyArray(this.storeHandler.loadPrivate());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyring.localstore" id="apidoc.element.openpgp.Keyring.localstore">
        function <span class="apidocSignatureSpan">openpgp.Keyring.</span>localstore
        <span class="apidocSignatureSpan">(prefix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LocalStore(prefix) {
  prefix = prefix || 'openpgp-';
  this.publicKeysItem = prefix + this.publicKeysItem;
  this.privateKeysItem = prefix + this.privateKeysItem;
  if (typeof window !== 'undefined' &amp;&amp; window.localStorage) {
    this.storage = window.localStorage;
  } else {
    this.storage = new (_dereq_('node-localstorage').LocalStorage)(_config2.default.node_store);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.Keyring.localstore" id="apidoc.module.openpgp.Keyring.localstore">module openpgp.Keyring.localstore</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.Keyring.localstore.localstore" id="apidoc.element.openpgp.Keyring.localstore.localstore">
        function <span class="apidocSignatureSpan">openpgp.Keyring.</span>localstore
        <span class="apidocSignatureSpan">(prefix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LocalStore(prefix) {
  prefix = prefix || 'openpgp-';
  this.publicKeysItem = prefix + this.publicKeysItem;
  this.privateKeysItem = prefix + this.privateKeysItem;
  if (typeof window !== 'undefined' &amp;&amp; window.localStorage) {
    this.storage = window.localStorage;
  } else {
    this.storage = new (_dereq_('node-localstorage').LocalStorage)(_config2.default.node_store);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.Keyring.localstore.prototype" id="apidoc.module.openpgp.Keyring.localstore.prototype">module openpgp.Keyring.localstore.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.Keyring.localstore.prototype.loadPrivate" id="apidoc.element.openpgp.Keyring.localstore.prototype.loadPrivate">
        function <span class="apidocSignatureSpan">openpgp.Keyring.localstore.prototype.</span>loadPrivate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadPrivate = function () {
  return loadKeys(this.storage, this.privateKeysItem);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyring.localstore.prototype.loadPublic" id="apidoc.element.openpgp.Keyring.localstore.prototype.loadPublic">
        function <span class="apidocSignatureSpan">openpgp.Keyring.localstore.prototype.</span>loadPublic
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadPublic = function () {
  return loadKeys(this.storage, this.publicKeysItem);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyring.localstore.prototype.storePrivate" id="apidoc.element.openpgp.Keyring.localstore.prototype.storePrivate">
        function <span class="apidocSignatureSpan">openpgp.Keyring.localstore.prototype.</span>storePrivate
        <span class="apidocSignatureSpan">(keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storePrivate = function (keys) {
  storeKeys(this.storage, this.privateKeysItem, keys);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyring.localstore.prototype.storePublic" id="apidoc.element.openpgp.Keyring.localstore.prototype.storePublic">
        function <span class="apidocSignatureSpan">openpgp.Keyring.localstore.prototype.</span>storePublic
        <span class="apidocSignatureSpan">(keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storePublic = function (keys) {
  storeKeys(this.storage, this.publicKeysItem, keys);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.Keyring.prototype" id="apidoc.module.openpgp.Keyring.prototype">module openpgp.Keyring.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.Keyring.prototype.clear" id="apidoc.element.openpgp.Keyring.prototype.clear">
        function <span class="apidocSignatureSpan">openpgp.Keyring.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {
  this.publicKeys.keys = [];
  this.privateKeys.keys = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyring.prototype.getAllKeys" id="apidoc.element.openpgp.Keyring.prototype.getAllKeys">
        function <span class="apidocSignatureSpan">openpgp.Keyring.prototype.</span>getAllKeys
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAllKeys = function () {
  return this.publicKeys.keys.concat(this.privateKeys.keys);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyring.prototype.getKeysForId" id="apidoc.element.openpgp.Keyring.prototype.getKeysForId">
        function <span class="apidocSignatureSpan">openpgp.Keyring.prototype.</span>getKeysForId
        <span class="apidocSignatureSpan">(keyId, deep)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getKeysForId = function (keyId, deep) {
  var result = [];
  result = result.concat(this.publicKeys.getForId(keyId, deep) || []);
  result = result.concat(this.privateKeys.getForId(keyId, deep) || []);
  return result.length ? result : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyring.prototype.removeKeysForId" id="apidoc.element.openpgp.Keyring.prototype.removeKeysForId">
        function <span class="apidocSignatureSpan">openpgp.Keyring.prototype.</span>removeKeysForId
        <span class="apidocSignatureSpan">(keyId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeKeysForId = function (keyId) {
  var result = [];
  result = result.concat(this.publicKeys.removeForId(keyId) || []);
  result = result.concat(this.privateKeys.removeForId(keyId) || []);
  return result.length ? result : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyring.prototype.store" id="apidoc.element.openpgp.Keyring.prototype.store">
        function <span class="apidocSignatureSpan">openpgp.Keyring.prototype.</span>store
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">store = function () {
  this.storeHandler.storePublic(this.publicKeys.keys);
  this.storeHandler.storePrivate(this.privateKeys.keys);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.MPI" id="apidoc.module.openpgp.MPI">module openpgp.MPI</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.MPI.MPI" id="apidoc.element.openpgp.MPI.MPI">
        function <span class="apidocSignatureSpan">openpgp.</span>MPI
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MPI() {
<span class="apidocCodeCommentSpan">  /** An implementation dependent integer */
</span>  this.data = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.MPI.fromClone" id="apidoc.element.openpgp.MPI.fromClone">
        function <span class="apidocSignatureSpan">openpgp.MPI.</span>fromClone
        <span class="apidocSignatureSpan">(clone)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromClone = function (clone) {
  clone.data.copyTo = _jsbn2.default.prototype.copyTo;
  var bn = new _jsbn2.default();
  clone.data.copyTo(bn);
  var mpi = new MPI();
  mpi.data = bn;
  return mpi;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.MPI.prototype" id="apidoc.module.openpgp.MPI.prototype">module openpgp.MPI.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.MPI.prototype.byteLength" id="apidoc.element.openpgp.MPI.prototype.byteLength">
        function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>byteLength
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">byteLength = function () {
  return this.toBytes().length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.MPI.prototype.fromBigInteger" id="apidoc.element.openpgp.MPI.prototype.fromBigInteger">
        function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>fromBigInteger
        <span class="apidocSignatureSpan">(bn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromBigInteger = function (bn) {
  this.data = bn.clone();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.MPI.prototype.fromBytes" id="apidoc.element.openpgp.MPI.prototype.fromBytes">
        function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>fromBytes
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromBytes = function (bytes) {
  this.data = new _jsbn2.default(_util2.default.hexstrdump(bytes), 16);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.MPI.prototype.read" id="apidoc.element.openpgp.MPI.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {

  if (typeof bytes === 'string' || String.prototype.isPrototypeOf(bytes)) {
    bytes = _util2.default.str2Uint8Array(bytes);
  }

  var bits = bytes[0] &lt;&lt; 8 | bytes[1];

  // Additional rules:
  //
  //    The size of an MPI is ((MPI.length + 7) / 8) + 2 octets.
  //
  //    The length field of an MPI describes the length starting from its
  //    most significant non-zero bit.  Thus, the MPI [00 02 01] is not
  //    formed correctly.  It should be [00 01 01].

  // TODO: Verification of this size method! This size calculation as
  //      specified above is not applicable in JavaScript
  var bytelen = Math.ceil(bits / 8);

  var raw = _util2.default.Uint8Array2str(bytes.subarray(2, 2 + bytelen));
  this.fromBytes(raw);

  return 2 + bytelen;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.MPI.prototype.toBigInteger" id="apidoc.element.openpgp.MPI.prototype.toBigInteger">
        function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>toBigInteger
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBigInteger = function () {
  return this.data.clone();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.MPI.prototype.toBytes" id="apidoc.element.openpgp.MPI.prototype.toBytes">
        function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>toBytes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBytes = function () {
  var bytes = _util2.default.Uint8Array2str(this.write());
  return bytes.substr(2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.MPI.prototype.write" id="apidoc.element.openpgp.MPI.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  return _util2.default.str2Uint8Array(this.data.toMPI());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.S2K" id="apidoc.module.openpgp.S2K">module openpgp.S2K</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.S2K.S2K" id="apidoc.element.openpgp.S2K.S2K">
        function <span class="apidocSignatureSpan">openpgp.</span>S2K
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function S2K() {
<span class="apidocCodeCommentSpan">  /** @type {module:enums.hash} */
</span>  this.algorithm = 'sha256';
  /** @type {module:enums.s2k} */
  this.type = 'iterated';
  this.c = 96;
  /** Eight bytes of salt in a binary string.
   * @type {String}
   */
  this.salt = _crypto2.default.random.getRandomBytes(8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.S2K.fromClone" id="apidoc.element.openpgp.S2K.fromClone">
        function <span class="apidocSignatureSpan">openpgp.S2K.</span>fromClone
        <span class="apidocSignatureSpan">(clone)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromClone = function (clone) {
  var s2k = new S2K();
  s2k.algorithm = clone.algorithm;
  s2k.type = clone.type;
  s2k.c = clone.c;
  s2k.salt = clone.salt;
  return s2k;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.S2K.prototype" id="apidoc.module.openpgp.S2K.prototype">module openpgp.S2K.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.S2K.prototype.get_count" id="apidoc.element.openpgp.S2K.prototype.get_count">
        function <span class="apidocSignatureSpan">openpgp.S2K.prototype.</span>get_count
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_count = function () {
  // Exponent bias, defined in RFC4880
  var expbias = 6;

  return 16 + (this.c &amp; 15) &lt;&lt; (this.c &gt;&gt; 4) + expbias;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.S2K.prototype.produce_key" id="apidoc.element.openpgp.S2K.prototype.produce_key">
        function <span class="apidocSignatureSpan">openpgp.S2K.prototype.</span>produce_key
        <span class="apidocSignatureSpan">(passphrase, numBytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">produce_key = function (passphrase, numBytes) {
  passphrase = _util2.default.str2Uint8Array(_util2.default.encode_utf8(passphrase));

  function round(prefix, s2k) {
    var algorithm = _enums2.default.write(_enums2.default.hash, s2k.algorithm);

    switch (s2k.type) {
      case 'simple':
        return _crypto2.default.hash.digest(algorithm, _util2.default.concatUint8Array([prefix, passphrase]));

      case 'salted':
        return _crypto2.default.hash.digest(algorithm, _util2.default.concatUint8Array([prefix, s2k.salt, passphrase]));

      case 'iterated':
        var isp = [],
            count = s2k.get_count(),
            data = _util2.default.concatUint8Array([s2k.salt, passphrase]);

        while (isp.length * data.length &lt; count) {
          isp.push(data);
        }

        isp = _util2.default.concatUint8Array(isp);

        if (isp.length &gt; count) {
          isp = isp.subarray(0, count);
        }

        return _crypto2.default.hash.digest(algorithm, _util2.default.concatUint8Array([prefix, isp]));

      case 'gnu':
        throw new Error("GNU s2k type not supported.");

      default:
        throw new Error("Unknown s2k type.");
    }
  }

  var arr = [],
      rlength = 0,
      prefix = new Uint8Array(numBytes);

  for (var i = 0; i &lt; numBytes; i++) {
    prefix[i] = 0;
  }
  i = 0;

  while (rlength &lt; numBytes) {
    var result = round(prefix.subarray(0, i), this);
    arr.push(result);
    rlength += result.length;
    i++;
  }

  return _util2.default.concatUint8Array(arr).subarray(0, numBytes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.S2K.prototype.read" id="apidoc.element.openpgp.S2K.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.S2K.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  var i = 0;
  this.type = _enums2.default.read(_enums2.default.s2k, bytes[i++]);
  this.algorithm = _enums2.default.read(_enums2.default.hash, bytes[i++]);

  switch (this.type) {
    case 'simple':
      break;

    case 'salted':
      this.salt = bytes.subarray(i, i + 8);
      i += 8;
      break;

    case 'iterated':
      this.salt = bytes.subarray(i, i + 8);
      i += 8;

      // Octet 10: count, a one-octet, coded value
      this.c = bytes[i++];
      break;

    case 'gnu':
      if (_util2.default.Uint8Array2str(bytes.subarray(i, 3)) === "GNU") {
        i += 3; // GNU
        var gnuExtType = 1000 + bytes[i++];
        if (gnuExtType === 1001) {
          this.type = gnuExtType;
          // GnuPG extension mode 1001 -- don't write secret key at all
        } else {
          throw new Error("Unknown s2k gnu protection mode.");
        }
      } else {
        throw new Error("Unknown s2k type.");
      }
      break;

    default:
      throw new Error("Unknown s2k type.");
  }

  return i;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.S2K.prototype.write" id="apidoc.element.openpgp.S2K.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.S2K.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {

  var arr = [new Uint8Array([_enums2.default.write(_enums2.default.s2k, this.type), _enums2.default.write(_enums2.default.hash,
this.algorithm)])];

  switch (this.type) {
    case 'simple':
      break;
    case 'salted':
      arr.push(this.salt);
      break;
    case 'iterated':
      arr.push(this.salt);
      arr.push(new Uint8Array([this.c]));
      break;
    case 'gnu':
      throw new Error("GNU s2k type not supported.");
    default:
      throw new Error("Unknown s2k type.");
  }

  return _util2.default.concatUint8Array(arr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.armor" id="apidoc.module.openpgp.armor">module openpgp.armor</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.armor.decode" id="apidoc.element.openpgp.armor.decode">
        function <span class="apidocSignatureSpan">openpgp.armor.</span>decode
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dearmor(text) {
  var reSplit = /^-----[^-]+-----$\n/m;

  // remove trailing whitespace at end of line
  text = text.replace(/[\t\r ]+\n/g, '\n');

  var type = getType(text);

  var splittext = text.split(reSplit);

  // IE has a bug in split with a re. If the pattern matches the beginning of the
  // string it doesn't create an empty array element 0. So we need to detect this
  // so we know the index of the data we are interested in.
  var indexBase = 1;

  var result, checksum, msg;

  if (text.search(reSplit) !== splittext[0].length) {
    indexBase = 0;
  }

  if (type !== 2) {
    msg = splitHeaders(splittext[indexBase]);
    var msg_sum = splitChecksum(msg.body);

    result = {
      data: _base2.default.decode(msg_sum.body),
      headers: msg.headers,
      type: type
    };

    checksum = msg_sum.checksum;
  } else {
    // Reverse dash-escaping for msg
    msg = splitHeaders(splittext[indexBase].replace(/^- /mg, ''));
    var sig = splitHeaders(splittext[indexBase + 1].replace(/^- /mg, ''));
    verifyHeaders(sig.headers);
    var sig_sum = splitChecksum(sig.body);

    result = {
      text: msg.body.replace(/\n$/, '').replace(/\n/g, "\r\n"),
      data: _base2.default.decode(sig_sum.body),
      headers: msg.headers,
      type: type
    };

    checksum = sig_sum.checksum;
  }

  checksum = checksum.substr(0, 4);

  if (!verifyCheckSum(result.data, checksum)) {
    throw new Error("Ascii armor integrity check on message failed: '" + checksum + "' should be '" + getCheckSum(result.data) + "'");
  }

  verifyHeaders(result.headers);

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.armor.encode" id="apidoc.element.openpgp.armor.encode">
        function <span class="apidocSignatureSpan">openpgp.armor.</span>encode
        <span class="apidocSignatureSpan">(messagetype, body, partindex, parttotal)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function armor(messagetype, body, partindex, parttotal) {
  var result = [];
  switch (messagetype) {
    case _enums2.default.armor.multipart_section:
      result.push("-----BEGIN PGP MESSAGE, PART " + partindex + "/" + parttotal + "-----\r\n");
      result.push(addheader());
      result.push(_base2.default.encode(body));
      result.push("\r\n=" + getCheckSum(body) + "\r\n");
      result.push("-----END PGP MESSAGE, PART " + partindex + "/" + parttotal + "-----\r\n");
      break;
    case _enums2.default.armor.multipart_last:
      result.push("-----BEGIN PGP MESSAGE, PART " + partindex + "-----\r\n");
      result.push(addheader());
      result.push(_base2.default.encode(body));
      result.push("\r\n=" + getCheckSum(body) + "\r\n");
      result.push("-----END PGP MESSAGE, PART " + partindex + "-----\r\n");
      break;
    case _enums2.default.armor.signed:
      result.push("\r\n-----BEGIN PGP SIGNED MESSAGE-----\r\n");
      result.push("Hash: " + body.hash + "\r\n\r\n");
      result.push(body.text.replace(/\n-/g, "\n- -"));
      result.push("\r\n-----BEGIN PGP SIGNATURE-----\r\n");
      result.push(addheader());
      result.push(_base2.default.encode(body.data));
      result.push("\r\n=" + getCheckSum(body.data) + "\r\n");
      result.push("-----END PGP SIGNATURE-----\r\n");
      break;
    case _enums2.default.armor.message:
      result.push("-----BEGIN PGP MESSAGE-----\r\n");
      result.push(addheader());
      result.push(_base2.default.encode(body));
      result.push("\r\n=" + getCheckSum(body) + "\r\n");
      result.push("-----END PGP MESSAGE-----\r\n");
      break;
    case _enums2.default.armor.public_key:
      result.push("-----BEGIN PGP PUBLIC KEY BLOCK-----\r\n");
      result.push(addheader());
      result.push(_base2.default.encode(body));
      result.push("\r\n=" + getCheckSum(body) + "\r\n");
      result.push("-----END PGP PUBLIC KEY BLOCK-----\r\n\r\n");
      break;
    case _enums2.default.armor.private_key:
      result.push("-----BEGIN PGP PRIVATE KEY BLOCK-----\r\n");
      result.push(addheader());
      result.push(_base2.default.encode(body));
      result.push("\r\n=" + getCheckSum(body) + "\r\n");
      result.push("-----END PGP PRIVATE KEY BLOCK-----\r\n");
      break;
    case _enums2.default.armor.signature:
      result.push("-----BEGIN PGP SIGNATURE-----\r\n");
      result.push(addheader());
      result.push(_base2.default.encode(body));
      result.push("\r\n=" + getCheckSum(body) + "\r\n");
      result.push("-----END PGP SIGNATURE-----\r\n");
      break;
  }

  return result.join('');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.cleartext" id="apidoc.module.openpgp.cleartext">module openpgp.cleartext</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.cleartext.CleartextMessage" id="apidoc.element.openpgp.cleartext.CleartextMessage">
        function <span class="apidocSignatureSpan">openpgp.cleartext.</span>CleartextMessage
        <span class="apidocSignatureSpan">(text, signature)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CleartextMessage(text, signature) {
  if (!(this instanceof CleartextMessage)) {
    return new CleartextMessage(text, signature);
  }
  // normalize EOL to canonical form &lt;CR&gt;&lt;LF&gt;
  this.text = text.replace(/\r/g, '').replace(/[\t ]+\n/g, "\n").replace(/\n/g, "\r\n");
  if (signature &amp;&amp; !(signature instanceof sigModule.Signature)) {
    throw new Error('Invalid signature input');
  }
  this.signature = signature || new sigModule.Signature(new _packet2.default.List());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.cleartext.readArmored" id="apidoc.element.openpgp.cleartext.readArmored">
        function <span class="apidocSignatureSpan">openpgp.cleartext.</span>readArmored
        <span class="apidocSignatureSpan">(armoredText)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readArmored(armoredText) {
  var input = _armor2.default.decode(armoredText);
  if (input.type !== _enums2.default.armor.signed) {
    throw new Error('No cleartext signed message.');
  }
  var packetlist = new _packet2.default.List();
  packetlist.read(input.data);
  verifyHeaders(input.headers, packetlist);
  var signature = new sigModule.Signature(packetlist);
  var newMessage = new CleartextMessage(input.text, signature);
  return newMessage;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var options, encrypted;

var pubkey = '-----BEGIN PGP PUBLIC KEY BLOCK ... END PGP PUBLIC KEY BLOCK-----';
var privkey = '-----BEGIN PGP PRIVATE KEY BLOCK ... END PGP PRIVATE KEY BLOCK-----'; //encrypted private key
var passphrase = 'secret passphrase'; //what the privKey is encrypted with

var privKeyObj = openpgp.key.<span class="apidocCodeKeywordSpan">readArmored</span>(privkey).keys[0];
privKeyObj.decrypt(passphrase);

options = {
    data: 'Hello, World!',                             // input as String (or Uint8Array)
    publicKeys: openpgp.key.readArmored(pubkey).keys,  // for encryption
    privateKeys: privKeyObj // for signing (optional)
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.cleartext.CleartextMessage" id="apidoc.module.openpgp.cleartext.CleartextMessage">module openpgp.cleartext.CleartextMessage</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.cleartext.CleartextMessage.CleartextMessage" id="apidoc.element.openpgp.cleartext.CleartextMessage.CleartextMessage">
        function <span class="apidocSignatureSpan">openpgp.cleartext.</span>CleartextMessage
        <span class="apidocSignatureSpan">(text, signature)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CleartextMessage(text, signature) {
  if (!(this instanceof CleartextMessage)) {
    return new CleartextMessage(text, signature);
  }
  // normalize EOL to canonical form &lt;CR&gt;&lt;LF&gt;
  this.text = text.replace(/\r/g, '').replace(/[\t ]+\n/g, "\n").replace(/\n/g, "\r\n");
  if (signature &amp;&amp; !(signature instanceof sigModule.Signature)) {
    throw new Error('Invalid signature input');
  }
  this.signature = signature || new sigModule.Signature(new _packet2.default.List());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.cleartext.CleartextMessage.prototype" id="apidoc.module.openpgp.cleartext.CleartextMessage.prototype">module openpgp.cleartext.CleartextMessage.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.armor" id="apidoc.element.openpgp.cleartext.CleartextMessage.prototype.armor">
        function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>armor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">armor = function () {
  var body = {
    hash: _enums2.default.read(_enums2.default.hash, _config2.default.prefer_hash_algorithm).toUpperCase(),
    text: this.text,
    data: this.signature.packets.write()
  };
  return _armor2.default.encode(_enums2.default.armor.signed, body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.getSigningKeyIds" id="apidoc.element.openpgp.cleartext.CleartextMessage.prototype.getSigningKeyIds">
        function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>getSigningKeyIds
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSigningKeyIds = function () {
  var keyIds = [];
  var signatureList = this.signature.packets;
  signatureList.forEach(function (packet) {
    keyIds.push(packet.issuerKeyId);
  });
  return keyIds;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.getText" id="apidoc.element.openpgp.cleartext.CleartextMessage.prototype.getText">
        function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>getText
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getText = function () {
  // normalize end of line to \n
  return this.text.replace(/\r\n/g, "\n");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.sign" id="apidoc.element.openpgp.cleartext.CleartextMessage.prototype.sign">
        function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>sign
        <span class="apidocSignatureSpan">(privateKeys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sign = function (privateKeys) {
  this.signature = this.signDetached(privateKeys);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
options = {
data: 'Hello, World!',                             // input as String (or Uint8Array)
privateKeys: privKeyObj // for signing
};

openpgp.<span class="apidocCodeKeywordSpan">sign</span>(options).then(function(signed) {
cleartext = signed.data; // '-----BEGIN PGP SIGNED MESSAGE ... END PGP SIGNATURE-----'
});
```

```js
options = {
message: openpgp.cleartext.readArmored(cleartext), // parse armored message
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.signDetached" id="apidoc.element.openpgp.cleartext.CleartextMessage.prototype.signDetached">
        function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>signDetached
        <span class="apidocSignatureSpan">(privateKeys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">signDetached = function (privateKeys) {
  var packetlist = new _packet2.default.List();
  var literalDataPacket = new _packet2.default.Literal();
  literalDataPacket.setText(this.text);
  for (var i = 0; i &lt; privateKeys.length; i++) {
    if (privateKeys[i].isPublic()) {
      throw new Error('Need private key for signing');
    }
    var signaturePacket = new _packet2.default.Signature();
    signaturePacket.signatureType = _enums2.default.signature.text;
    signaturePacket.hashAlgorithm = _config2.default.prefer_hash_algorithm;
    var signingKeyPacket = privateKeys[i].getSigningKeyPacket();
    signaturePacket.publicKeyAlgorithm = signingKeyPacket.algorithm;
    if (!signingKeyPacket.isDecrypted) {
      throw new Error('Private key is not decrypted.');
    }
    signaturePacket.sign(signingKeyPacket, literalDataPacket);
    packetlist.push(signaturePacket);
  }
  return new sigModule.Signature(packetlist);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.verify" id="apidoc.element.openpgp.cleartext.CleartextMessage.prototype.verify">
        function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>verify
        <span class="apidocSignatureSpan">(keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verify = function (keys) {
  return this.verifyDetached(this.signature, keys);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
options = {
    message: openpgp.cleartext.readArmored(cleartext), // parse armored message
    publicKeys: openpgp.key.readArmored(pubkey).keys   // for verification
};

openpgp.<span class="apidocCodeKeywordSpan">verify</span>(options).then(function(verified) {
	validity = verified.signatures[0].valid; // true
	if (validity) {
		console.log('signed by key id ' + verified.signatures[0].keyid.toHex());
	}
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.verifyDetached" id="apidoc.element.openpgp.cleartext.CleartextMessage.prototype.verifyDetached">
        function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>verifyDetached
        <span class="apidocSignatureSpan">(signature, keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verifyDetached = function (signature, keys) {
  var result = [];
  var signatureList = signature.packets;
  var literalDataPacket = new _packet2.default.Literal();
  // we assume that cleartext signature is generated based on UTF8 cleartext
  literalDataPacket.setText(this.text);
  for (var i = 0; i &lt; signatureList.length; i++) {
    var keyPacket = null;
    for (var j = 0; j &lt; keys.length; j++) {
      keyPacket = keys[j].getSigningKeyPacket(signatureList[i].issuerKeyId);
      if (keyPacket) {
        break;
      }
    }

    var verifiedSig = {};
    if (keyPacket) {
      verifiedSig.keyid = signatureList[i].issuerKeyId;
      verifiedSig.valid = signatureList[i].verify(keyPacket, literalDataPacket);
    } else {
      verifiedSig.keyid = signatureList[i].issuerKeyId;
      verifiedSig.valid = null;
    }
    verifiedSig.signature = new sigModule.Signature([signatureList[i]]);

    result.push(verifiedSig);
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.crypto" id="apidoc.module.openpgp.crypto">module openpgp.crypto</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.crypto.generateMpi" id="apidoc.element.openpgp.crypto.generateMpi">
        function <span class="apidocSignatureSpan">openpgp.crypto.</span>generateMpi
        <span class="apidocSignatureSpan">(algo, bits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generateMpi(algo, bits) {
  switch (algo) {
    case 'rsa_encrypt':
    case 'rsa_encrypt_sign':
    case 'rsa_sign':
      //remember "publicKey" refers to the crypto/public_key dir
      var rsa = new _public_key2.default.rsa();
      return rsa.generate(bits, "10001").then(function (keyObject) {
        var output = [];
        output.push(keyObject.n);
        output.push(keyObject.ee);
        output.push(keyObject.d);
        output.push(keyObject.p);
        output.push(keyObject.q);
        output.push(keyObject.u);
        return mapResult(output);
      });
    default:
      throw new Error('Unsupported algorithm for key generation.');
  }

  function mapResult(result) {
    return result.map(function (bn) {
      var mpi = new _mpi2.default();
      mpi.fromBigInteger(bn);
      return mpi;
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.generateSessionKey" id="apidoc.element.openpgp.crypto.generateSessionKey">
        function <span class="apidocSignatureSpan">openpgp.crypto.</span>generateSessionKey
        <span class="apidocSignatureSpan">(algo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generateSessionKey(algo) {
  return _random2.default.getRandomBytes(_cipher2.default[algo].keySize);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.getPrefixRandom" id="apidoc.element.openpgp.crypto.getPrefixRandom">
        function <span class="apidocSignatureSpan">openpgp.crypto.</span>getPrefixRandom
        <span class="apidocSignatureSpan">(algo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getPrefixRandom(algo) {
  return _random2.default.getRandomBytes(_cipher2.default[algo].blockSize);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.getPrivateMpiCount" id="apidoc.element.openpgp.crypto.getPrivateMpiCount">
        function <span class="apidocSignatureSpan">openpgp.crypto.</span>getPrivateMpiCount
        <span class="apidocSignatureSpan">(algo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getPrivateMpiCount(algo) {
  switch (algo) {
    case 'rsa_encrypt':
    case 'rsa_encrypt_sign':
    case 'rsa_sign':
      //   Algorithm-Specific Fields for RSA secret keys:
      //   - multiprecision integer (MPI) of RSA secret exponent d.
      //   - MPI of RSA secret prime value p.
      //   - MPI of RSA secret prime value q (p &lt; q).
      //   - MPI of u, the multiplicative inverse of p, mod q.
      return 4;
    case 'elgamal':
      // Algorithm-Specific Fields for Elgamal secret keys:
      //   - MPI of Elgamal secret exponent x.
      return 1;
    case 'dsa':
      // Algorithm-Specific Fields for DSA secret keys:
      //   - MPI of DSA secret exponent x.
      return 1;
    default:
      throw new Error('Unknown algorithm');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.getPublicMpiCount" id="apidoc.element.openpgp.crypto.getPublicMpiCount">
        function <span class="apidocSignatureSpan">openpgp.crypto.</span>getPublicMpiCount
        <span class="apidocSignatureSpan">(algo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getPublicMpiCount(algo) {
  // - A series of multiprecision integers comprising the key material:
  //   Algorithm-Specific Fields for RSA public keys:
  //       - a multiprecision integer (MPI) of RSA public modulus n;
  //       - an MPI of RSA public encryption exponent e.
  switch (algo) {
    case 'rsa_encrypt':
    case 'rsa_encrypt_sign':
    case 'rsa_sign':
      return 2;

    //   Algorithm-Specific Fields for Elgamal public keys:
    //     - MPI of Elgamal prime p;
    //     - MPI of Elgamal group generator g;
    //     - MPI of Elgamal public key value y (= g**x mod p where x  is secret).
    case 'elgamal':
      return 3;

    //   Algorithm-Specific Fields for DSA public keys:
    //       - MPI of DSA prime p;
    //       - MPI of DSA group order q (q is a prime divisor of p-1);
    //       - MPI of DSA group generator g;
    //       - MPI of DSA public-key value y (= g**x mod p where x  is secret).
    case 'dsa':
      return 4;

    default:
      throw new Error('Unknown algorithm.');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.publicKeyDecrypt" id="apidoc.element.openpgp.crypto.publicKeyDecrypt">
        function <span class="apidocSignatureSpan">openpgp.crypto.</span>publicKeyDecrypt
        <span class="apidocSignatureSpan">(algo, keyIntegers, dataIntegers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function publicKeyDecrypt(algo, keyIntegers, dataIntegers) {
  var p;

  var bn = function () {
    switch (algo) {
      case 'rsa_encrypt_sign':
      case 'rsa_encrypt':
        var rsa = new _public_key2.default.rsa();
        // 0 and 1 are the public key.
        var n = keyIntegers[0].toBigInteger();
        var e = keyIntegers[1].toBigInteger();
        // 2 to 5 are the private key.
        var d = keyIntegers[2].toBigInteger();
        p = keyIntegers[3].toBigInteger();
        var q = keyIntegers[4].toBigInteger();
        var u = keyIntegers[5].toBigInteger();
        var m = dataIntegers[0].toBigInteger();
        return rsa.decrypt(m, n, e, d, p, q, u);
      case 'elgamal':
        var elgamal = new _public_key2.default.elgamal();
        var x = keyIntegers[3].toBigInteger();
        var c1 = dataIntegers[0].toBigInteger();
        var c2 = dataIntegers[1].toBigInteger();
        p = keyIntegers[0].toBigInteger();
        return elgamal.decrypt(c1, c2, p, x);
      default:
        return null;
    }
  }();

  var result = new _mpi2.default();
  result.fromBigInteger(bn);
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.publicKeyEncrypt" id="apidoc.element.openpgp.crypto.publicKeyEncrypt">
        function <span class="apidocSignatureSpan">openpgp.crypto.</span>publicKeyEncrypt
        <span class="apidocSignatureSpan">(algo, publicMPIs, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function publicKeyEncrypt(algo, publicMPIs, data) {
  var result = function () {
    var m;
    switch (algo) {
      case 'rsa_encrypt':
      case 'rsa_encrypt_sign':
        var rsa = new _public_key2.default.rsa();
        var n = publicMPIs[0].toBigInteger();
        var e = publicMPIs[1].toBigInteger();
        m = data.toBigInteger();
        return [rsa.encrypt(m, e, n)];

      case 'elgamal':
        var elgamal = new _public_key2.default.elgamal();
        var p = publicMPIs[0].toBigInteger();
        var g = publicMPIs[1].toBigInteger();
        var y = publicMPIs[2].toBigInteger();
        m = data.toBigInteger();
        return elgamal.encrypt(m, g, p, y);

      default:
        return [];
    }
  }();

  return result.map(function (bn) {
    var mpi = new _mpi2.default();
    mpi.fromBigInteger(bn);
    return mpi;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.crypto.cfb" id="apidoc.module.openpgp.crypto.cfb">module openpgp.crypto.cfb</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.crypto.cfb.decrypt" id="apidoc.element.openpgp.crypto.cfb.decrypt">
        function <span class="apidocSignatureSpan">openpgp.crypto.cfb.</span>decrypt
        <span class="apidocSignatureSpan">(cipherfn, key, ciphertext, resync)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decrypt(cipherfn, key, ciphertext, resync) {
  cipherfn = new _cipher2.default[cipherfn](key);
  var block_size = cipherfn.blockSize;

  var iblock = new Uint8Array(block_size);
  var ablock = new Uint8Array(block_size);

  var i, j, n;
  var text = new Uint8Array(ciphertext.length - block_size);

  // initialisation vector
  for (i = 0; i &lt; block_size; i++) {
    iblock[i] = 0;
  }

  iblock = cipherfn.encrypt(iblock);
  for (i = 0; i &lt; block_size; i++) {
    ablock[i] = ciphertext[i];
    iblock[i] ^= ablock[i];
  }

  ablock = cipherfn.encrypt(ablock);

  // test check octets
  if (iblock[block_size - 2] !== (ablock[0] ^ ciphertext[block_size]) || iblock[block_size - 1] !== (ablock[1] ^ ciphertext[block_size
 + 1])) {
    throw new Error('CFB decrypt: invalid key');
  }

<span class="apidocCodeCommentSpan">  /*  RFC4880: Tag 18 and Resync:
   *  [...] Unlike the Symmetrically Encrypted Data Packet, no
   *  special CFB resynchronization is done after encrypting this prefix
   *  data.  See "OpenPGP CFB Mode" below for more details.
    */
</span>
  j = 0;
  if (resync) {
    for (i = 0; i &lt; block_size; i++) {
      iblock[i] = ciphertext[i + 2];
    }
    for (n = block_size + 2; n &lt; ciphertext.length; n += block_size) {
      ablock = cipherfn.encrypt(iblock);

      for (i = 0; i &lt; block_size &amp;&amp; i + n &lt; ciphertext.length; i++) {
        iblock[i] = ciphertext[n + i];
        if (j &lt; text.length) {
          text[j] = ablock[i] ^ iblock[i];
          j++;
        }
      }
    }
  } else {
    for (i = 0; i &lt; block_size; i++) {
      iblock[i] = ciphertext[i];
    }
    for (n = block_size; n &lt; ciphertext.length; n += block_size) {
      ablock = cipherfn.encrypt(iblock);
      for (i = 0; i &lt; block_size &amp;&amp; i + n &lt; ciphertext.length; i++) {
        iblock[i] = ciphertext[n + i];
        if (j &lt; text.length) {
          text[j] = ablock[i] ^ iblock[i];
          j++;
        }
      }
    }
  }

  n = resync ? 0 : 2;

  text = text.subarray(n, ciphertext.length - block_size - 2 + n);

  return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
options = {
    message: openpgp.message.read(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.<span class="apidocCodeKeywordSpan">decrypt</span>(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
```

#### Encrypt and decrypt *String* data with PGP keys

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.cfb.encrypt" id="apidoc.element.openpgp.crypto.cfb.encrypt">
        function <span class="apidocSignatureSpan">openpgp.crypto.cfb.</span>encrypt
        <span class="apidocSignatureSpan">(prefixrandom, cipherfn, plaintext, key, resync)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encrypt(prefixrandom, cipherfn, plaintext, key, resync) {
  cipherfn = new _cipher2.default[cipherfn](key);
  var block_size = cipherfn.blockSize;

  var FR = new Uint8Array(block_size);
  var FRE = new Uint8Array(block_size);

  var new_prefix = new Uint8Array(prefixrandom.length + 2);
  new_prefix.set(prefixrandom);
  new_prefix[prefixrandom.length] = prefixrandom[block_size - 2];
  new_prefix[prefixrandom.length + 1] = prefixrandom[block_size - 1];
  prefixrandom = new_prefix;

  var ciphertext = new Uint8Array(plaintext.length + 2 + block_size * 2);
  var i, n, begin;
  var offset = resync ? 0 : 2;

  // 1.  The feedback register (FR) is set to the IV, which is all zeros.
  for (i = 0; i &lt; block_size; i++) {
    FR[i] = 0;
  }

  // 2.  FR is encrypted to produce FRE (FR Encrypted).  This is the
  //     encryption of an all-zero value.
  FRE = cipherfn.encrypt(FR);
  // 3.  FRE is xored with the first BS octets of random data prefixed to
  //     the plaintext to produce C[1] through C[BS], the first BS octets
  //     of ciphertext.
  for (i = 0; i &lt; block_size; i++) {
    ciphertext[i] = FRE[i] ^ prefixrandom[i];
  }

  // 4.  FR is loaded with C[1] through C[BS].
  FR.set(ciphertext.subarray(0, block_size));

  // 5.  FR is encrypted to produce FRE, the encryption of the first BS
  //     octets of ciphertext.
  FRE = cipherfn.encrypt(FR);

  // 6.  The left two octets of FRE get xored with the next two octets of
  //     data that were prefixed to the plaintext.  This produces C[BS+1]
  //     and C[BS+2], the next two octets of ciphertext.
  ciphertext[block_size] = FRE[0] ^ prefixrandom[block_size];
  ciphertext[block_size + 1] = FRE[1] ^ prefixrandom[block_size + 1];

  if (resync) {
    // 7.  (The resync step) FR is loaded with C[3] through C[BS+2].
    FR.set(ciphertext.subarray(2, block_size + 2));
  } else {
    FR.set(ciphertext.subarray(0, block_size));
  }
  // 8.  FR is encrypted to produce FRE.
  FRE = cipherfn.encrypt(FR);

  // 9.  FRE is xored with the first BS octets of the given plaintext, now
  //     that we have finished encrypting the BS+2 octets of prefixed
  //     data.  This produces C[BS+3] through C[BS+(BS+2)], the next BS
  //     octets of ciphertext.
  for (i = 0; i &lt; block_size; i++) {
    ciphertext[block_size + 2 + i] = FRE[i + offset] ^ plaintext[i];
  }
  for (n = block_size; n &lt; plaintext.length + offset; n += block_size) {
    // 10. FR is loaded with C[BS+3] to C[BS + (BS+2)] (which is C11-C18 for
    // an 8-octet block).
    begin = n + 2 - offset;
    FR.set(ciphertext.subarray(begin, begin + block_size));

    // 11. FR is encrypted to produce FRE.
    FRE = cipherfn.encrypt(FR);

    // 12. FRE is xored with the next BS octets of plaintext, to produce
    // the next BS octets of ciphertext.  These are loaded into FR, and
    // the process is repeated until the plaintext is used up.
    for (i = 0; i &lt; block_size; i++) {
      ciphertext[block_size + begin + i] = FRE[i] ^ plaintext[n + i - offset];
    }
  }

  ciphertext = ciphertext.subarray(0, plaintext.length + 2 + block_size);
  return ciphertext;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.<span class="apidocCodeKeywordSpan">encrypt</span>(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.cfb.mdc" id="apidoc.element.openpgp.crypto.cfb.mdc">
        function <span class="apidocSignatureSpan">openpgp.crypto.cfb.</span>mdc
        <span class="apidocSignatureSpan">(cipherfn, key, ciphertext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mdc(cipherfn, key, ciphertext) {
  cipherfn = new _cipher2.default[cipherfn](key);
  var block_size = cipherfn.blockSize;

  var iblock = new Uint8Array(block_size);
  var ablock = new Uint8Array(block_size);
  var i;

  // initialisation vector
  for (i = 0; i &lt; block_size; i++) {
    iblock[i] = 0;
  }

  iblock = cipherfn.encrypt(iblock);
  for (i = 0; i &lt; block_size; i++) {
    ablock[i] = ciphertext[i];
    iblock[i] ^= ablock[i];
  }

  ablock = cipherfn.encrypt(ablock);

  var result = new Uint8Array(iblock.length + 2);
  result.set(iblock);
  result[iblock.length] = ablock[0] ^ ciphertext[block_size];
  result[iblock.length + 1] = ablock[1] ^ ciphertext[block_size + 1];
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.cfb.normalDecrypt" id="apidoc.element.openpgp.crypto.cfb.normalDecrypt">
        function <span class="apidocSignatureSpan">openpgp.crypto.cfb.</span>normalDecrypt
        <span class="apidocSignatureSpan">(cipherfn, key, ciphertext, iv)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function normalDecrypt(cipherfn, key, ciphertext, iv) {
  cipherfn = new _cipher2.default[cipherfn](key);
  var block_size = cipherfn.blockSize;

  var blockp;
  var pos = 0;
  var plaintext = new Uint8Array(ciphertext.length);
  var offset = 0;
  var i,
      j = 0;

  if (iv === null) {
    blockp = new Uint8Array(block_size);
    for (i = 0; i &lt; block_size; i++) {
      blockp[i] = 0;
    }
  } else {
    blockp = iv.subarray(0, block_size);
  }
  while (ciphertext.length &gt; block_size * pos) {
    var decblock = cipherfn.encrypt(blockp);
    blockp = ciphertext.subarray(pos * block_size + offset, pos * block_size + block_size + offset);
    for (i = 0; i &lt; blockp.length; i++) {
      plaintext[j++] = blockp[i] ^ decblock[i];
    }
    pos++;
  }

  return plaintext;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.cfb.normalEncrypt" id="apidoc.element.openpgp.crypto.cfb.normalEncrypt">
        function <span class="apidocSignatureSpan">openpgp.crypto.cfb.</span>normalEncrypt
        <span class="apidocSignatureSpan">(cipherfn, key, plaintext, iv)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function normalEncrypt(cipherfn, key, plaintext, iv) {
  cipherfn = new _cipher2.default[cipherfn](key);
  var block_size = cipherfn.blockSize;

  var blocki = new Uint8Array(block_size);
  var blockc = new Uint8Array(block_size);
  var pos = 0;
  var cyphertext = new Uint8Array(plaintext.length);
  var i,
      j = 0;

  if (iv === null) {
    for (i = 0; i &lt; block_size; i++) {
      blockc[i] = 0;
    }
  } else {
    for (i = 0; i &lt; block_size; i++) {
      blockc[i] = iv[i];
    }
  }
  while (plaintext.length &gt; block_size * pos) {
    var encblock = cipherfn.encrypt(blockc);
    blocki = plaintext.subarray(pos * block_size, pos * block_size + block_size);
    for (i = 0; i &lt; blocki.length; i++) {
      blockc[i] = blocki[i] ^ encblock[i];
      cyphertext[j++] = blockc[i];
    }
    pos++;
  }
  return cyphertext;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.crypto.cipher" id="apidoc.module.openpgp.crypto.cipher">module openpgp.crypto.cipher</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.crypto.cipher.aes128" id="apidoc.element.openpgp.crypto.cipher.aes128">
        function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>aes128
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function c(key) {
  this.key = keyExpansion(key);
  this._temp = new Uint32Array(this.blockSize / 4);

  this.encrypt = function (block) {
    return AESencrypt(block, this.key, this._temp);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.cipher.aes192" id="apidoc.element.openpgp.crypto.cipher.aes192">
        function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>aes192
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function c(key) {
  this.key = keyExpansion(key);
  this._temp = new Uint32Array(this.blockSize / 4);

  this.encrypt = function (block) {
    return AESencrypt(block, this.key, this._temp);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.cipher.aes256" id="apidoc.element.openpgp.crypto.cipher.aes256">
        function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>aes256
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function c(key) {
  this.key = keyExpansion(key);
  this._temp = new Uint32Array(this.blockSize / 4);

  this.encrypt = function (block) {
    return AESencrypt(block, this.key, this._temp);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.cipher.blowfish" id="apidoc.element.openpgp.crypto.cipher.blowfish">
        function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>blowfish
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BF(key) {
  this.bf = new Blowfish();
  this.bf.init(key);

  this.encrypt = function (block) {
    return this.bf.encrypt_block(block);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.cipher.cast5" id="apidoc.element.openpgp.crypto.cipher.cast5">
        function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>cast5
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cast5(key) {
  this.cast5 = new OpenpgpSymencCast5();
  this.cast5.setKey(key);

  this.encrypt = function (block) {
    return this.cast5.encrypt(block);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.cipher.des" id="apidoc.element.openpgp.crypto.cipher.des">
        function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>des
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OriginalDes(key) {
  this.key = key;

  this.encrypt = function (block, padding) {
    var keys = des_createKeys(this.key);
    return des(keys, block, true, 0, null, padding);
  };

  this.decrypt = function (block, padding) {
    var keys = des_createKeys(this.key);
    return des(keys, block, false, 0, null, padding);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.cipher.idea" id="apidoc.element.openpgp.crypto.cipher.idea">
        function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>idea
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function idea() {
  throw new Error('IDEA symmetric-key algorithm not implemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.cipher.tripledes" id="apidoc.element.openpgp.crypto.cipher.tripledes">
        function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>tripledes
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Des(key) {
  this.key = [];

  for (var i = 0; i &lt; 3; i++) {
    this.key.push(new Uint8Array(key.subarray(i * 8, i * 8 + 8)));
  }

  this.encrypt = function (block) {
    return des(des_createKeys(this.key[2]), des(des_createKeys(this.key[1]), des(des_createKeys(this.key[0]), block, true, 0, null
, null), false, 0, null, null), true, 0, null, null);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.cipher.twofish" id="apidoc.element.openpgp.crypto.cipher.twofish">
        function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>twofish
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TF(key) {
  this.tf = createTwofish();
  this.tf.open(toArray(key), 0);

  this.encrypt = function (block) {
    return this.tf.encrypt(toArray(block), 0);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.crypto.gcm" id="apidoc.module.openpgp.crypto.gcm">module openpgp.crypto.gcm</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.crypto.gcm.decrypt" id="apidoc.element.openpgp.crypto.gcm.decrypt">
        function <span class="apidocSignatureSpan">openpgp.crypto.gcm.</span>decrypt
        <span class="apidocSignatureSpan">(cipher, ciphertext, key, iv)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decrypt(cipher, ciphertext, key, iv) {
  if (cipher.substr(0, 3) !== 'aes') {
    return Promise.reject(new Error('GCM mode supports only AES cipher'));
  }

  if (webCrypto &amp;&amp; _config2.default.use_native &amp;&amp; key.length !== 24) {
    // WebCrypto (no 192 bit support) see: https://www.chromium.org/blink/webcrypto#TOC-AES-support
    return webDecrypt(ciphertext, key, iv);
  } else if (nodeCrypto &amp;&amp; _config2.default.use_native) {
    // Node crypto library
    return nodeDecrypt(ciphertext, key, iv);
  } else {
    // asm.js fallback
    return Promise.resolve(_asmcryptoLite2.default.AES_GCM.decrypt(ciphertext, key, iv));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
options = {
    message: openpgp.message.read(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.<span class="apidocCodeKeywordSpan">decrypt</span>(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
```

#### Encrypt and decrypt *String* data with PGP keys

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.gcm.encrypt" id="apidoc.element.openpgp.crypto.gcm.encrypt">
        function <span class="apidocSignatureSpan">openpgp.crypto.gcm.</span>encrypt
        <span class="apidocSignatureSpan">(cipher, plaintext, key, iv)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encrypt(cipher, plaintext, key, iv) {
  if (cipher.substr(0, 3) !== 'aes') {
    return Promise.reject(new Error('GCM mode supports only AES cipher'));
  }

  if (webCrypto &amp;&amp; _config2.default.use_native &amp;&amp; key.length !== 24) {
    // WebCrypto (no 192 bit support) see: https://www.chromium.org/blink/webcrypto#TOC-AES-support
    return webEncrypt(plaintext, key, iv);
  } else if (nodeCrypto &amp;&amp; _config2.default.use_native) {
    // Node crypto library
    return nodeEncrypt(plaintext, key, iv);
  } else {
    // asm.js fallback
    return Promise.resolve(_asmcryptoLite2.default.AES_GCM.encrypt(plaintext, key, iv));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.<span class="apidocCodeKeywordSpan">encrypt</span>(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.crypto.hash" id="apidoc.module.openpgp.crypto.hash">module openpgp.crypto.hash</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.crypto.hash.digest" id="apidoc.element.openpgp.crypto.hash.digest">
        function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>digest
        <span class="apidocSignatureSpan">(algo, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function digest(algo, data) {
  switch (algo) {
    case 1:
      // - MD5 [HAC]
      return this.md5(data);
    case 2:
      // - SHA-1 [FIPS180]
      return this.sha1(data);
    case 3:
      // - RIPE-MD/160 [HAC]
      return this.ripemd(data);
    case 8:
      // - SHA256 [FIPS180]
      return this.sha256(data);
    case 9:
      // - SHA384 [FIPS180]
      return this.sha384(data);
    case 10:
      // - SHA512 [FIPS180]
      return this.sha512(data);
    case 11:
      // - SHA224 [FIPS180]
      return this.sha224(data);
    default:
      throw new Error('Invalid hash function.');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.hash.getHashByteLength" id="apidoc.element.openpgp.crypto.hash.getHashByteLength">
        function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>getHashByteLength
        <span class="apidocSignatureSpan">(algo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getHashByteLength(algo) {
  switch (algo) {
    case 1:
      // - MD5 [HAC]
      return 16;
    case 2:
    // - SHA-1 [FIPS180]
    case 3:
      // - RIPE-MD/160 [HAC]
      return 20;
    case 8:
      // - SHA256 [FIPS180]
      return 32;
    case 9:
      // - SHA384 [FIPS180]
      return 48;
    case 10:
      // - SHA512 [FIPS180]
      return 64;
    case 11:
      // - SHA224 [FIPS180]
      return 28;
    default:
      throw new Error('Invalid hash algorithm.');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.hash.md5" id="apidoc.element.openpgp.crypto.hash.md5">
        function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>md5
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">md5 = function (data) {
  var shasum = nodeCrypto.createHash(type);
  shasum.update(new Buffer(data));
  return new Uint8Array(shasum.digest());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.hash.ripemd" id="apidoc.element.openpgp.crypto.hash.ripemd">
        function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>ripemd
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ripemd = function (data) {
  var shasum = nodeCrypto.createHash(type);
  shasum.update(new Buffer(data));
  return new Uint8Array(shasum.digest());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.hash.sha1" id="apidoc.element.openpgp.crypto.hash.sha1">
        function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>sha1
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sha1 = function (data) {
  var shasum = nodeCrypto.createHash(type);
  shasum.update(new Buffer(data));
  return new Uint8Array(shasum.digest());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.hash.sha224" id="apidoc.element.openpgp.crypto.hash.sha224">
        function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>sha224
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sha224 = function (data) {
  var shasum = nodeCrypto.createHash(type);
  shasum.update(new Buffer(data));
  return new Uint8Array(shasum.digest());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.hash.sha256" id="apidoc.element.openpgp.crypto.hash.sha256">
        function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>sha256
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sha256 = function (data) {
  var shasum = nodeCrypto.createHash(type);
  shasum.update(new Buffer(data));
  return new Uint8Array(shasum.digest());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.hash.sha384" id="apidoc.element.openpgp.crypto.hash.sha384">
        function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>sha384
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sha384 = function (data) {
  var shasum = nodeCrypto.createHash(type);
  shasum.update(new Buffer(data));
  return new Uint8Array(shasum.digest());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.hash.sha512" id="apidoc.element.openpgp.crypto.hash.sha512">
        function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>sha512
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sha512 = function (data) {
  var shasum = nodeCrypto.createHash(type);
  shasum.update(new Buffer(data));
  return new Uint8Array(shasum.digest());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.crypto.publicKey" id="apidoc.module.openpgp.crypto.publicKey">module openpgp.crypto.publicKey</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.crypto.publicKey.dsa" id="apidoc.element.openpgp.crypto.publicKey.dsa">
        function <span class="apidocSignatureSpan">openpgp.crypto.publicKey.</span>dsa
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DSA() {
  // s1 = ((g**s) mod p) mod q
  // s1 = ((s**-1)*(sha-1(m)+(s1*x) mod q)
  function sign(hashalgo, m, g, p, q, x) {
    // If the output size of the chosen hash is larger than the number of
    // bits of q, the hash result is truncated to fit by taking the number
    // of leftmost bits equal to the number of bits of q.  This (possibly
    // truncated) hash function result is treated as a number and used
    // directly in the DSA signature algorithm.
    var hashed_data = _util2.default.getLeftNBits(_util2.default.Uint8Array2str(_hash2.default.digest(hashalgo, _util2.default.str2Uint8Array
(m))), q.bitLength());
    var hash = new _jsbn2.default(_util2.default.hexstrdump(hashed_data), 16);
    // FIPS-186-4, section 4.6:
    // The values of r and s shall be checked to determine if r = 0 or s = 0.
    // If either r = 0 or s = 0, a new value of k shall be generated, and the
    // signature shall be recalculated. It is extremely unlikely that r = 0
    // or s = 0 if signatures are generated properly.
    var k, s1, s2;
    while (true) {
      k = _random2.default.getRandomBigIntegerInRange(_jsbn2.default.ONE, q.subtract(_jsbn2.default.ONE));
      s1 = g.modPow(k, p).mod(q);
      s2 = k.modInverse(q).multiply(hash.add(x.multiply(s1))).mod(q);
      if (s1 !== 0 &amp;&amp; s2 !== 0) {
        break;
      }
    }
    var result = [];
    result[0] = s1.toMPI();
    result[1] = s2.toMPI();
    return result;
  }

  function select_hash_algorithm(q) {
    var usersetting = _config2.default.prefer_hash_algorithm;
<span class="apidocCodeCommentSpan">    /*
     * 1024-bit key, 160-bit q, SHA-1, SHA-224, SHA-256, SHA-384, or SHA-512 hash
     * 2048-bit key, 224-bit q, SHA-224, SHA-256, SHA-384, or SHA-512 hash
     * 2048-bit key, 256-bit q, SHA-256, SHA-384, or SHA-512 hash
     * 3072-bit key, 256-bit q, SHA-256, SHA-384, or SHA-512 hash
     */
</span>    switch (Math.round(q.bitLength() / 8)) {
      case 20:
        // 1024 bit
        if (usersetting !== 2 &amp;&amp; usersetting &gt; 11 &amp;&amp; usersetting !== 10 &amp;&amp; usersetting &lt; 8) {
          return 2; // prefer sha1
        }
        return usersetting;
      case 28:
        // 2048 bit
        if (usersetting &gt; 11 &amp;&amp; usersetting &lt; 8) {
          return 11;
        }
        return usersetting;
      case 32:
        // 4096 bit // prefer sha224
        if (usersetting &gt; 10 &amp;&amp; usersetting &lt; 8) {
          return 8; // prefer sha256
        }
        return usersetting;
      default:
        _util2.default.print_debug("DSA select hash algorithm: returning null for an unknown length of q");
        return null;
    }
  }
  this.select_hash_algorithm = select_hash_algorithm;

  function verify(hashalgo, s1, s2, m, p, q, g, y) {
    var hashed_data = _util2.default.getLeftNBits(_util2.default.Uint8Array2str(_hash2.default.digest(hashalgo, _util2.default.str2Uint8Array
(m))), q.bitLength());
    var hash = new _jsbn2.default(_util2.default.hexstrdump(hashed_data), 16);
    if (_jsbn2.default.ZERO.compareTo(s1) &gt;= 0 || s1.compareTo(q) &gt;= 0 || _jsbn2.default.ZERO.compareTo(s2) &gt;= 0 || s2.compareTo
(q) &gt;= 0) {
      _util2.default.print_debug("invalid DSA Signature");
      return null;
    }
    var w = s2.modInverse(q);
    if (_jsbn2.default.ZERO.compareTo(w) === 0) {
      _util2.default.print_debug("invalid DSA Signature");
      return null;
    }
    var u1 = hash.multiply(w).mod(q);
    var u2 = s1.multiply(w).mod(q);
    return g.modPow(u1, p).multiply(y.modPow(u2, p)).mod(p).mod(q);
  }

  this.sign = sign;
  this.verify = verify;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.publicKey.elgamal" id="apidoc.element.openpgp.crypto.publicKey.elgamal">
        function <span class="apidocSignatureSpan">openpgp.crypto.publicKey.</span>elgamal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Elgamal() {

  function encrypt(m, g, p, y) {
    //  choose k in {2,...,p-2}
    var pMinus2 = p.subtract(_jsbn2.default.TWO);
    var k = _random2.default.getRandomBigIntegerInRange(_jsbn2.default.ONE, pMinus2);
    k = k.mod(pMinus2).add(_jsbn2.default.ONE);
    var c = [];
    c[0] = g.modPow(k, p);
    c[1] = y.modPow(k, p).multiply(m).mod(p);
    return c;
  }

  function decrypt(c1, c2, p, x) {
    _util2.default.print_debug("Elgamal Decrypt:\nc1:" + _util2.default.hexstrdump(c1.toMPI()) + "\n" + "c2:" + _util2.default.hexstrdump
(c2.toMPI()) + "\n" + "p:" + _util2.default.hexstrdump(p.toMPI()) + "\n" + "x:" + _util2.default.hexstrdump(x.toMPI()));
    return c1.modPow(x, p).modInverse(p).multiply(c2).mod(p);
    //var c = c1.pow(x).modInverse(p); // c0^-a mod p
    //return c.multiply(c2).mod(p);
  }

  // signing and signature verification using Elgamal is not required by OpenPGP.
  this.encrypt = encrypt;
  this.decrypt = decrypt;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.publicKey.rsa" id="apidoc.element.openpgp.crypto.publicKey.rsa">
        function <span class="apidocSignatureSpan">openpgp.crypto.publicKey.</span>rsa
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RSA() {
<span class="apidocCodeCommentSpan">  /**
   * This function uses jsbn Big Num library to decrypt RSA
   * @param m
   *            message
   * @param n
   *            RSA public modulus n as BigInteger
   * @param e
   *            RSA public exponent as BigInteger
   * @param d
   *            RSA d as BigInteger
   * @param p
   *            RSA p as BigInteger
   * @param q
   *            RSA q as BigInteger
   * @param u
   *            RSA u as BigInteger
   * @return {BigInteger} The decrypted value of the message
   */
</span>  function decrypt(m, n, e, d, p, q, u) {
    if (_config2.default.rsa_blinding) {
      m = blind(m, n, e);
    }
    var xp = m.mod(p).modPow(d.mod(p.subtract(_jsbn2.default.ONE)), p);
    var xq = m.mod(q).modPow(d.mod(q.subtract(_jsbn2.default.ONE)), q);
    _util2.default.print_debug("rsa.js decrypt\nxpn:" + _util2.default.hexstrdump(xp.toMPI()) + "\nxqn:" + _util2.default.hexstrdump
(xq.toMPI()));

    var t = xq.subtract(xp);
    if (t[0] === 0) {
      t = xp.subtract(xq);
      t = t.multiply(u).mod(q);
      t = q.subtract(t);
    } else {
      t = t.multiply(u).mod(q);
    }
    t = t.multiply(p).add(xp);
    if (_config2.default.rsa_blinding) {
      t = unblind(t, n);
    }
    return t;
  }

  /**
   * encrypt message
   * @param m message as BigInteger
   * @param e public MPI part as BigInteger
   * @param n public MPI part as BigInteger
   * @return BigInteger
   */
  function encrypt(m, e, n) {
    return m.modPowInt(e, n);
  }

  /* Sign and Verify */
  function sign(m, d, n) {
    return m.modPow(d, n);
  }

  function verify(x, e, n) {
    return x.modPowInt(e, n);
  }

  // "empty" RSA key constructor

  function KeyObject() {
    this.n = null;
    this.e = 0;
    this.ee = null;
    this.d = null;
    this.p = null;
    this.q = null;
    this.dmp1 = null;
    this.dmq1 = null;
    this.u = null;
  }

  // Generate a new random private key B bits long, using public expt E

  function generate(B, E) {
    var webCrypto = _util2.default.getWebCryptoAll();

    //
    // Native RSA keygen using Web Crypto
    //

    if (webCrypto) {
      var Euint32 = new Uint32Array([parseInt(E, 16)]); // get integer of exponent
      var Euint8 = new Uint8Array(Euint32.buffer); // get bytes of exponent
      var keyGenOpt;

      var keys;
      if (window.crypto &amp;&amp; window.crypto.webkitSubtle) {
        // outdated spec implemented by Webkit
        keyGenOpt = {
          name: 'RSA-OAEP',
          modulusLength: B, // the specified keysize in bits
          publicExponent: Euint8.subarray(0, 3) // take three bytes (max 65537)
        };
        keys = webCrypto.generateKey(keyGenOpt, true, ['encrypt', 'decrypt']);
      } else {
        // current standard spec
        keyGenOpt = {
          name: 'RSASSA-PKCS1-v1_5',
          modulusLength: B, // the specified keysize in bits
          publicExponent: Euint8.subarray(0, 3), // take three bytes (max 65537)
          hash: {
            name: 'SHA-1' // not required for actual RSA keys, but for crypto api 'sign' and 'verify'
          }
        };

        keys = webCrypto.generateKey(keyGenOpt, true, ['sign', 'verify']);
        if (typeof keys.then !== 'function') {
          // IE11 KeyOperation
          keys = _util2.default.promisifyIE11Op(keys, 'Error generating RSA key pair.');
        }
      }

      return keys.then(exportKey).then(function (key) {
        if (key instanceof ArrayBuffer) {
          // parse raw ArrayBuffer bytes to jwk/json (WebKit/Safari/IE11 quirk)
          return decodeKey(JSON.parse(String.fromCharCode.apply(null, new Uint8Array(key))));
        }
        return decodeKey(key);
      });
    }

    function exportKey(keypair) {
      // export the generated keys as JsonWebKey (JWK)
      // https://tools.ietf.org/html/draft-ietf-jose-json-web-key-33
      var key = webCrypto.exportKey('jwk', keypair.privateKey);
      if (typeof key.then !== 'function') {
        // IE11 KeyOperation
        key = _util2.default.promisifyIE11Op(key, 'Error exporting RSA key pair.');
      }
      return key;
    }

    function decode ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.crypto.random" id="apidoc.module.openpgp.crypto.random">module openpgp.crypto.random</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.crypto.random.getRandomBigInteger" id="apidoc.element.openpgp.crypto.random.getRandomBigInteger">
        function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getRandomBigInteger
        <span class="apidocSignatureSpan">(bits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRandomBigInteger(bits) {
  if (bits &lt; 1) {
    throw new Error('Illegal parameter value: bits &lt; 1');
  }
  var numBytes = Math.floor((bits + 7) / 8);

  var randomBits = _util2.default.Uint8Array2str(this.getRandomBytes(numBytes));
  if (bits % 8 &gt; 0) {

    randomBits = String.fromCharCode(Math.pow(2, bits % 8) - 1 &amp; randomBits.charCodeAt(0)) + randomBits.substring(1);
  }
  var mpi = new _mpi2.default();
  mpi.fromBytes(randomBits);
  return mpi.toBigInteger();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.random.getRandomBigIntegerInRange" id="apidoc.element.openpgp.crypto.random.getRandomBigIntegerInRange">
        function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getRandomBigIntegerInRange
        <span class="apidocSignatureSpan">(min, max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRandomBigIntegerInRange(min, max) {
  if (max.compareTo(min) &lt;= 0) {
    throw new Error('Illegal parameter value: max &lt;= min');
  }

  var range = max.subtract(min);
  var r = this.getRandomBigInteger(range.bitLength());
  while (r.compareTo(range) &gt; 0) {
    r = this.getRandomBigInteger(range.bitLength());
  }
  return min.add(r);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.random.getRandomBytes" id="apidoc.element.openpgp.crypto.random.getRandomBytes">
        function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getRandomBytes
        <span class="apidocSignatureSpan">(length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRandomBytes(length) {
  var result = new Uint8Array(length);
  for (var i = 0; i &lt; length; i++) {
    result[i] = this.getSecureRandomOctet();
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.random.getRandomValues" id="apidoc.element.openpgp.crypto.random.getRandomValues">
        function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getRandomValues
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRandomValues(buf) {
  if (!(buf instanceof Uint8Array)) {
    throw new Error('Invalid type: buf not an Uint8Array');
  }
  if (typeof window !== 'undefined' &amp;&amp; window.crypto &amp;&amp; window.crypto.getRandomValues) {
    window.crypto.getRandomValues(buf);
  } else if (typeof window !== 'undefined' &amp;&amp; _typeof(window.msCrypto) === 'object' &amp;&amp; typeof window.msCrypto.getRandomValues === '
function') {
    window.msCrypto.getRandomValues(buf);
  } else if (nodeCrypto) {
    var bytes = nodeCrypto.randomBytes(buf.length);
    buf.set(bytes);
  } else if (this.randomBuffer.buffer) {
    this.randomBuffer.get(buf);
  } else {
    throw new Error('No secure random number generator available.');
  }
  return buf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.random.getSecureRandom" id="apidoc.element.openpgp.crypto.random.getSecureRandom">
        function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getSecureRandom
        <span class="apidocSignatureSpan">(from, to)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSecureRandom(from, to) {
  var randUint = this.getSecureRandomUint();
  var bits = (to - from).toString(2).length;
  while ((randUint &amp; Math.pow(2, bits) - 1) &gt; to - from) {
    randUint = this.getSecureRandomUint();
  }
  return from + Math.abs(randUint &amp; Math.pow(2, bits) - 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.random.getSecureRandomOctet" id="apidoc.element.openpgp.crypto.random.getSecureRandomOctet">
        function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getSecureRandomOctet
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSecureRandomOctet() {
  var buf = new Uint8Array(1);
  this.getRandomValues(buf);
  return buf[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.random.getSecureRandomUint" id="apidoc.element.openpgp.crypto.random.getSecureRandomUint">
        function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getSecureRandomUint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSecureRandomUint() {
  var buf = new Uint8Array(4);
  var dv = new DataView(buf.buffer);
  this.getRandomValues(buf);
  return dv.getUint32(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.crypto.signature" id="apidoc.module.openpgp.crypto.signature">module openpgp.crypto.signature</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.crypto.signature.sign" id="apidoc.element.openpgp.crypto.signature.sign">
        function <span class="apidocSignatureSpan">openpgp.crypto.signature.</span>sign
        <span class="apidocSignatureSpan">(hash_algo, algo, keyIntegers, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sign(hash_algo, algo, keyIntegers, data) {

  data = _util2.default.Uint8Array2str(data);

  var m;

  switch (algo) {
    case 1:
    // RSA (Encrypt or Sign) [HAC]
    case 2:
    // RSA Encrypt-Only [HAC]
    case 3:
      // RSA Sign-Only [HAC]
      var rsa = new _public_key2.default.rsa();
      var d = keyIntegers[2].toBigInteger();
      var n = keyIntegers[0].toBigInteger();
      m = _pkcs2.default.emsa.encode(hash_algo, data, keyIntegers[0].byteLength());
      return _util2.default.str2Uint8Array(rsa.sign(m, d, n).toMPI());

    case 17:
      // DSA (Digital Signature Algorithm) [FIPS186] [HAC]
      var dsa = new _public_key2.default.dsa();

      var p = keyIntegers[0].toBigInteger();
      var q = keyIntegers[1].toBigInteger();
      var g = keyIntegers[2].toBigInteger();
      var x = keyIntegers[4].toBigInteger();
      m = data;
      var result = dsa.sign(hash_algo, m, g, p, q, x);

      return _util2.default.str2Uint8Array(result[0].toString() + result[1].toString());
    case 16:
      // Elgamal (Encrypt-Only) [ELGAMAL] [HAC]
      throw new Error('Signing with Elgamal is not defined in the OpenPGP standard.');
    default:
      throw new Error('Invalid signature algorithm.');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
options = {
data: 'Hello, World!',                             // input as String (or Uint8Array)
privateKeys: privKeyObj // for signing
};

openpgp.<span class="apidocCodeKeywordSpan">sign</span>(options).then(function(signed) {
cleartext = signed.data; // '-----BEGIN PGP SIGNED MESSAGE ... END PGP SIGNATURE-----'
});
```

```js
options = {
message: openpgp.cleartext.readArmored(cleartext), // parse armored message
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.signature.verify" id="apidoc.element.openpgp.crypto.signature.verify">
        function <span class="apidocSignatureSpan">openpgp.crypto.signature.</span>verify
        <span class="apidocSignatureSpan">(algo, hash_algo, msg_MPIs, publickey_MPIs, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function verify(algo, hash_algo, msg_MPIs, publickey_MPIs, data) {
  var m;

  data = _util2.default.Uint8Array2str(data);

  switch (algo) {
    case 1:
    // RSA (Encrypt or Sign) [HAC]
    case 2:
    // RSA Encrypt-Only [HAC]
    case 3:
      // RSA Sign-Only [HAC]
      var rsa = new _public_key2.default.rsa();
      var n = publickey_MPIs[0].toBigInteger();
      var k = publickey_MPIs[0].byteLength();
      var e = publickey_MPIs[1].toBigInteger();
      m = msg_MPIs[0].toBigInteger();
      var EM = rsa.verify(m, e, n);
      var EM2 = _pkcs2.default.emsa.encode(hash_algo, data, k);
      return EM.compareTo(EM2) === 0;
    case 16:
      // Elgamal (Encrypt-Only) [ELGAMAL] [HAC]
      throw new Error("signing with Elgamal is not defined in the OpenPGP standard.");
    case 17:
      // DSA (Digital Signature Algorithm) [FIPS186] [HAC]
      var dsa = new _public_key2.default.dsa();
      var s1 = msg_MPIs[0].toBigInteger();
      var s2 = msg_MPIs[1].toBigInteger();
      var p = publickey_MPIs[0].toBigInteger();
      var q = publickey_MPIs[1].toBigInteger();
      var g = publickey_MPIs[2].toBigInteger();
      var y = publickey_MPIs[3].toBigInteger();
      m = data;
      var dopublic = dsa.verify(hash_algo, s1, s2, m, p, q, g, y);
      return dopublic.compareTo(s1) === 0;
    default:
      throw new Error('Invalid signature algorithm.');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
options = {
    message: openpgp.cleartext.readArmored(cleartext), // parse armored message
    publicKeys: openpgp.key.readArmored(pubkey).keys   // for verification
};

openpgp.<span class="apidocCodeKeywordSpan">verify</span>(options).then(function(verified) {
	validity = verified.signatures[0].valid; // true
	if (validity) {
		console.log('signed by key id ' + verified.signatures[0].keyid.toHex());
	}
});
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.default" id="apidoc.module.openpgp.default">module openpgp.default</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.default.decrypt" id="apidoc.element.openpgp.default.decrypt">
        function <span class="apidocSignatureSpan">openpgp.default.</span>decrypt
        <span class="apidocSignatureSpan">(_ref6)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decrypt(_ref6) {
  var message = _ref6.message;
  var privateKey = _ref6.privateKey;
  var publicKeys = _ref6.publicKeys;
  var sessionKey = _ref6.sessionKey;
  var password = _ref6.password;
  var _ref6$format = _ref6.format;
  var format = _ref6$format === undefined ? 'utf8' : _ref6$format;
  var _ref6$signature = _ref6.signature;
  var signature = _ref6$signature === undefined ? null : _ref6$signature;

  checkMessage(message);publicKeys = toArray(publicKeys);

  if (!nativeAEAD() &amp;&amp; asyncProxy) {
    // use web worker if web crypto apis are not supported
    return asyncProxy.delegate('decrypt', { message: message, privateKey: privateKey, publicKeys: publicKeys, sessionKey: sessionKey
, password: password, format: format, signature: signature });
  }

  return message.decrypt(privateKey, sessionKey, password).then(function (message) {

    var result = parseMessage(message, format);
    if (result.data) {
      // verify
      if (!publicKeys) {
        publicKeys = [];
      }
      if (signature) {
        //detached signature
        result.signatures = message.verifyDetached(signature, publicKeys);
      } else {
        result.signatures = message.verify(publicKeys);
      }
    }
    return result;
  }).catch(onError.bind(null, 'Error decrypting message'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
options = {
    message: openpgp.message.read(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.<span class="apidocCodeKeywordSpan">decrypt</span>(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
```

#### Encrypt and decrypt *String* data with PGP keys

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.default.decryptKey" id="apidoc.element.openpgp.default.decryptKey">
        function <span class="apidocSignatureSpan">openpgp.default.</span>decryptKey
        <span class="apidocSignatureSpan">(_ref4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decryptKey(_ref4) {
  var privateKey = _ref4.privateKey;
  var passphrase = _ref4.passphrase;

  if (asyncProxy) {
    // use web worker if available
    return asyncProxy.delegate('decryptKey', { privateKey: privateKey, passphrase: passphrase });
  }

  return execute(function () {

    if (!privateKey.decrypt(passphrase)) {
      throw new Error('Invalid passphrase');
    }
    return {
      key: privateKey
    };
  }, 'Error decrypting private key');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.default.decryptSessionKey" id="apidoc.element.openpgp.default.decryptSessionKey">
        function <span class="apidocSignatureSpan">openpgp.default.</span>decryptSessionKey
        <span class="apidocSignatureSpan">(_ref10)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decryptSessionKey(_ref10) {
  var message = _ref10.message;
  var privateKey = _ref10.privateKey;
  var password = _ref10.password;

  checkMessage(message);

  if (asyncProxy) {
    // use web worker if available
    return asyncProxy.delegate('decryptSessionKey', { message: message, privateKey: privateKey, password: password });
  }

  return execute(function () {
    return message.decryptSessionKey(privateKey, password);
  }, 'Error decrypting session key');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.default.destroyWorker" id="apidoc.element.openpgp.default.destroyWorker">
        function <span class="apidocSignatureSpan">openpgp.default.</span>destroyWorker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyWorker() {
  asyncProxy = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.default.encrypt" id="apidoc.element.openpgp.default.encrypt">
        function <span class="apidocSignatureSpan">openpgp.default.</span>encrypt
        <span class="apidocSignatureSpan">(_ref5)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encrypt(_ref5) {
  var data = _ref5.data;
  var publicKeys = _ref5.publicKeys;
  var privateKeys = _ref5.privateKeys;
  var passwords = _ref5.passwords;
  var filename = _ref5.filename;
  var _ref5$armor = _ref5.armor;
  var armor = _ref5$armor === undefined ? true : _ref5$armor;
  var _ref5$detached = _ref5.detached;
  var detached = _ref5$detached === undefined ? false : _ref5$detached;
  var _ref5$signature = _ref5.signature;
  var signature = _ref5$signature === undefined ? null : _ref5$signature;

  checkData(data);publicKeys = toArray(publicKeys);privateKeys = toArray(privateKeys);passwords = toArray(passwords);

  if (!nativeAEAD() &amp;&amp; asyncProxy) {
    // use web worker if web crypto apis are not supported
    return asyncProxy.delegate('encrypt', { data: data, publicKeys: publicKeys, privateKeys: privateKeys, passwords: passwords,
filename: filename, armor: armor, detached: detached, signature: signature });
  }
  var result = {};
  return Promise.resolve().then(function () {

    var message = createMessage(data, filename);
    if (!privateKeys) {
      privateKeys = [];
    }
    if (privateKeys.length || signature) {
      // sign the message only if private keys or signature is specified
      if (detached) {
        var detachedSignature = message.signDetached(privateKeys, signature);
        if (armor) {
          result.signature = detachedSignature.armor();
        } else {
          result.signature = detachedSignature;
        }
      } else {
        message = message.sign(privateKeys, signature);
      }
    }
    return message.encrypt(publicKeys, passwords);
  }).then(function (message) {
    if (armor) {
      result.data = message.armor();
    } else {
      result.message = message;
    }
    return result;
  }).catch(onError.bind(null, 'Error encrypting message'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.<span class="apidocCodeKeywordSpan">encrypt</span>(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.default.encryptSessionKey" id="apidoc.element.openpgp.default.encryptSessionKey">
        function <span class="apidocSignatureSpan">openpgp.default.</span>encryptSessionKey
        <span class="apidocSignatureSpan">(_ref9)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encryptSessionKey(_ref9) {
  var data = _ref9.data;
  var algorithm = _ref9.algorithm;
  var publicKeys = _ref9.publicKeys;
  var passwords = _ref9.passwords;

  checkbinary(data);checkString(algorithm, 'algorithm');publicKeys = toArray(publicKeys);passwords = toArray(passwords);

  if (asyncProxy) {
    // use web worker if available
    return asyncProxy.delegate('encryptSessionKey', { data: data, algorithm: algorithm, publicKeys: publicKeys, passwords: passwords
 });
  }

  return execute(function () {
    return {

      message: messageLib.encryptSessionKey(data, algorithm, publicKeys, passwords)

    };
  }, 'Error encrypting session key');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.default.generateKey" id="apidoc.element.openpgp.default.generateKey">
        function <span class="apidocSignatureSpan">openpgp.default.</span>generateKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generateKey() {
  var _ref2 = arguments.length &lt;= 0 || arguments[0] === undefined ? {} : arguments[0];

  var _ref2$userIds = _ref2.userIds;
  var userIds = _ref2$userIds === undefined ? [] : _ref2$userIds;
  var passphrase = _ref2.passphrase;
  var _ref2$numBits = _ref2.numBits;
  var numBits = _ref2$numBits === undefined ? 2048 : _ref2$numBits;
  var _ref2$unlocked = _ref2.unlocked;
  var unlocked = _ref2$unlocked === undefined ? false : _ref2$unlocked;
  var _ref2$keyExpirationTi = _ref2.keyExpirationTime;
  var keyExpirationTime = _ref2$keyExpirationTi === undefined ? 0 : _ref2$keyExpirationTi;

  var options = formatUserIds({ userIds: userIds, passphrase: passphrase, numBits: numBits, unlocked: unlocked, keyExpirationTime
: keyExpirationTime });

  if (!_util2.default.getWebCryptoAll() &amp;&amp; asyncProxy) {
    // use web worker if web crypto apis are not supported
    return asyncProxy.delegate('generateKey', options);
  }

  return key.generate(options).then(function (newKey) {
    return {

      key: newKey,
      privateKeyArmored: newKey.armor(),
      publicKeyArmored: newKey.toPublic().armor()

    };
  }).catch(onError.bind(null, 'Error generating keypair'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var options = {
    userIds: [{ name:'Jon Smith', email:'jon@example.com' }], // multiple user IDs
    numBits: 4096,                                            // RSA key size
    passphrase: 'super long and hard to guess secret'         // protects the private key
};

openpgp.<span class="apidocCodeKeywordSpan">generateKey</span>(options).then(function(key) {
    var privkey = key.privateKeyArmored; // '-----BEGIN PGP PRIVATE KEY BLOCK ... '
    var pubkey = key.publicKeyArmored;   // '-----BEGIN PGP PUBLIC KEY BLOCK ... '
});
```

#### Lookup public key on HKP server
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.default.getWorker" id="apidoc.element.openpgp.default.getWorker">
        function <span class="apidocSignatureSpan">openpgp.default.</span>getWorker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getWorker() {
  return asyncProxy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.default.initWorker" id="apidoc.element.openpgp.default.initWorker">
        function <span class="apidocSignatureSpan">openpgp.default.</span>initWorker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function initWorker() {
  var _ref = arguments.length &lt;= 0 || arguments[0] === undefined ? {} : arguments[0];

  var _ref$path = _ref.path;
  var path = _ref$path === undefined ? 'openpgp.worker.js' : _ref$path;
  var worker = _ref.worker;

  if (worker || typeof window !== 'undefined' &amp;&amp; window.Worker) {
    asyncProxy = new _async_proxy2.default({ path: path, worker: worker, config: _config2.default });
    return true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Here are some examples of how to use the v2.x api. For more elaborate examples and working code, please check out the [public api
 unit tests](https://github.com/openpgpjs/openpgpjs/blob/master/test/general/openpgp.js). If you're upgrading from v1.x it
might help to check out the [documentation](https://github.com/openpgpjs/openpgpjs#documentation).

#### Set up

```js
var openpgp = require('openpgp'); // use as CommonJS, AMD, ES6 module or via window.openpgp

openpgp.<span class="apidocCodeKeywordSpan">initWorker</span>({ path:'openpgp.worker.js' }) // set the relative web worker
 path

openpgp.config.aead_protect = true // activate fast AES-GCM mode (not yet OpenPGP standard)
```

#### Encrypt and decrypt *Uint8Array* data with a password

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.default.reformatKey" id="apidoc.element.openpgp.default.reformatKey">
        function <span class="apidocSignatureSpan">openpgp.default.</span>reformatKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reformatKey() {
  var _ref3 = arguments.length &lt;= 0 || arguments[0] === undefined ? {} : arguments[0];

  var privateKey = _ref3.privateKey;
  var _ref3$userIds = _ref3.userIds;
  var userIds = _ref3$userIds === undefined ? [] : _ref3$userIds;
  var _ref3$passphrase = _ref3.passphrase;
  var passphrase = _ref3$passphrase === undefined ? "" : _ref3$passphrase;
  var _ref3$unlocked = _ref3.unlocked;
  var unlocked = _ref3$unlocked === undefined ? false : _ref3$unlocked;
  var _ref3$keyExpirationTi = _ref3.keyExpirationTime;
  var keyExpirationTime = _ref3$keyExpirationTi === undefined ? 0 : _ref3$keyExpirationTi;

  var options = formatUserIds({ privateKey: privateKey, userIds: userIds, passphrase: passphrase, unlocked: unlocked, keyExpirationTime
: keyExpirationTime });

  if (asyncProxy) {
    return asyncProxy.delegate('reformatKey', options);
  }

  return key.reformat(options).then(function (newKey) {
    return {

      key: newKey,
      privateKeyArmored: newKey.armor(),
      publicKeyArmored: newKey.toPublic().armor()

    };
  }).catch(onError.bind(null, 'Error reformatting keypair'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.default.sign" id="apidoc.element.openpgp.default.sign">
        function <span class="apidocSignatureSpan">openpgp.default.</span>sign
        <span class="apidocSignatureSpan">(_ref7)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sign(_ref7) {
  var data = _ref7.data;
  var privateKeys = _ref7.privateKeys;
  var _ref7$armor = _ref7.armor;
  var armor = _ref7$armor === undefined ? true : _ref7$armor;
  var _ref7$detached = _ref7.detached;
  var detached = _ref7$detached === undefined ? false : _ref7$detached;

  checkString(data);
  privateKeys = toArray(privateKeys);

  if (asyncProxy) {
    // use web worker if available
    return asyncProxy.delegate('sign', { data: data, privateKeys: privateKeys, armor: armor, detached: detached });
  }

  var result = {};
  return execute(function () {

    var cleartextMessage = new cleartext.CleartextMessage(data);

    if (detached) {
      var signature = cleartextMessage.signDetached(privateKeys);
      if (armor) {
        result.signature = signature.armor();
      } else {
        result.signature = signature;
      }
    } else {
      cleartextMessage.sign(privateKeys);
    }

    if (armor) {
      result.data = cleartextMessage.armor();
    } else {
      result.message = cleartextMessage;
    }
    return result;
  }, 'Error signing cleartext message');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
options = {
data: 'Hello, World!',                             // input as String (or Uint8Array)
privateKeys: privKeyObj // for signing
};

openpgp.<span class="apidocCodeKeywordSpan">sign</span>(options).then(function(signed) {
cleartext = signed.data; // '-----BEGIN PGP SIGNED MESSAGE ... END PGP SIGNATURE-----'
});
```

```js
options = {
message: openpgp.cleartext.readArmored(cleartext), // parse armored message
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.default.verify" id="apidoc.element.openpgp.default.verify">
        function <span class="apidocSignatureSpan">openpgp.default.</span>verify
        <span class="apidocSignatureSpan">(_ref8)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function verify(_ref8) {
  var message = _ref8.message;
  var publicKeys = _ref8.publicKeys;
  var _ref8$signature = _ref8.signature;
  var signature = _ref8$signature === undefined ? null : _ref8$signature;

  checkCleartextMessage(message);
  publicKeys = toArray(publicKeys);

  if (asyncProxy) {
    // use web worker if available
    return asyncProxy.delegate('verify', { message: message, publicKeys: publicKeys, signature: signature });
  }

  var result = {};
  return execute(function () {
    result.data = message.getText();

    if (signature) {
      //detached signature
      result.signatures = message.verifyDetached(signature, publicKeys);
    } else {
      result.signatures = message.verify(publicKeys);
    }
    return result;
  }, 'Error verifying cleartext signed message');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
options = {
    message: openpgp.cleartext.readArmored(cleartext), // parse armored message
    publicKeys: openpgp.key.readArmored(pubkey).keys   // for verification
};

openpgp.<span class="apidocCodeKeywordSpan">verify</span>(options).then(function(verified) {
	validity = verified.signatures[0].valid; // true
	if (validity) {
		console.log('signed by key id ' + verified.signatures[0].keyid.toHex());
	}
});
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.enums" id="apidoc.module.openpgp.enums">module openpgp.enums</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.enums.read" id="apidoc.element.openpgp.enums.read">
        function <span class="apidocSignatureSpan">openpgp.enums.</span>read
        <span class="apidocSignatureSpan">(type, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read(type, e) {
  for (var i in type) {
    if (type[i] === parseInt(e)) {
      return i;
    }
  }

  throw new Error('Invalid enum value.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.enums.write" id="apidoc.element.openpgp.enums.write">
        function <span class="apidocSignatureSpan">openpgp.enums.</span>write
        <span class="apidocSignatureSpan">(type, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write(type, e) {
  if (typeof e === 'number') {
    e = this.read(type, e);
  }

  if (type[e] !== undefined) {
    return type[e];
  } else {
    throw new Error('Invalid enum value.');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.key" id="apidoc.module.openpgp.key">module openpgp.key</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.key.Key" id="apidoc.element.openpgp.key.Key">
        function <span class="apidocSignatureSpan">openpgp.key.</span>Key
        <span class="apidocSignatureSpan">(packetlist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Key(packetlist) {
  if (!(this instanceof Key)) {
    return new Key(packetlist);
  }
  // same data as in packetlist but in structured form
  this.primaryKey = null;
  this.revocationSignature = null;
  this.directSignatures = null;
  this.users = null;
  this.subKeys = null;
  this.packetlist2structure(packetlist);
  if (!this.primaryKey || !this.users) {
    throw new Error('Invalid key: need at least key and user ID packet');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.generate" id="apidoc.element.openpgp.key.generate">
        function <span class="apidocSignatureSpan">openpgp.key.</span>generate
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generate(options) {
  var secretKeyPacket, secretSubkeyPacket;
  return Promise.resolve().then(function () {
    options.keyType = options.keyType || _enums2.default.publicKey.rsa_encrypt_sign;
    if (options.keyType !== _enums2.default.publicKey.rsa_encrypt_sign) {
      // RSA Encrypt-Only and RSA Sign-Only are deprecated and SHOULD NOT be generated
      throw new Error('Only RSA Encrypt or Sign supported');
    }

    if (!options.passphrase) {
      // Key without passphrase is unlocked by definition
      options.unlocked = true;
    }
    if (String.prototype.isPrototypeOf(options.userIds) || typeof options.userIds === 'string') {
      options.userIds = [options.userIds];
    }

    return Promise.all([generateSecretKey(), generateSecretSubkey()]).then(function () {
      return wrapKeyObject(secretKeyPacket, secretSubkeyPacket, options);
    });
  });

  function generateSecretKey() {
    secretKeyPacket = new _packet2.default.SecretKey();
    secretKeyPacket.algorithm = _enums2.default.read(_enums2.default.publicKey, options.keyType);
    return secretKeyPacket.generate(options.numBits);
  }

  function generateSecretSubkey() {
    secretSubkeyPacket = new _packet2.default.SecretSubkey();
    secretSubkeyPacket.algorithm = _enums2.default.read(_enums2.default.publicKey, options.keyType);
    return secretSubkeyPacket.generate(options.numBits);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.getPreferredSymAlgo" id="apidoc.element.openpgp.key.getPreferredSymAlgo">
        function <span class="apidocSignatureSpan">openpgp.key.</span>getPreferredSymAlgo
        <span class="apidocSignatureSpan">(keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getPreferredSymAlgo(keys) {
  var prioMap = {};
  keys.forEach(function (key) {
    var primaryUser = key.getPrimaryUser();
    if (!primaryUser || !primaryUser.selfCertificate.preferredSymmetricAlgorithms) {
      return _config2.default.encryption_cipher;
    }
    primaryUser.selfCertificate.preferredSymmetricAlgorithms.forEach(function (algo, index) {
      var entry = prioMap[algo] || (prioMap[algo] = { prio: 0, count: 0, algo: algo });
      entry.prio += 64 &gt;&gt; index;
      entry.count++;
    });
  });
  var prefAlgo = { prio: 0, algo: _config2.default.encryption_cipher };
  for (var algo in prioMap) {
    try {
      if (algo !== _enums2.default.symmetric.plaintext &amp;&amp; algo !== _enums2.default.symmetric.idea &amp;&amp; // not implemented
      _enums2.default.read(_enums2.default.symmetric, algo) &amp;&amp; // known algorithm
      prioMap[algo].count === keys.length &amp;&amp; // available for all keys
      prioMap[algo].prio &gt; prefAlgo.prio) {
        prefAlgo = prioMap[algo];
      }
    } catch (e) {}
  }
  return prefAlgo.algo;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.readArmored" id="apidoc.element.openpgp.key.readArmored">
        function <span class="apidocSignatureSpan">openpgp.key.</span>readArmored
        <span class="apidocSignatureSpan">(armoredText)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readArmored(armoredText) {
  var result = {};
  result.keys = [];
  try {
    var input = _armor2.default.decode(armoredText);
    if (!(input.type === _enums2.default.armor.public_key || input.type === _enums2.default.armor.private_key)) {
      throw new Error('Armored text not of type key');
    }
    var packetlist = new _packet2.default.List();
    packetlist.read(input.data);
    var keyIndex = packetlist.indexOfTag(_enums2.default.packet.publicKey, _enums2.default.packet.secretKey);
    if (keyIndex.length === 0) {
      throw new Error('No key packet found in armored text');
    }
    for (var i = 0; i &lt; keyIndex.length; i++) {
      var oneKeyList = packetlist.slice(keyIndex[i], keyIndex[i + 1]);
      try {
        var newKey = new Key(oneKeyList);
        result.keys.push(newKey);
      } catch (e) {
        result.err = result.err || [];
        result.err.push(e);
      }
    }
  } catch (e) {
    result.err = result.err || [];
    result.err.push(e);
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var options, encrypted;

var pubkey = '-----BEGIN PGP PUBLIC KEY BLOCK ... END PGP PUBLIC KEY BLOCK-----';
var privkey = '-----BEGIN PGP PRIVATE KEY BLOCK ... END PGP PRIVATE KEY BLOCK-----'; //encrypted private key
var passphrase = 'secret passphrase'; //what the privKey is encrypted with

var privKeyObj = openpgp.key.<span class="apidocCodeKeywordSpan">readArmored</span>(privkey).keys[0];
privKeyObj.decrypt(passphrase);

options = {
    data: 'Hello, World!',                             // input as String (or Uint8Array)
    publicKeys: openpgp.key.readArmored(pubkey).keys,  // for encryption
    privateKeys: privKeyObj // for signing (optional)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.reformat" id="apidoc.element.openpgp.key.reformat">
        function <span class="apidocSignatureSpan">openpgp.key.</span>reformat
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reformat(options) {
  var secretKeyPacket, secretSubkeyPacket;
  return Promise.resolve().then(function () {

    options.keyType = options.keyType || _enums2.default.publicKey.rsa_encrypt_sign;
    if (options.keyType !== _enums2.default.publicKey.rsa_encrypt_sign) {
      // RSA Encrypt-Only and RSA Sign-Only are deprecated and SHOULD NOT be generated
      throw new Error('Only RSA Encrypt or Sign supported');
    }

    if (!options.passphrase) {
      // Key without passphrase is unlocked by definition
      options.unlocked = true;
    }
    if (String.prototype.isPrototypeOf(options.userIds) || typeof options.userIds === 'string') {
      options.userIds = [options.userIds];
    }
    var packetlist = options.privateKey.toPacketlist();
    for (var i = 0; i &lt; packetlist.length; i++) {
      if (packetlist[i].tag === _enums2.default.packet.secretKey) {
        secretKeyPacket = packetlist[i];
      } else if (packetlist[i].tag === _enums2.default.packet.secretSubkey) {
        secretSubkeyPacket = packetlist[i];
      }
    }
    return wrapKeyObject(secretKeyPacket, secretSubkeyPacket, options);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.key.Key" id="apidoc.module.openpgp.key.Key">module openpgp.key.Key</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.key.Key.Key" id="apidoc.element.openpgp.key.Key.Key">
        function <span class="apidocSignatureSpan">openpgp.key.</span>Key
        <span class="apidocSignatureSpan">(packetlist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Key(packetlist) {
  if (!(this instanceof Key)) {
    return new Key(packetlist);
  }
  // same data as in packetlist but in structured form
  this.primaryKey = null;
  this.revocationSignature = null;
  this.directSignatures = null;
  this.users = null;
  this.subKeys = null;
  this.packetlist2structure(packetlist);
  if (!this.primaryKey || !this.users) {
    throw new Error('Invalid key: need at least key and user ID packet');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.key.Key.prototype" id="apidoc.module.openpgp.key.Key.prototype">module openpgp.key.Key.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.armor" id="apidoc.element.openpgp.key.Key.prototype.armor">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>armor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">armor = function () {
  var type = this.isPublic() ? _enums2.default.armor.public_key : _enums2.default.armor.private_key;
  return _armor2.default.encode(type, this.toPacketlist().write());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.decrypt" id="apidoc.element.openpgp.key.Key.prototype.decrypt">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(passphrase)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (passphrase) {
  if (this.isPrivate()) {
    var keys = this.getAllKeyPackets();
    for (var i = 0; i &lt; keys.length; i++) {
      var success = keys[i].decrypt(passphrase);
      if (!success) {
        return false;
      }
    }
  } else {
    throw new Error("Nothing to decrypt in a public key");
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
options = {
    message: openpgp.message.read(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.<span class="apidocCodeKeywordSpan">decrypt</span>(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
```

#### Encrypt and decrypt *String* data with PGP keys

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.decryptKeyPacket" id="apidoc.element.openpgp.key.Key.prototype.decryptKeyPacket">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>decryptKeyPacket
        <span class="apidocSignatureSpan">(keyIds, passphrase)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decryptKeyPacket = function (keyIds, passphrase) {
  if (this.isPrivate()) {
    var keys = this.getAllKeyPackets();
    for (var i = 0; i &lt; keys.length; i++) {
      var keyId = keys[i].getKeyId();
      for (var j = 0; j &lt; keyIds.length; j++) {
        if (keyId.equals(keyIds[j])) {
          var success = keys[i].decrypt(passphrase);
          if (!success) {
            return false;
          }
        }
      }
    }
  } else {
    throw new Error("Nothing to decrypt in a public key");
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.encrypt" id="apidoc.element.openpgp.key.Key.prototype.encrypt">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(passphrase)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (passphrase) {
  if (!this.isPrivate()) {
    throw new Error("Nothing to encrypt in a public key");
  }

  var keys = this.getAllKeyPackets();
  for (var i = 0; i &lt; keys.length; i++) {
    keys[i].encrypt(passphrase);
    keys[i].clearPrivateMPIs();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.<span class="apidocCodeKeywordSpan">encrypt</span>(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.getAllKeyPackets" id="apidoc.element.openpgp.key.Key.prototype.getAllKeyPackets">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getAllKeyPackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAllKeyPackets = function () {
  return [this.primaryKey].concat(this.getSubkeyPackets());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.getEncryptionKeyPacket" id="apidoc.element.openpgp.key.Key.prototype.getEncryptionKeyPacket">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getEncryptionKeyPacket
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getEncryptionKeyPacket = function () {
  // V4: by convention subkeys are prefered for encryption service
  // V3: keys MUST NOT have subkeys
  if (this.subKeys) {
    for (var i = 0; i &lt; this.subKeys.length; i++) {
      if (this.subKeys[i].isValidEncryptionKey(this.primaryKey)) {
        return this.subKeys[i].subKey;
      }
    }
  }
  // if no valid subkey for encryption, evaluate primary key
  var primaryUser = this.getPrimaryUser();
  if (primaryUser &amp;&amp; primaryUser.selfCertificate &amp;&amp; !primaryUser.selfCertificate.isExpired() &amp;&amp; isValidEncryptionKeyPacket(this.
primaryKey, primaryUser.selfCertificate)) {
    return this.primaryKey;
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.getExpirationTime" id="apidoc.element.openpgp.key.Key.prototype.getExpirationTime">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getExpirationTime
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getExpirationTime = function () {
  if (this.primaryKey.version === 3) {
    return getExpirationTime(this.primaryKey);
  }
  if (this.primaryKey.version === 4) {
    var primaryUser = this.getPrimaryUser();
    if (!primaryUser) {
      return null;
    }
    return getExpirationTime(this.primaryKey, primaryUser.selfCertificate);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.getKeyIds" id="apidoc.element.openpgp.key.Key.prototype.getKeyIds">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getKeyIds
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getKeyIds = function () {
  var keyIds = [];
  var keys = this.getAllKeyPackets();
  for (var i = 0; i &lt; keys.length; i++) {
    keyIds.push(keys[i].getKeyId());
  }
  return keyIds;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.getKeyPacket" id="apidoc.element.openpgp.key.Key.prototype.getKeyPacket">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getKeyPacket
        <span class="apidocSignatureSpan">(keyIds)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getKeyPacket = function (keyIds) {
  var keys = this.getAllKeyPackets();
  for (var i = 0; i &lt; keys.length; i++) {
    var keyId = keys[i].getKeyId();
    for (var j = 0; j &lt; keyIds.length; j++) {
      if (keyId.equals(keyIds[j])) {
        return keys[i];
      }
    }
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.getPreferredHashAlgorithm" id="apidoc.element.openpgp.key.Key.prototype.getPreferredHashAlgorithm">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getPreferredHashAlgorithm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPreferredHashAlgorithm = function () {
  var primaryUser = this.getPrimaryUser();
  if (primaryUser &amp;&amp; primaryUser.selfCertificate.preferredHashAlgorithms) {
    return primaryUser.selfCertificate.preferredHashAlgorithms[0];
  }
  return _config2.default.prefer_hash_algorithm;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.getPrimaryUser" id="apidoc.element.openpgp.key.Key.prototype.getPrimaryUser">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getPrimaryUser
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPrimaryUser = function () {
  var primUser = [];
  for (var i = 0; i &lt; this.users.length; i++) {
    if (!this.users[i].userId || !this.users[i].selfCertifications) {
      continue;
    }
    for (var j = 0; j &lt; this.users[i].selfCertifications.length; j++) {
      primUser.push({ index: i, user: this.users[i], selfCertificate: this.users[i].selfCertifications[j] });
    }
  }
  // sort by primary user flag and signature creation time
  primUser = primUser.sort(function (a, b) {
    if (a.selfCertificate.isPrimaryUserID &gt; b.selfCertificate.isPrimaryUserID) {
      return -1;
    } else if (a.selfCertificate.isPrimaryUserID &lt; b.selfCertificate.isPrimaryUserID) {
      return 1;
    } else if (a.selfCertificate.created &gt; b.selfCertificate.created) {
      return -1;
    } else if (a.selfCertificate.created &lt; b.selfCertificate.created) {
      return 1;
    } else {
      return 0;
    }
  });
  // return first valid
  for (var k = 0; k &lt; primUser.length; k++) {
    if (primUser[k].user.isValidSelfCertificate(this.primaryKey, primUser[k].selfCertificate)) {
      return primUser[k];
    }
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.getSigningKeyPacket" id="apidoc.element.openpgp.key.Key.prototype.getSigningKeyPacket">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getSigningKeyPacket
        <span class="apidocSignatureSpan">(keyId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSigningKeyPacket = function (keyId) {
  var primaryUser = this.getPrimaryUser();
  if (primaryUser &amp;&amp; isValidSigningKeyPacket(this.primaryKey, primaryUser.selfCertificate) &amp;&amp; (!keyId || this.primaryKey.getKeyId
().equals(keyId))) {
    return this.primaryKey;
  }
  if (this.subKeys) {
    for (var i = 0; i &lt; this.subKeys.length; i++) {
      if (this.subKeys[i].isValidSigningKey(this.primaryKey) &amp;&amp; (!keyId || this.subKeys[i].subKey.getKeyId().equals(keyId))) {
        return this.subKeys[i].subKey;
      }
    }
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.getSubkeyPackets" id="apidoc.element.openpgp.key.Key.prototype.getSubkeyPackets">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getSubkeyPackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSubkeyPackets = function () {
  var subKeys = [];
  if (this.subKeys) {
    for (var i = 0; i &lt; this.subKeys.length; i++) {
      subKeys.push(this.subKeys[i].subKey);
    }
  }
  return subKeys;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.getUserIds" id="apidoc.element.openpgp.key.Key.prototype.getUserIds">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getUserIds
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getUserIds = function () {
  var userids = [];
  for (var i = 0; i &lt; this.users.length; i++) {
    if (this.users[i].userId) {
      userids.push(_util2.default.Uint8Array2str(this.users[i].userId.write()));
    }
  }
  return userids;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.isPrivate" id="apidoc.element.openpgp.key.Key.prototype.isPrivate">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>isPrivate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPrivate = function () {
  return this.primaryKey.tag === _enums2.default.packet.secretKey;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.isPublic" id="apidoc.element.openpgp.key.Key.prototype.isPublic">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>isPublic
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPublic = function () {
  return this.primaryKey.tag === _enums2.default.packet.publicKey;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.packetlist2structure" id="apidoc.element.openpgp.key.Key.prototype.packetlist2structure">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>packetlist2structure
        <span class="apidocSignatureSpan">(packetlist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">packetlist2structure = function (packetlist) {
  var user, primaryKeyId, subKey;
  for (var i = 0; i &lt; packetlist.length; i++) {
    switch (packetlist[i].tag) {
      case _enums2.default.packet.publicKey:
      case _enums2.default.packet.secretKey:
        this.primaryKey = packetlist[i];
        primaryKeyId = this.primaryKey.getKeyId();
        break;
      case _enums2.default.packet.userid:
      case _enums2.default.packet.userAttribute:
        user = new User(packetlist[i]);
        if (!this.users) {
          this.users = [];
        }
        this.users.push(user);
        break;
      case _enums2.default.packet.publicSubkey:
      case _enums2.default.packet.secretSubkey:
        user = null;
        if (!this.subKeys) {
          this.subKeys = [];
        }
        subKey = new SubKey(packetlist[i]);
        this.subKeys.push(subKey);
        break;
      case _enums2.default.packet.signature:
        switch (packetlist[i].signatureType) {
          case _enums2.default.signature.cert_generic:
          case _enums2.default.signature.cert_persona:
          case _enums2.default.signature.cert_casual:
          case _enums2.default.signature.cert_positive:
            if (!user) {
              _util2.default.print_debug('Dropping certification signatures without preceding user packet');
              continue;
            }
            if (packetlist[i].issuerKeyId.equals(primaryKeyId)) {
              if (!user.selfCertifications) {
                user.selfCertifications = [];
              }
              user.selfCertifications.push(packetlist[i]);
            } else {
              if (!user.otherCertifications) {
                user.otherCertifications = [];
              }
              user.otherCertifications.push(packetlist[i]);
            }
            break;
          case _enums2.default.signature.cert_revocation:
            if (user) {
              if (!user.revocationCertifications) {
                user.revocationCertifications = [];
              }
              user.revocationCertifications.push(packetlist[i]);
            } else {
              if (!this.directSignatures) {
                this.directSignatures = [];
              }
              this.directSignatures.push(packetlist[i]);
            }
            break;
          case _enums2.default.signature.key:
            if (!this.directSignatures) {
              this.directSignatures = [];
            }
            this.directSignatures.push(packetlist[i]);
            break;
          case _enums2.default.signature.subkey_binding:
            if (!subKey) {
              _util2.default.print_debug('Dropping subkey binding signature without preceding subkey packet');
              continue;
            }
            subKey.bindingSignature = packetlist[i];
            break;
          case _enums2.default.signature.key_revocation:
            this.revocationSignature = packetlist[i];
            break;
          case _enums2.default.signature.subkey_revocation:
            if (!subKey) {
              _util2.default.print_debug('Dropping subkey revocation signature without preceding subkey packet');
              continue;
            }
            subKey.revocationSignature = packetlist[i];
            break;
        }
        break;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.revoke" id="apidoc.element.openpgp.key.Key.prototype.revoke">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>revoke
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">revoke = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.signAllUsers" id="apidoc.element.openpgp.key.Key.prototype.signAllUsers">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>signAllUsers
        <span class="apidocSignatureSpan">(privateKeys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">signAllUsers = function (privateKeys) {
  var _this = this;

  var users = this.users.map(function (user) {
    return user.sign(_this.primaryKey, privateKeys);
  });
  var key = new Key(this.toPacketlist());
  key.users = users;
  return key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.signPrimaryUser" id="apidoc.element.openpgp.key.Key.prototype.signPrimaryUser">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>signPrimaryUser
        <span class="apidocSignatureSpan">(privateKeys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">signPrimaryUser = function (privateKeys) {
  var _ref = this.getPrimaryUser() || {};

  var index = _ref.index;
  var user = _ref.user;

  if (!user) {
    throw new Error('Could not find primary user');
  }
  user = user.sign(this.primaryKey, privateKeys);
  var key = new Key(this.toPacketlist());
  key.users[index] = user;
  return key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.toPacketlist" id="apidoc.element.openpgp.key.Key.prototype.toPacketlist">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>toPacketlist
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPacketlist = function () {
  var packetlist = new _packet2.default.List();
  packetlist.push(this.primaryKey);
  packetlist.push(this.revocationSignature);
  packetlist.concat(this.directSignatures);
  var i;
  for (i = 0; i &lt; this.users.length; i++) {
    packetlist.concat(this.users[i].toPacketlist());
  }
  if (this.subKeys) {
    for (i = 0; i &lt; this.subKeys.length; i++) {
      packetlist.concat(this.subKeys[i].toPacketlist());
    }
  }
  return packetlist;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.toPublic" id="apidoc.element.openpgp.key.Key.prototype.toPublic">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>toPublic
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPublic = function () {
  var packetlist = new _packet2.default.List();
  var keyPackets = this.toPacketlist();
  var bytes;
  for (var i = 0; i &lt; keyPackets.length; i++) {
    switch (keyPackets[i].tag) {
      case _enums2.default.packet.secretKey:
        bytes = keyPackets[i].writePublicKey();
        var pubKeyPacket = new _packet2.default.PublicKey();
        pubKeyPacket.read(bytes);
        packetlist.push(pubKeyPacket);
        break;
      case _enums2.default.packet.secretSubkey:
        bytes = keyPackets[i].writePublicKey();
        var pubSubkeyPacket = new _packet2.default.PublicSubkey();
        pubSubkeyPacket.read(bytes);
        packetlist.push(pubSubkeyPacket);
        break;
      default:
        packetlist.push(keyPackets[i]);
    }
  }
  return new Key(packetlist);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.update" id="apidoc.element.openpgp.key.Key.prototype.update">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>update
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (key) {
  var that = this;
  if (key.verifyPrimaryKey() === _enums2.default.keyStatus.invalid) {
    return;
  }
  if (this.primaryKey.getFingerprint() !== key.primaryKey.getFingerprint()) {
    throw new Error('Key update method: fingerprints of keys not equal');
  }
  if (this.isPublic() &amp;&amp; key.isPrivate()) {
    // check for equal subkey packets
    var equal = (this.subKeys &amp;&amp; this.subKeys.length) === (key.subKeys &amp;&amp; key.subKeys.length) &amp;&amp; (!this.subKeys || this.subKeys.
every(function (destSubKey) {
      return key.subKeys.some(function (srcSubKey) {
        return destSubKey.subKey.getFingerprint() === srcSubKey.subKey.getFingerprint();
      });
    }));
    if (!equal) {
      throw new Error('Cannot update public key with private key if subkey mismatch');
    }
    this.primaryKey = key.primaryKey;
  }
  // revocation signature
  if (!this.revocationSignature &amp;&amp; key.revocationSignature &amp;&amp; !key.revocationSignature.isExpired() &amp;&amp; (key.revocationSignature.verified
 || key.revocationSignature.verify(key.primaryKey, { key: key.primaryKey }))) {
    this.revocationSignature = key.revocationSignature;
  }
  // direct signatures
  mergeSignatures(key, this, 'directSignatures');
  // users
  key.users.forEach(function (srcUser) {
    var found = false;
    for (var i = 0; i &lt; that.users.length; i++) {
      if (srcUser.userId &amp;&amp; srcUser.userId.userid === that.users[i].userId.userid || srcUser.userAttribute &amp;&amp; srcUser.userAttribute
.equals(that.users[i].userAttribute)) {
        that.users[i].update(srcUser, that.primaryKey);
        found = true;
        break;
      }
    }
    if (!found) {
      that.users.push(srcUser);
    }
  });
  // subkeys
  if (key.subKeys) {
    key.subKeys.forEach(function (srcSubKey) {
      var found = false;
      for (var i = 0; i &lt; that.subKeys.length; i++) {
        if (srcSubKey.subKey.getFingerprint() === that.subKeys[i].subKey.getFingerprint()) {
          that.subKeys[i].update(srcSubKey, that.primaryKey);
          found = true;
          break;
        }
      }
      if (!found) {
        that.subKeys.push(srcSubKey);
      }
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.verifyAllUsers" id="apidoc.element.openpgp.key.Key.prototype.verifyAllUsers">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>verifyAllUsers
        <span class="apidocSignatureSpan">(keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verifyAllUsers = function (keys) {
  var _this2 = this;

  return this.users.reduce(function (signatures, user) {
    return signatures.concat(user.verifyAllSignatures(_this2.primaryKey, keys).map(function (signature) {
      return {
        userid: user.userId.userid,
        keyid: signature.keyid,
        valid: signature.valid
      };
    }));
  }, []);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.verifyPrimaryKey" id="apidoc.element.openpgp.key.Key.prototype.verifyPrimaryKey">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>verifyPrimaryKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verifyPrimaryKey = function () {
  // check revocation signature
  if (this.revocationSignature &amp;&amp; !this.revocationSignature.isExpired() &amp;&amp; (this.revocationSignature.verified || this.revocationSignature
.verify(this.primaryKey, { key: this.primaryKey }))) {
    return _enums2.default.keyStatus.revoked;
  }
  // check V3 expiration time
  if (this.primaryKey.version === 3 &amp;&amp; this.primaryKey.expirationTimeV3 !== 0 &amp;&amp; Date.now() &gt; this.primaryKey.created.getTime() +
this.primaryKey.expirationTimeV3 * 24 * 3600 * 1000) {
    return _enums2.default.keyStatus.expired;
  }
  // check for at least one self signature. Self signature of user ID not mandatory
  // See {@link http://tools.ietf.org/html/rfc4880#section-11.1}
  var selfSigned = false;
  for (var i = 0; i &lt; this.users.length; i++) {
    if (this.users[i].userId &amp;&amp; this.users[i].selfCertifications) {
      selfSigned = true;
    }
  }
  if (!selfSigned) {
    return _enums2.default.keyStatus.no_self_cert;
  }
  // check for valid self signature
  var primaryUser = this.getPrimaryUser();
  if (!primaryUser) {
    return _enums2.default.keyStatus.invalid;
  }
  // check V4 expiration time
  if (this.primaryKey.version === 4 &amp;&amp; primaryUser.selfCertificate.keyNeverExpires === false &amp;&amp; Date.now() &gt; this.primaryKey.created
.getTime() + primaryUser.selfCertificate.keyExpirationTime * 1000) {
    return _enums2.default.keyStatus.expired;
  }
  return _enums2.default.keyStatus.valid;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.verifyPrimaryUser" id="apidoc.element.openpgp.key.Key.prototype.verifyPrimaryUser">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>verifyPrimaryUser
        <span class="apidocSignatureSpan">(keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verifyPrimaryUser = function (keys) {
  var _ref2 = this.getPrimaryUser() || {};

  var user = _ref2.user;

  if (!user) {
    throw new Error('Could not find primary user');
  }
  return user.verifyAllSignatures(this.primaryKey, keys);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.message" id="apidoc.module.openpgp.message">module openpgp.message</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.message.Message" id="apidoc.element.openpgp.message.Message">
        function <span class="apidocSignatureSpan">openpgp.message.</span>Message
        <span class="apidocSignatureSpan">(packetlist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Message(packetlist) {
  if (!(this instanceof Message)) {
    return new Message(packetlist);
  }
  this.packets = packetlist || new _packet2.default.List();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.encryptSessionKey" id="apidoc.element.openpgp.message.encryptSessionKey">
        function <span class="apidocSignatureSpan">openpgp.message.</span>encryptSessionKey
        <span class="apidocSignatureSpan">(sessionKey, symAlgo, publicKeys, passwords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encryptSessionKey(sessionKey, symAlgo, publicKeys, passwords) {
  var packetlist = new _packet2.default.List();

  if (publicKeys) {
    publicKeys.forEach(function (key) {
      var encryptionKeyPacket = key.getEncryptionKeyPacket();
      if (encryptionKeyPacket) {
        var pkESKeyPacket = new _packet2.default.PublicKeyEncryptedSessionKey();
        pkESKeyPacket.publicKeyId = encryptionKeyPacket.getKeyId();
        pkESKeyPacket.publicKeyAlgorithm = encryptionKeyPacket.algorithm;
        pkESKeyPacket.sessionKey = sessionKey;
        pkESKeyPacket.sessionKeyAlgorithm = symAlgo;
        pkESKeyPacket.encrypt(encryptionKeyPacket);
        delete pkESKeyPacket.sessionKey; // delete plaintext session key after encryption
        packetlist.push(pkESKeyPacket);
      } else {
        throw new Error('Could not find valid key packet for encryption in key ' + key.primaryKey.getKeyId().toHex());
      }
    });
  }

  if (passwords) {
    passwords.forEach(function (password) {
      var symEncryptedSessionKeyPacket = new _packet2.default.SymEncryptedSessionKey();
      symEncryptedSessionKeyPacket.sessionKey = sessionKey;
      symEncryptedSessionKeyPacket.sessionKeyAlgorithm = symAlgo;
      symEncryptedSessionKeyPacket.encrypt(password);
      delete symEncryptedSessionKeyPacket.sessionKey; // delete plaintext session key after encryption
      packetlist.push(symEncryptedSessionKeyPacket);
    });
  }

  return new Message(packetlist);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.fromBinary" id="apidoc.element.openpgp.message.fromBinary">
        function <span class="apidocSignatureSpan">openpgp.message.</span>fromBinary
        <span class="apidocSignatureSpan">(bytes, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromBinary(bytes, filename) {
  if (!_util2.default.isUint8Array(bytes)) {
    throw new Error('Data must be in the form of a Uint8Array');
  }

  var literalDataPacket = new _packet2.default.Literal();
  if (filename) {
    literalDataPacket.setFilename(filename);
  }
  literalDataPacket.setBytes(bytes, _enums2.default.read(_enums2.default.literal, _enums2.default.literal.binary));
  if (filename !== undefined) {
    literalDataPacket.setFilename(filename);
  }
  var literalDataPacketlist = new _packet2.default.List();
  literalDataPacketlist.push(literalDataPacket);
  return new Message(literalDataPacketlist);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.fromText" id="apidoc.element.openpgp.message.fromText">
        function <span class="apidocSignatureSpan">openpgp.message.</span>fromText
        <span class="apidocSignatureSpan">(text, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromText(text, filename) {
  var literalDataPacket = new _packet2.default.Literal();
  // text will be converted to UTF8
  literalDataPacket.setText(text);
  if (filename !== undefined) {
    literalDataPacket.setFilename(filename);
  }
  var literalDataPacketlist = new _packet2.default.List();
  literalDataPacketlist.push(literalDataPacket);
  return new Message(literalDataPacketlist);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.read" id="apidoc.element.openpgp.message.read">
        function <span class="apidocSignatureSpan">openpgp.message.</span>read
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read(input) {
  var packetlist = new _packet2.default.List();
  packetlist.read(input);
  return new Message(packetlist);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.readArmored" id="apidoc.element.openpgp.message.readArmored">
        function <span class="apidocSignatureSpan">openpgp.message.</span>readArmored
        <span class="apidocSignatureSpan">(armoredText)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readArmored(armoredText) {
  //TODO how do we want to handle bad text? Exception throwing
  //TODO don't accept non-message armored texts
  var input = _armor2.default.decode(armoredText).data;
  return read(input);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var options, encrypted;

var pubkey = '-----BEGIN PGP PUBLIC KEY BLOCK ... END PGP PUBLIC KEY BLOCK-----';
var privkey = '-----BEGIN PGP PRIVATE KEY BLOCK ... END PGP PRIVATE KEY BLOCK-----'; //encrypted private key
var passphrase = 'secret passphrase'; //what the privKey is encrypted with

var privKeyObj = openpgp.key.<span class="apidocCodeKeywordSpan">readArmored</span>(privkey).keys[0];
privKeyObj.decrypt(passphrase);

options = {
    data: 'Hello, World!',                             // input as String (or Uint8Array)
    publicKeys: openpgp.key.readArmored(pubkey).keys,  // for encryption
    privateKeys: privKeyObj // for signing (optional)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.readSignedContent" id="apidoc.element.openpgp.message.readSignedContent">
        function <span class="apidocSignatureSpan">openpgp.message.</span>readSignedContent
        <span class="apidocSignatureSpan">(content, detachedSignature)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readSignedContent(content, detachedSignature) {
  var literalDataPacket = new _packet2.default.Literal();
  literalDataPacket.setBytes(_util2.default.str2Uint8Array(content), _enums2.default.read(_enums2.default.literal, _enums2.default
.literal.binary));
  var packetlist = new _packet2.default.List();
  packetlist.push(literalDataPacket);
  var input = _armor2.default.decode(detachedSignature).data;
  packetlist.read(input);
  return new Message(packetlist);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.message.Message" id="apidoc.module.openpgp.message.Message">module openpgp.message.Message</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.message.Message.Message" id="apidoc.element.openpgp.message.Message.Message">
        function <span class="apidocSignatureSpan">openpgp.message.</span>Message
        <span class="apidocSignatureSpan">(packetlist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Message(packetlist) {
  if (!(this instanceof Message)) {
    return new Message(packetlist);
  }
  this.packets = packetlist || new _packet2.default.List();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.message.Message.prototype" id="apidoc.module.openpgp.message.Message.prototype">module openpgp.message.Message.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.armor" id="apidoc.element.openpgp.message.Message.prototype.armor">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>armor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">armor = function () {
  return _armor2.default.encode(_enums2.default.armor.message, this.packets.write());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.decrypt" id="apidoc.element.openpgp.message.Message.prototype.decrypt">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(privateKey, sessionKey, password)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (privateKey, sessionKey, password) {
  var _this = this;

  return Promise.resolve().then(function () {
    var keyObj = sessionKey || _this.decryptSessionKey(privateKey, password);
    if (!keyObj || !_util2.default.isUint8Array(keyObj.data) || !_util2.default.isString(keyObj.algorithm)) {
      throw new Error('Invalid session key for decryption.');
    }

    var symEncryptedPacketlist = _this.packets.filterByTag(_enums2.default.packet.symmetricallyEncrypted, _enums2.default.packet
.symEncryptedIntegrityProtected, _enums2.default.packet.symEncryptedAEADProtected);

    if (symEncryptedPacketlist.length === 0) {
      return;
    }

    var symEncryptedPacket = symEncryptedPacketlist[0];
    return symEncryptedPacket.decrypt(keyObj.algorithm, keyObj.data).then(function () {
      var resultMsg = new Message(symEncryptedPacket.packets);
      symEncryptedPacket.packets = new _packet2.default.List(); // remove packets after decryption
      return resultMsg;
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
options = {
    message: openpgp.message.read(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.<span class="apidocCodeKeywordSpan">decrypt</span>(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
```

#### Encrypt and decrypt *String* data with PGP keys

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.decryptSessionKey" id="apidoc.element.openpgp.message.Message.prototype.decryptSessionKey">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>decryptSessionKey
        <span class="apidocSignatureSpan">(privateKey, password)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decryptSessionKey = function (privateKey, password) {
  var keyPacket;

  if (password) {
    var symEncryptedSessionKeyPacketlist = this.packets.filterByTag(_enums2.default.packet.symEncryptedSessionKey);
    var symLength = symEncryptedSessionKeyPacketlist.length;
    for (var i = 0; i &lt; symLength; i++) {
      keyPacket = symEncryptedSessionKeyPacketlist[i];
      try {
        keyPacket.decrypt(password);
        break;
      } catch (err) {
        if (i === symLength - 1) {
          throw err;
        }
      }
    }
    if (!keyPacket) {
      throw new Error('No symmetrically encrypted session key packet found.');
    }
  } else if (privateKey) {
    var encryptionKeyIds = this.getEncryptionKeyIds();
    if (!encryptionKeyIds.length) {
      // nothing to decrypt
      return;
    }
    var privateKeyPacket = privateKey.getKeyPacket(encryptionKeyIds);
    if (!privateKeyPacket.isDecrypted) {
      throw new Error('Private key is not decrypted.');
    }
    var pkESKeyPacketlist = this.packets.filterByTag(_enums2.default.packet.publicKeyEncryptedSessionKey);
    for (var j = 0; j &lt; pkESKeyPacketlist.length; j++) {
      if (pkESKeyPacketlist[j].publicKeyId.equals(privateKeyPacket.getKeyId())) {
        keyPacket = pkESKeyPacketlist[j];
        keyPacket.decrypt(privateKeyPacket);
        break;
      }
    }
  } else {
    throw new Error('No key or password specified.');
  }

  if (keyPacket) {
    return {
      data: keyPacket.sessionKey,
      algorithm: keyPacket.sessionKeyAlgorithm
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.encrypt" id="apidoc.element.openpgp.message.Message.prototype.encrypt">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(keys, passwords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (keys, passwords) {
  var _this2 = this;

  var symAlgo = void 0,
      msg = void 0,
      symEncryptedPacket = void 0;
  return Promise.resolve().then(function () {
    if (keys) {
      symAlgo = keyModule.getPreferredSymAlgo(keys);
    } else if (passwords) {
      symAlgo = _config2.default.encryption_cipher;
    } else {
      throw new Error('No keys or passwords');
    }

    var sessionKey = _crypto2.default.generateSessionKey(_enums2.default.read(_enums2.default.symmetric, symAlgo));
    msg = encryptSessionKey(sessionKey, _enums2.default.read(_enums2.default.symmetric, symAlgo), keys, passwords);

    if (_config2.default.aead_protect) {
      symEncryptedPacket = new _packet2.default.SymEncryptedAEADProtected();
    } else if (_config2.default.integrity_protect) {
      symEncryptedPacket = new _packet2.default.SymEncryptedIntegrityProtected();
    } else {
      symEncryptedPacket = new _packet2.default.SymmetricallyEncrypted();
    }
    symEncryptedPacket.packets = _this2.packets;

    return symEncryptedPacket.encrypt(_enums2.default.read(_enums2.default.symmetric, symAlgo), sessionKey);
  }).then(function () {
    msg.packets.push(symEncryptedPacket);
    symEncryptedPacket.packets = new _packet2.default.List(); // remove packets after encryption
    return msg;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.<span class="apidocCodeKeywordSpan">encrypt</span>(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.getEncryptionKeyIds" id="apidoc.element.openpgp.message.Message.prototype.getEncryptionKeyIds">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>getEncryptionKeyIds
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getEncryptionKeyIds = function () {
  var keyIds = [];
  var pkESKeyPacketlist = this.packets.filterByTag(_enums2.default.packet.publicKeyEncryptedSessionKey);
  pkESKeyPacketlist.forEach(function (packet) {
    keyIds.push(packet.publicKeyId);
  });
  return keyIds;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.getFilename" id="apidoc.element.openpgp.message.Message.prototype.getFilename">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>getFilename
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFilename = function () {
  var literal = this.packets.findPacket(_enums2.default.packet.literal);
  return literal &amp;&amp; literal.getFilename() || null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.getLiteralData" id="apidoc.element.openpgp.message.Message.prototype.getLiteralData">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>getLiteralData
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLiteralData = function () {
  var literal = this.packets.findPacket(_enums2.default.packet.literal);
  return literal &amp;&amp; literal.data || null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.getSigningKeyIds" id="apidoc.element.openpgp.message.Message.prototype.getSigningKeyIds">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>getSigningKeyIds
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSigningKeyIds = function () {
  var keyIds = [];
  var msg = this.unwrapCompressed();
  // search for one pass signatures
  var onePassSigList = msg.packets.filterByTag(_enums2.default.packet.onePassSignature);
  onePassSigList.forEach(function (packet) {
    keyIds.push(packet.signingKeyId);
  });
  // if nothing found look for signature packets
  if (!keyIds.length) {
    var signatureList = msg.packets.filterByTag(_enums2.default.packet.signature);
    signatureList.forEach(function (packet) {
      keyIds.push(packet.issuerKeyId);
    });
  }
  return keyIds;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.getText" id="apidoc.element.openpgp.message.Message.prototype.getText">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>getText
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getText = function () {
  var literal = this.packets.findPacket(_enums2.default.packet.literal);
  if (literal) {
    return literal.getText();
  } else {
    return null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.sign" id="apidoc.element.openpgp.message.Message.prototype.sign">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>sign
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sign = function () {
  var privateKeys = arguments.length &lt;= 0 || arguments[0] === undefined ? [] : arguments[0];
  var signature = arguments.length &lt;= 1 || arguments[1] === undefined ? null : arguments[1];


  var packetlist = new _packet2.default.List();

  var literalDataPacket = this.packets.findPacket(_enums2.default.packet.literal);
  if (!literalDataPacket) {
    throw new Error('No literal data packet to sign.');
  }

  var literalFormat = _enums2.default.write(_enums2.default.literal, literalDataPacket.format);
  var signatureType = literalFormat === _enums2.default.literal.binary ? _enums2.default.signature.binary : _enums2.default.signature
.text;
  var i, signingKeyPacket, existingSigPacketlist, onePassSig;

  if (signature) {
    existingSigPacketlist = signature.packets.filterByTag(_enums2.default.packet.signature);
    if (existingSigPacketlist.length) {
      for (i = existingSigPacketlist.length - 1; i &gt;= 0; i--) {
        var sigPacket = existingSigPacketlist[i];
        onePassSig = new _packet2.default.OnePassSignature();
        onePassSig.type = signatureType;
        onePassSig.hashAlgorithm = _config2.default.prefer_hash_algorithm;
        onePassSig.publicKeyAlgorithm = sigPacket.publicKeyAlgorithm;
        onePassSig.signingKeyId = sigPacket.issuerKeyId;
        if (!privateKeys.length &amp;&amp; i === 0) {
          onePassSig.flags = 1;
        }
        packetlist.push(onePassSig);
      }
    }
  }
  for (i = 0; i &lt; privateKeys.length; i++) {
    if (privateKeys[i].isPublic()) {
      throw new Error('Need private key for signing');
    }
    onePassSig = new _packet2.default.OnePassSignature();
    onePassSig.type = signatureType;
    //TODO get preferred hashg algo from key signature
    onePassSig.hashAlgorithm = _config2.default.prefer_hash_algorithm;
    signingKeyPacket = privateKeys[i].getSigningKeyPacket();
    if (!signingKeyPacket) {
      throw new Error('Could not find valid key packet for signing in key ' + privateKeys[i].primaryKey.getKeyId().toHex());
    }
    onePassSig.publicKeyAlgorithm = signingKeyPacket.algorithm;
    onePassSig.signingKeyId = signingKeyPacket.getKeyId();
    if (i === privateKeys.length - 1) {
      onePassSig.flags = 1;
    }
    packetlist.push(onePassSig);
  }

  packetlist.push(literalDataPacket);

  for (i = privateKeys.length - 1; i &gt;= 0; i--) {
    var signaturePacket = new _packet2.default.Signature();
    signaturePacket.signatureType = signatureType;
    signaturePacket.hashAlgorithm = _config2.default.prefer_hash_algorithm;
    signaturePacket.publicKeyAlgorithm = signingKeyPacket.algorithm;
    if (!signingKeyPacket.isDecrypted) {
      throw new Error('Private key is not decrypted.');
    }
    signaturePacket.sign(signingKeyPacket, literalDataPacket);
    packetlist.push(signaturePacket);
  }

  if (signature) {
    packetlist.concat(existingSigPacketlist);
  }

  return new Message(packetlist);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
options = {
data: 'Hello, World!',                             // input as String (or Uint8Array)
privateKeys: privKeyObj // for signing
};

openpgp.<span class="apidocCodeKeywordSpan">sign</span>(options).then(function(signed) {
cleartext = signed.data; // '-----BEGIN PGP SIGNED MESSAGE ... END PGP SIGNATURE-----'
});
```

```js
options = {
message: openpgp.cleartext.readArmored(cleartext), // parse armored message
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.signDetached" id="apidoc.element.openpgp.message.Message.prototype.signDetached">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>signDetached
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">signDetached = function () {
  var privateKeys = arguments.length &lt;= 0 || arguments[0] === undefined ? [] : arguments[0];
  var signature = arguments.length &lt;= 1 || arguments[1] === undefined ? null : arguments[1];


  var packetlist = new _packet2.default.List();

  var literalDataPacket = this.packets.findPacket(_enums2.default.packet.literal);
  if (!literalDataPacket) {
    throw new Error('No literal data packet to sign.');
  }

  var literalFormat = _enums2.default.write(_enums2.default.literal, literalDataPacket.format);
  var signatureType = literalFormat === _enums2.default.literal.binary ? _enums2.default.signature.binary : _enums2.default.signature
.text;

  for (var i = 0; i &lt; privateKeys.length; i++) {
    var signingKeyPacket = privateKeys[i].getSigningKeyPacket();
    var signaturePacket = new _packet2.default.Signature();
    signaturePacket.signatureType = signatureType;
    signaturePacket.hashAlgorithm = _config2.default.prefer_hash_algorithm;
    signaturePacket.publicKeyAlgorithm = signingKeyPacket.algorithm;
    if (!signingKeyPacket.isDecrypted) {
      throw new Error('Private key is not decrypted.');
    }
    signaturePacket.sign(signingKeyPacket, literalDataPacket);
    packetlist.push(signaturePacket);
  }
  if (signature) {
    var existingSigPacketlist = signature.packets.filterByTag(_enums2.default.packet.signature);
    packetlist.concat(existingSigPacketlist);
  }

  return new sigModule.Signature(packetlist);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.unwrapCompressed" id="apidoc.element.openpgp.message.Message.prototype.unwrapCompressed">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>unwrapCompressed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unwrapCompressed = function () {
  var compressed = this.packets.filterByTag(_enums2.default.packet.compressed);
  if (compressed.length) {
    return new Message(compressed[0].packets);
  } else {
    return this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.verify" id="apidoc.element.openpgp.message.Message.prototype.verify">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>verify
        <span class="apidocSignatureSpan">(keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verify = function (keys) {
  var msg = this.unwrapCompressed();
  var literalDataList = msg.packets.filterByTag(_enums2.default.packet.literal);
  if (literalDataList.length !== 1) {
    throw new Error('Can only verify message with one literal data packet.');
  }
  var signatureList = msg.packets.filterByTag(_enums2.default.packet.signature);
  return createVerificationObjects(signatureList, literalDataList, keys);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
options = {
    message: openpgp.cleartext.readArmored(cleartext), // parse armored message
    publicKeys: openpgp.key.readArmored(pubkey).keys   // for verification
};

openpgp.<span class="apidocCodeKeywordSpan">verify</span>(options).then(function(verified) {
	validity = verified.signatures[0].valid; // true
	if (validity) {
		console.log('signed by key id ' + verified.signatures[0].keyid.toHex());
	}
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.verifyDetached" id="apidoc.element.openpgp.message.Message.prototype.verifyDetached">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>verifyDetached
        <span class="apidocSignatureSpan">(signature, keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verifyDetached = function (signature, keys) {
  var msg = this.unwrapCompressed();
  var literalDataList = msg.packets.filterByTag(_enums2.default.packet.literal);
  if (literalDataList.length !== 1) {
    throw new Error('Can only verify message with one literal data packet.');
  }
  var signatureList = signature.packets;
  return createVerificationObjects(signatureList, literalDataList, keys);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet" id="apidoc.module.openpgp.packet">module openpgp.packet</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.Compressed" id="apidoc.element.openpgp.packet.Compressed">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>Compressed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Compressed() {
<span class="apidocCodeCommentSpan">  /**
   * Packet type
   * @type {module:enums.packet}
   */
</span>  this.tag = _enums2.default.packet.compressed;
  /**
   * List of packets
   * @type {module:packet/packetlist}
   */
  this.packets = null;
  /**
   * Compression algorithm
   * @type {compression}
   */
  this.algorithm = 'zip';

  /**
   * Compressed packet data
   * @type {String}
   */
  this.compressed = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.List" id="apidoc.element.openpgp.packet.List">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>List
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Packetlist() {
<span class="apidocCodeCommentSpan">  /** The number of packets contained within the list.
   * @readonly
   * @type {Integer} */
</span>  this.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Literal" id="apidoc.element.openpgp.packet.Literal">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>Literal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Literal() {
  this.tag = _enums2.default.packet.literal;
  this.format = 'utf8'; // default format for literal data packets
  this.date = new Date();
  this.data = new Uint8Array(0); // literal data representation
  this.filename = 'msg.txt';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Marker" id="apidoc.element.openpgp.packet.Marker">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>Marker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Marker() {
  this.tag = _enums2.default.packet.marker;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.OnePassSignature" id="apidoc.element.openpgp.packet.OnePassSignature">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>OnePassSignature
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OnePassSignature() {
  this.tag = _enums2.default.packet.onePassSignature; // The packet type
  this.version = null; // A one-octet version number.  The current version is 3.
  this.type = null; // A one-octet signature type.  Signature types are described in {@link http://tools.ietf.org/html/rfc4880#section
-5.2.1|RFC4880 Section 5.2.1}.
  this.hashAlgorithm = null; // A one-octet number describing the hash algorithm used. (See {@link http://tools.ietf.org/html/rfc4880
#section-9.4|RFC4880 9.4})
  this.publicKeyAlgorithm = null; // A one-octet number describing the public-key algorithm used. (See {@link http://tools.ietf.
org/html/rfc4880#section-9.1|RFC4880 9.1})
  this.signingKeyId = null; // An eight-octet number holding the Key ID of the signing key.
  this.flags = null; //  A one-octet number holding a flag showing whether the signature is nested.  A zero value indicates that
 the next packet is another One-Pass Signature packet that describes another signature to be applied to the same message data.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKey" id="apidoc.element.openpgp.packet.PublicKey">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>PublicKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PublicKey() {
  this.tag = _enums2.default.packet.publicKey;
  this.version = 4;
<span class="apidocCodeCommentSpan">  /** Key creation date.
   * @type {Date} */
</span>  this.created = new Date();
  /** A list of multiprecision integers
   * @type {module:type/mpi} */
  this.mpi = [];
  /** Public key algorithm
   * @type {module:enums.publicKey} */
  this.algorithm = 'rsa_sign';
  // time in days (V3 only)
  this.expirationTimeV3 = 0;
  /**
   * Fingerprint in lowercase hex
   * @type {String}
   */
  this.fingerprint = null;
  /**
   * Keyid
   * @type {module:type/keyid}
   */
  this.keyid = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey" id="apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>PublicKeyEncryptedSessionKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PublicKeyEncryptedSessionKey() {
  this.tag = _enums2.default.packet.publicKeyEncryptedSessionKey;
  this.version = 3;

  this.publicKeyId = new _keyid2.default();
  this.publicKeyAlgorithm = 'rsa_encrypt';

  this.sessionKey = null;
  this.sessionKeyAlgorithm = 'aes256';

<span class="apidocCodeCommentSpan">  /** @type {Array&lt;module:type/mpi&gt;} */
</span>  this.encrypted = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicSubkey" id="apidoc.element.openpgp.packet.PublicSubkey">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>PublicSubkey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PublicSubkey() {
  _public_key2.default.call(this);
  this.tag = _enums2.default.packet.publicSubkey;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretKey" id="apidoc.element.openpgp.packet.SecretKey">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>SecretKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SecretKey() {
  _public_key2.default.call(this);
  this.tag = _enums2.default.packet.secretKey;
  // encrypted secret-key data
  this.encrypted = null;
  // indicator if secret-key data is available in decrypted form
  this.isDecrypted = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretSubkey" id="apidoc.element.openpgp.packet.SecretSubkey">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>SecretSubkey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SecretSubkey() {
  _secret_key2.default.call(this);
  this.tag = _enums2.default.packet.secretSubkey;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Signature" id="apidoc.element.openpgp.packet.Signature">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>Signature
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Signature() {
  this.tag = _enums2.default.packet.signature;
  this.version = 4;
  this.signatureType = null;
  this.hashAlgorithm = null;
  this.publicKeyAlgorithm = null;

  this.signatureData = null;
  this.unhashedSubpackets = null;
  this.signedHashValue = null;

  this.created = new Date();
  this.signatureExpirationTime = null;
  this.signatureNeverExpires = true;
  this.exportable = null;
  this.trustLevel = null;
  this.trustAmount = null;
  this.regularExpression = null;
  this.revocable = null;
  this.keyExpirationTime = null;
  this.keyNeverExpires = null;
  this.preferredSymmetricAlgorithms = null;
  this.revocationKeyClass = null;
  this.revocationKeyAlgorithm = null;
  this.revocationKeyFingerprint = null;
  this.issuerKeyId = new _keyid2.default();
  this.notation = null;
  this.preferredHashAlgorithms = null;
  this.preferredCompressionAlgorithms = null;
  this.keyServerPreferences = null;
  this.preferredKeyServer = null;
  this.isPrimaryUserID = null;
  this.policyURI = null;
  this.keyFlags = null;
  this.signersUserId = null;
  this.reasonForRevocationFlag = null;
  this.reasonForRevocationString = null;
  this.features = null;
  this.signatureTargetPublicKeyAlgorithm = null;
  this.signatureTargetHashAlgorithm = null;
  this.signatureTargetHash = null;
  this.embeddedSignature = null;

  this.verified = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected" id="apidoc.element.openpgp.packet.SymEncryptedAEADProtected">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>SymEncryptedAEADProtected
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymEncryptedAEADProtected() {
  this.tag = _enums2.default.packet.symEncryptedAEADProtected;
  this.version = VERSION;
  this.iv = null;
  this.encrypted = null;
  this.packets = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected" id="apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>SymEncryptedIntegrityProtected
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymEncryptedIntegrityProtected() {
  this.tag = _enums2.default.packet.symEncryptedIntegrityProtected;
  this.version = VERSION;
<span class="apidocCodeCommentSpan">  /** The encrypted payload. */
</span>  this.encrypted = null; // string
  /**
   * If after decrypting the packet this is set to true,
   * a modification has been detected and thus the contents
   * should be discarded.
   * @type {Boolean}
   */
  this.modification = false;
  this.packets = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey" id="apidoc.element.openpgp.packet.SymEncryptedSessionKey">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>SymEncryptedSessionKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymEncryptedSessionKey() {
  this.tag = _enums2.default.packet.symEncryptedSessionKey;
  this.version = 4;
  this.sessionKey = null;
  this.sessionKeyEncryptionAlgorithm = null;
  this.sessionKeyAlgorithm = 'aes256';
  this.encrypted = null;
  this.s2k = new _s2k2.default();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted" id="apidoc.element.openpgp.packet.SymmetricallyEncrypted">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>SymmetricallyEncrypted
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymmetricallyEncrypted() {
  this.tag = _enums2.default.packet.symmetricallyEncrypted;
  this.encrypted = null;
<span class="apidocCodeCommentSpan">  /** Decrypted packets contained within.
   * @type {module:packet/packetlist} */
</span>  this.packets = null;
  this.ignore_mdc_error = _config2.default.ignore_mdc_error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Trust" id="apidoc.element.openpgp.packet.Trust">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>Trust
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Trust() {
  this.tag = _enums2.default.packet.trust;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.UserAttribute" id="apidoc.element.openpgp.packet.UserAttribute">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>UserAttribute
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UserAttribute() {
  this.tag = _enums2.default.packet.userAttribute;
  this.attributes = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Userid" id="apidoc.element.openpgp.packet.Userid">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>Userid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Userid() {
  this.tag = _enums2.default.packet.userid;
<span class="apidocCodeCommentSpan">  /** A string containing the user id. Usually in the form
   * John Doe &lt;john@example.com&gt;
   * @type {String}
   */
</span>  this.userid = '';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.fromStructuredClone" id="apidoc.element.openpgp.packet.fromStructuredClone">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>fromStructuredClone
        <span class="apidocSignatureSpan">(packetClone)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromStructuredClone(packetClone) {
  var tagName = _enums2.default.read(_enums2.default.packet, packetClone.tag);
  var packet = newPacketFromTag(tagName);
  for (var attr in packetClone) {
    if (packetClone.hasOwnProperty(attr)) {
      packet[attr] = packetClone[attr];
    }
  }
  if (packet.postCloneTypeFix) {
    packet.postCloneTypeFix();
  }
  return packet;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.newPacketFromTag" id="apidoc.element.openpgp.packet.newPacketFromTag">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>newPacketFromTag
        <span class="apidocSignatureSpan">(tag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function newPacketFromTag(tag) {
  return new packets[packetClassFromTagName(tag)]();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.Compressed" id="apidoc.module.openpgp.packet.Compressed">module openpgp.packet.Compressed</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.Compressed.Compressed" id="apidoc.element.openpgp.packet.Compressed.Compressed">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>Compressed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Compressed() {
<span class="apidocCodeCommentSpan">  /**
   * Packet type
   * @type {module:enums.packet}
   */
</span>  this.tag = _enums2.default.packet.compressed;
  /**
   * List of packets
   * @type {module:packet/packetlist}
   */
  this.packets = null;
  /**
   * Compression algorithm
   * @type {compression}
   */
  this.algorithm = 'zip';

  /**
   * Compressed packet data
   * @type {String}
   */
  this.compressed = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.Compressed.prototype" id="apidoc.module.openpgp.packet.Compressed.prototype">module openpgp.packet.Compressed.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.Compressed.prototype.compress" id="apidoc.element.openpgp.packet.Compressed.prototype.compress">
        function <span class="apidocSignatureSpan">openpgp.packet.Compressed.prototype.</span>compress
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compress = function () {
  var uncompressed, deflate;
  uncompressed = this.packets.write();

  switch (this.algorithm) {

    case 'uncompressed':
      // - Uncompressed
      this.compressed = uncompressed;
      break;

    case 'zip':
      // - ZIP [RFC1951]
      deflate = new _rawdeflateMin2.default.Zlib.RawDeflate(uncompressed);
      this.compressed = deflate.compress();
      break;

    case 'zlib':
      // - ZLIB [RFC1950]
      deflate = new _zlibMin2.default.Zlib.Deflate(uncompressed);
      this.compressed = deflate.compress();
      break;

    case 'bzip2':
      //  - BZip2 [BZ2]
      // TODO: need to implement this
      throw new Error("Compression algorithm BZip2 [BZ2] is not implemented.");

    default:
      throw new Error("Compression algorithm unknown :" + this.type);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Compressed.prototype.decompress" id="apidoc.element.openpgp.packet.Compressed.prototype.decompress">
        function <span class="apidocSignatureSpan">openpgp.packet.Compressed.prototype.</span>decompress
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decompress = function () {
  var decompressed, inflate;

  switch (this.algorithm) {
    case 'uncompressed':
      decompressed = this.compressed;
      break;

    case 'zip':
      inflate = new _rawinflateMin2.default.Zlib.RawInflate(this.compressed);
      decompressed = inflate.decompress();
      break;

    case 'zlib':
      inflate = new _zlibMin2.default.Zlib.Inflate(this.compressed);
      decompressed = inflate.decompress();
      break;

    case 'bzip2':
      // TODO: need to implement this
      throw new Error('Compression algorithm BZip2 [BZ2] is not implemented.');

    default:
      throw new Error("Compression algorithm unknown :" + this.algorithm);
  }

  this.packets.read(decompressed);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Compressed.prototype.read" id="apidoc.element.openpgp.packet.Compressed.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.Compressed.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  // One octet that gives the algorithm used to compress the packet.
  this.algorithm = _enums2.default.read(_enums2.default.compression, bytes[0]);

  // Compressed data, which makes up the remainder of the packet.
  this.compressed = bytes.subarray(1, bytes.length);

  this.decompress();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Compressed.prototype.write" id="apidoc.element.openpgp.packet.Compressed.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.Compressed.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  if (this.compressed === null) {
    this.compress();
  }

  return _util2.default.concatUint8Array(new Uint8Array([_enums2.default.write(_enums2.default.compression, this.algorithm)]), this
.compressed);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.List" id="apidoc.module.openpgp.packet.List">module openpgp.packet.List</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.List.List" id="apidoc.element.openpgp.packet.List.List">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>List
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Packetlist() {
<span class="apidocCodeCommentSpan">  /** The number of packets contained within the list.
   * @readonly
   * @type {Integer} */
</span>  this.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.List.fromStructuredClone" id="apidoc.element.openpgp.packet.List.fromStructuredClone">
        function <span class="apidocSignatureSpan">openpgp.packet.List.</span>fromStructuredClone
        <span class="apidocSignatureSpan">(packetlistClone)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromStructuredClone = function (packetlistClone) {
  var packetlist = new Packetlist();
  for (var i = 0; i &lt; packetlistClone.length; i++) {
    packetlist.push(packets.fromStructuredClone(packetlistClone[i]));
    if (packetlist[i].packets.length !== 0) {
      packetlist[i].packets = this.fromStructuredClone(packetlist[i].packets);
    } else {
      packetlist[i].packets = new Packetlist();
    }
  }
  return packetlist;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.List.prototype" id="apidoc.module.openpgp.packet.List.prototype">module openpgp.packet.List.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.List.prototype.concat" id="apidoc.element.openpgp.packet.List.prototype.concat">
        function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>concat
        <span class="apidocSignatureSpan">(packetlist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concat = function (packetlist) {
  if (packetlist) {
    for (var i = 0; i &lt; packetlist.length; i++) {
      this.push(packetlist[i]);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.List.prototype.filter" id="apidoc.element.openpgp.packet.List.prototype.filter">
        function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>filter
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (callback) {

  var filtered = new Packetlist();

  for (var i = 0; i &lt; this.length; i++) {
    if (callback(this[i], i, this)) {
      filtered.push(this[i]);
    }
  }

  return filtered;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.List.prototype.filterByTag" id="apidoc.element.openpgp.packet.List.prototype.filterByTag">
        function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>filterByTag
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterByTag = function () {
  var args = Array.prototype.slice.call(arguments);
  var filtered = new Packetlist();
  var that = this;

  function handle(packetType) {
    return that[i].tag === packetType;
  }
  for (var i = 0; i &lt; this.length; i++) {
    if (args.some(handle)) {
      filtered.push(this[i]);
    }
  }

  return filtered;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.List.prototype.findPacket" id="apidoc.element.openpgp.packet.List.prototype.findPacket">
        function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>findPacket
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findPacket = function (type) {
  var packetlist = this.filterByTag(type);
  if (packetlist.length) {
    return packetlist[0];
  } else {
    var found = null;
    for (var i = 0; i &lt; this.length; i++) {
      if (this[i].packets.length) {
        found = this[i].packets.findPacket(type);
        if (found) {
          return found;
        }
      }
    }
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.List.prototype.forEach" id="apidoc.element.openpgp.packet.List.prototype.forEach">
        function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback) {
  for (var i = 0; i &lt; this.length; i++) {
    callback(this[i]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.List.prototype.indexOfTag" id="apidoc.element.openpgp.packet.List.prototype.indexOfTag">
        function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>indexOfTag
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexOfTag = function () {
  var args = Array.prototype.slice.call(arguments);
  var tagIndex = [];
  var that = this;

  function handle(packetType) {
    return that[i].tag === packetType;
  }
  for (var i = 0; i &lt; this.length; i++) {
    if (args.some(handle)) {
      tagIndex.push(i);
    }
  }
  return tagIndex;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.List.prototype.pop" id="apidoc.element.openpgp.packet.List.prototype.pop">
        function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>pop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pop = function () {
  if (this.length === 0) {
    return;
  }

  var packet = this[this.length - 1];
  delete this[this.length - 1];
  this.length--;

  return packet;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.List.prototype.push" id="apidoc.element.openpgp.packet.List.prototype.push">
        function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>push
        <span class="apidocSignatureSpan">(packet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (packet) {
  if (!packet) {
    return;
  }

  packet.packets = packet.packets || new Packetlist();

  this[this.length] = packet;
  this.length++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.List.prototype.read" id="apidoc.element.openpgp.packet.List.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  var i = 0;

  while (i &lt; bytes.length) {
    var parsed = _packet2.default.read(bytes, i, bytes.length - i);
    i = parsed.offset;

    var pushed = false;
    try {
      var tag = _enums2.default.read(_enums2.default.packet, parsed.tag);
      var packet = packets.newPacketFromTag(tag);
      this.push(packet);
      pushed = true;
      packet.read(parsed.packet);
    } catch (e) {
      if (!_config2.default.tolerant || parsed.tag == _enums2.default.packet.symmetricallyEncrypted || parsed.tag == _enums2.default
.packet.literal || parsed.tag == _enums2.default.packet.compressed) {
        throw e;
      }
      if (pushed) {
        this.pop(); // drop unsupported packet
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.List.prototype.slice" id="apidoc.element.openpgp.packet.List.prototype.slice">
        function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>slice
        <span class="apidocSignatureSpan">(begin, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">slice = function (begin, end) {
  if (!end) {
    end = this.length;
  }
  var part = new Packetlist();
  for (var i = begin; i &lt; end; i++) {
    part.push(this[i]);
  }
  return part;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.List.prototype.write" id="apidoc.element.openpgp.packet.List.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  var arr = [];

  for (var i = 0; i &lt; this.length; i++) {
    var packetbytes = this[i].write();
    arr.push(_packet2.default.writeHeader(this[i].tag, packetbytes.length));
    arr.push(packetbytes);
  }

  return _util2.default.concatUint8Array(arr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.Literal" id="apidoc.module.openpgp.packet.Literal">module openpgp.packet.Literal</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.Literal.Literal" id="apidoc.element.openpgp.packet.Literal.Literal">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>Literal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Literal() {
  this.tag = _enums2.default.packet.literal;
  this.format = 'utf8'; // default format for literal data packets
  this.date = new Date();
  this.data = new Uint8Array(0); // literal data representation
  this.filename = 'msg.txt';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.Literal.prototype" id="apidoc.module.openpgp.packet.Literal.prototype">module openpgp.packet.Literal.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.Literal.prototype.getBytes" id="apidoc.element.openpgp.packet.Literal.prototype.getBytes">
        function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>getBytes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBytes = function () {
  return this.data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Literal.prototype.getFilename" id="apidoc.element.openpgp.packet.Literal.prototype.getFilename">
        function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>getFilename
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFilename = function () {
  return this.filename;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Literal.prototype.getText" id="apidoc.element.openpgp.packet.Literal.prototype.getText">
        function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>getText
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getText = function () {
  // decode UTF8
  var text = _util2.default.decode_utf8(_util2.default.Uint8Array2str(this.data));
  // normalize EOL to \n
  return text.replace(/\r\n/g, '\n');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Literal.prototype.read" id="apidoc.element.openpgp.packet.Literal.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  // - A one-octet field that describes how the data is formatted.
  var format = _enums2.default.read(_enums2.default.literal, bytes[0]);

  var filename_len = bytes[1];
  this.filename = _util2.default.decode_utf8(_util2.default.Uint8Array2str(bytes.subarray(2, 2 + filename_len)));

  this.date = _util2.default.readDate(bytes.subarray(2 + filename_len, 2 + filename_len + 4));

  var data = bytes.subarray(6 + filename_len, bytes.length);

  this.setBytes(data, format);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Literal.prototype.setBytes" id="apidoc.element.openpgp.packet.Literal.prototype.setBytes">
        function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>setBytes
        <span class="apidocSignatureSpan">(bytes, format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setBytes = function (bytes, format) {
  this.format = format;
  this.data = bytes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Literal.prototype.setFilename" id="apidoc.element.openpgp.packet.Literal.prototype.setFilename">
        function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>setFilename
        <span class="apidocSignatureSpan">(filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setFilename = function (filename) {
  this.filename = filename;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Literal.prototype.setText" id="apidoc.element.openpgp.packet.Literal.prototype.setText">
        function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>setText
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setText = function (text) {
  // normalize EOL to \r\n
  text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').replace(/\n/g, '\r\n');
  // encode UTF8
  this.data = this.format === 'utf8' ? _util2.default.str2Uint8Array(_util2.default.encode_utf8(text)) : _util2.default.str2Uint8Array
(text);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Literal.prototype.write" id="apidoc.element.openpgp.packet.Literal.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  var filename = _util2.default.str2Uint8Array(_util2.default.encode_utf8(this.filename));
  var filename_length = new Uint8Array([filename.length]);

  var format = new Uint8Array([_enums2.default.write(_enums2.default.literal, this.format)]);
  var date = _util2.default.writeDate(this.date);
  var data = this.getBytes();

  return _util2.default.concatUint8Array([format, filename_length, filename, date, data]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.Marker" id="apidoc.module.openpgp.packet.Marker">module openpgp.packet.Marker</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.Marker.Marker" id="apidoc.element.openpgp.packet.Marker.Marker">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>Marker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Marker() {
  this.tag = _enums2.default.packet.marker;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.Marker.prototype" id="apidoc.module.openpgp.packet.Marker.prototype">module openpgp.packet.Marker.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.Marker.prototype.read" id="apidoc.element.openpgp.packet.Marker.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.Marker.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  if (bytes[0] === 0x50 &amp;&amp; // P
  bytes[1] === 0x47 &amp;&amp; // G
  bytes[2] === 0x50) {
    // P
    return true;
  }
  // marker packet does not contain "PGP"
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.OnePassSignature" id="apidoc.module.openpgp.packet.OnePassSignature">module openpgp.packet.OnePassSignature</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.OnePassSignature.OnePassSignature" id="apidoc.element.openpgp.packet.OnePassSignature.OnePassSignature">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>OnePassSignature
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OnePassSignature() {
  this.tag = _enums2.default.packet.onePassSignature; // The packet type
  this.version = null; // A one-octet version number.  The current version is 3.
  this.type = null; // A one-octet signature type.  Signature types are described in {@link http://tools.ietf.org/html/rfc4880#section
-5.2.1|RFC4880 Section 5.2.1}.
  this.hashAlgorithm = null; // A one-octet number describing the hash algorithm used. (See {@link http://tools.ietf.org/html/rfc4880
#section-9.4|RFC4880 9.4})
  this.publicKeyAlgorithm = null; // A one-octet number describing the public-key algorithm used. (See {@link http://tools.ietf.
org/html/rfc4880#section-9.1|RFC4880 9.1})
  this.signingKeyId = null; // An eight-octet number holding the Key ID of the signing key.
  this.flags = null; //  A one-octet number holding a flag showing whether the signature is nested.  A zero value indicates that
 the next packet is another One-Pass Signature packet that describes another signature to be applied to the same message data.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.OnePassSignature.prototype" id="apidoc.module.openpgp.packet.OnePassSignature.prototype">module openpgp.packet.OnePassSignature.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.OnePassSignature.prototype.postCloneTypeFix" id="apidoc.element.openpgp.packet.OnePassSignature.prototype.postCloneTypeFix">
        function <span class="apidocSignatureSpan">openpgp.packet.OnePassSignature.prototype.</span>postCloneTypeFix
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">postCloneTypeFix = function () {
  this.signingKeyId = _keyid2.default.fromClone(this.signingKeyId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.OnePassSignature.prototype.read" id="apidoc.element.openpgp.packet.OnePassSignature.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.OnePassSignature.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  var mypos = 0;
  // A one-octet version number.  The current version is 3.
  this.version = bytes[mypos++];

  // A one-octet signature type.  Signature types are described in
  //   Section 5.2.1.
  this.type = _enums2.default.read(_enums2.default.signature, bytes[mypos++]);

  // A one-octet number describing the hash algorithm used.
  this.hashAlgorithm = _enums2.default.read(_enums2.default.hash, bytes[mypos++]);

  // A one-octet number describing the public-key algorithm used.
  this.publicKeyAlgorithm = _enums2.default.read(_enums2.default.publicKey, bytes[mypos++]);

  // An eight-octet number holding the Key ID of the signing key.
  this.signingKeyId = new _keyid2.default();
  this.signingKeyId.read(bytes.subarray(mypos, mypos + 8));
  mypos += 8;

  // A one-octet number holding a flag showing whether the signature
  //   is nested.  A zero value indicates that the next packet is
  //   another One-Pass Signature packet that describes another
  //   signature to be applied to the same message data.
  this.flags = bytes[mypos++];
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.OnePassSignature.prototype.write" id="apidoc.element.openpgp.packet.OnePassSignature.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.OnePassSignature.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {

  var start = new Uint8Array([3, _enums2.default.write(_enums2.default.signature, this.type), _enums2.default.write(_enums2.default
.hash, this.hashAlgorithm), _enums2.default.write(_enums2.default.publicKey, this.publicKeyAlgorithm)]);

  var end = new Uint8Array([this.flags]);

  return _util2.default.concatUint8Array([start, this.signingKeyId.write(), end]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.PublicKey" id="apidoc.module.openpgp.packet.PublicKey">module openpgp.packet.PublicKey</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKey.PublicKey" id="apidoc.element.openpgp.packet.PublicKey.PublicKey">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>PublicKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PublicKey() {
  this.tag = _enums2.default.packet.publicKey;
  this.version = 4;
<span class="apidocCodeCommentSpan">  /** Key creation date.
   * @type {Date} */
</span>  this.created = new Date();
  /** A list of multiprecision integers
   * @type {module:type/mpi} */
  this.mpi = [];
  /** Public key algorithm
   * @type {module:enums.publicKey} */
  this.algorithm = 'rsa_sign';
  // time in days (V3 only)
  this.expirationTimeV3 = 0;
  /**
   * Fingerprint in lowercase hex
   * @type {String}
   */
  this.fingerprint = null;
  /**
   * Keyid
   * @type {module:type/keyid}
   */
  this.keyid = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.PublicKey.prototype" id="apidoc.module.openpgp.packet.PublicKey.prototype">module openpgp.packet.PublicKey.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKey.prototype.getBitSize" id="apidoc.element.openpgp.packet.PublicKey.prototype.getBitSize">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>getBitSize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBitSize = function () {
  return this.mpi[0].byteLength() * 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKey.prototype.getFingerprint" id="apidoc.element.openpgp.packet.PublicKey.prototype.getFingerprint">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>getFingerprint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFingerprint = function () {
  if (this.fingerprint) {
    return this.fingerprint;
  }
  var toHash = '';
  if (this.version === 4) {
    toHash = this.writeOld();
    this.fingerprint = _util2.default.Uint8Array2str(_crypto2.default.hash.sha1(toHash));
  } else if (this.version === 3) {
    var mpicount = _crypto2.default.getPublicMpiCount(this.algorithm);
    for (var i = 0; i &lt; mpicount; i++) {
      toHash += this.mpi[i].toBytes();
    }
    this.fingerprint = _util2.default.Uint8Array2str(_crypto2.default.hash.md5(_util2.default.str2Uint8Array(toHash)));
  }
  this.fingerprint = _util2.default.hexstrdump(this.fingerprint);
  return this.fingerprint;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKey.prototype.getKeyId" id="apidoc.element.openpgp.packet.PublicKey.prototype.getKeyId">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>getKeyId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getKeyId = function () {
  if (this.keyid) {
    return this.keyid;
  }
  this.keyid = new _keyid2.default();
  if (this.version === 4) {
    this.keyid.read(_util2.default.str2Uint8Array(_util2.default.hex2bin(this.getFingerprint()).substr(12, 8)));
  } else if (this.version === 3) {
    var arr = this.mpi[0].write();
    this.keyid.read(arr.subarray(arr.length - 8, arr.length));
  }
  return this.keyid;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKey.prototype.postCloneTypeFix" id="apidoc.element.openpgp.packet.PublicKey.prototype.postCloneTypeFix">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>postCloneTypeFix
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">postCloneTypeFix = function () {
  for (var i = 0; i &lt; this.mpi.length; i++) {
    this.mpi[i] = _mpi2.default.fromClone(this.mpi[i]);
  }
  if (this.keyid) {
    this.keyid = _keyid2.default.fromClone(this.keyid);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKey.prototype.read" id="apidoc.element.openpgp.packet.PublicKey.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  var pos = 0;
  // A one-octet version number (3 or 4).
  this.version = bytes[pos++];

  if (this.version === 3 || this.version === 4) {
    // - A four-octet number denoting the time that the key was created.
    this.created = _util2.default.readDate(bytes.subarray(pos, pos + 4));
    pos += 4;

    if (this.version === 3) {
      // - A two-octet number denoting the time in days that this key is
      //   valid.  If this number is zero, then it does not expire.
      this.expirationTimeV3 = _util2.default.readNumber(bytes.subarray(pos, pos + 2));
      pos += 2;
    }

    // - A one-octet number denoting the public-key algorithm of this key.
    this.algorithm = _enums2.default.read(_enums2.default.publicKey, bytes[pos++]);

    var mpicount = _crypto2.default.getPublicMpiCount(this.algorithm);
    this.mpi = [];

    var bmpi = bytes.subarray(pos, bytes.length);
    var p = 0;

    for (var i = 0; i &lt; mpicount &amp;&amp; p &lt; bmpi.length; i++) {

      this.mpi[i] = new _mpi2.default();

      p += this.mpi[i].read(bmpi.subarray(p, bmpi.length));

      if (p &gt; bmpi.length) {
        throw new Error('Error reading MPI @:' + p);
      }
    }

    return p + 6;
  } else {
    throw new Error('Version ' + this.version + ' of the key packet is unsupported.');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKey.prototype.readPublicKey" id="apidoc.element.openpgp.packet.PublicKey.prototype.readPublicKey">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>readPublicKey
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readPublicKey = function (bytes) {
  var pos = 0;
  // A one-octet version number (3 or 4).
  this.version = bytes[pos++];

  if (this.version === 3 || this.version === 4) {
    // - A four-octet number denoting the time that the key was created.
    this.created = _util2.default.readDate(bytes.subarray(pos, pos + 4));
    pos += 4;

    if (this.version === 3) {
      // - A two-octet number denoting the time in days that this key is
      //   valid.  If this number is zero, then it does not expire.
      this.expirationTimeV3 = _util2.default.readNumber(bytes.subarray(pos, pos + 2));
      pos += 2;
    }

    // - A one-octet number denoting the public-key algorithm of this key.
    this.algorithm = _enums2.default.read(_enums2.default.publicKey, bytes[pos++]);

    var mpicount = _crypto2.default.getPublicMpiCount(this.algorithm);
    this.mpi = [];

    var bmpi = bytes.subarray(pos, bytes.length);
    var p = 0;

    for (var i = 0; i &lt; mpicount &amp;&amp; p &lt; bmpi.length; i++) {

      this.mpi[i] = new _mpi2.default();

      p += this.mpi[i].read(bmpi.subarray(p, bmpi.length));

      if (p &gt; bmpi.length) {
        throw new Error('Error reading MPI @:' + p);
      }
    }

    return p + 6;
  } else {
    throw new Error('Version ' + this.version + ' of the key packet is unsupported.');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKey.prototype.write" id="apidoc.element.openpgp.packet.PublicKey.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {

  var arr = [];
  // Version
  arr.push(new Uint8Array([this.version]));
  arr.push(_util2.default.writeDate(this.created));
  if (this.version === 3) {
    arr.push(_util2.default.writeNumber(this.expirationTimeV3, 2));
  }
  arr.push(new Uint8Array([_enums2.default.write(_enums2.default.publicKey, this.algorithm)]));

  var mpicount = _crypto2.default.getPublicMpiCount(this.algorithm);

  for (var i = 0; i &lt; mpicount; i++) {
    arr.push(this.mpi[i].write());
  }

  return _util2.default.concatUint8Array(arr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKey.prototype.writeOld" id="apidoc.element.openpgp.packet.PublicKey.prototype.writeOld">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>writeOld
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeOld = function () {
  var bytes = this.writePublicKey();

  return _util2.default.concatUint8Array([new Uint8Array([0x99]), _util2.default.writeNumber(bytes.length, 2), bytes]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKey.prototype.writePublicKey" id="apidoc.element.openpgp.packet.PublicKey.prototype.writePublicKey">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>writePublicKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writePublicKey = function () {

  var arr = [];
  // Version
  arr.push(new Uint8Array([this.version]));
  arr.push(_util2.default.writeDate(this.created));
  if (this.version === 3) {
    arr.push(_util2.default.writeNumber(this.expirationTimeV3, 2));
  }
  arr.push(new Uint8Array([_enums2.default.write(_enums2.default.publicKey, this.algorithm)]));

  var mpicount = _crypto2.default.getPublicMpiCount(this.algorithm);

  for (var i = 0; i &lt; mpicount; i++) {
    arr.push(this.mpi[i].write());
  }

  return _util2.default.concatUint8Array(arr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.PublicKeyEncryptedSessionKey" id="apidoc.module.openpgp.packet.PublicKeyEncryptedSessionKey">module openpgp.packet.PublicKeyEncryptedSessionKey</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.PublicKeyEncryptedSessionKey" id="apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.PublicKeyEncryptedSessionKey">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>PublicKeyEncryptedSessionKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PublicKeyEncryptedSessionKey() {
  this.tag = _enums2.default.packet.publicKeyEncryptedSessionKey;
  this.version = 3;

  this.publicKeyId = new _keyid2.default();
  this.publicKeyAlgorithm = 'rsa_encrypt';

  this.sessionKey = null;
  this.sessionKeyAlgorithm = 'aes256';

<span class="apidocCodeCommentSpan">  /** @type {Array&lt;module:type/mpi&gt;} */
</span>  this.encrypted = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.PublicKeyEncryptedSessionKey.prototype" id="apidoc.module.openpgp.packet.PublicKeyEncryptedSessionKey.prototype">module openpgp.packet.PublicKeyEncryptedSessionKey.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.decrypt" id="apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.decrypt">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKeyEncryptedSessionKey.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (key) {
  var result = _crypto2.default.publicKeyDecrypt(this.publicKeyAlgorithm, key.mpi, this.encrypted).toBytes();

  var checksum = _util2.default.readNumber(_util2.default.str2Uint8Array(result.substr(result.length - 2)));

  var decoded = _crypto2.default.pkcs1.eme.decode(result);

  key = _util2.default.str2Uint8Array(decoded.substring(1, decoded.length - 2));

  if (checksum !== _util2.default.calc_checksum(key)) {
    throw new Error('Checksum mismatch');
  } else {
    this.sessionKey = key;
    this.sessionKeyAlgorithm = _enums2.default.read(_enums2.default.symmetric, decoded.charCodeAt(0));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
options = {
    message: openpgp.message.read(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.<span class="apidocCodeKeywordSpan">decrypt</span>(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
```

#### Encrypt and decrypt *String* data with PGP keys

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.encrypt" id="apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.encrypt">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKeyEncryptedSessionKey.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (key) {
  var data = String.fromCharCode(_enums2.default.write(_enums2.default.symmetric, this.sessionKeyAlgorithm));

  data += _util2.default.Uint8Array2str(this.sessionKey);
  var checksum = _util2.default.calc_checksum(this.sessionKey);
  data += _util2.default.Uint8Array2str(_util2.default.writeNumber(checksum, 2));

  var mpi = new _mpi2.default();
  mpi.fromBytes(_crypto2.default.pkcs1.eme.encode(data, key.mpi[0].byteLength()));

  this.encrypted = _crypto2.default.publicKeyEncrypt(this.publicKeyAlgorithm, key.mpi, mpi);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.<span class="apidocCodeKeywordSpan">encrypt</span>(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.postCloneTypeFix" id="apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.postCloneTypeFix">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKeyEncryptedSessionKey.prototype.</span>postCloneTypeFix
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">postCloneTypeFix = function () {
  this.publicKeyId = _keyid2.default.fromClone(this.publicKeyId);
  for (var i = 0; i &lt; this.encrypted.length; i++) {
    this.encrypted[i] = _mpi2.default.fromClone(this.encrypted[i]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.read" id="apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKeyEncryptedSessionKey.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {

  this.version = bytes[0];
  this.publicKeyId.read(bytes.subarray(1, bytes.length));
  this.publicKeyAlgorithm = _enums2.default.read(_enums2.default.publicKey, bytes[9]);

  var i = 10;

  var integerCount = function (algo) {
    switch (algo) {
      case 'rsa_encrypt':
      case 'rsa_encrypt_sign':
        return 1;

      case 'elgamal':
        return 2;

      default:
        throw new Error("Invalid algorithm.");
    }
  }(this.publicKeyAlgorithm);

  this.encrypted = [];

  for (var j = 0; j &lt; integerCount; j++) {
    var mpi = new _mpi2.default();
    i += mpi.read(bytes.subarray(i, bytes.length));
    this.encrypted.push(mpi);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.write" id="apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKeyEncryptedSessionKey.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {

  var arr = [new Uint8Array([this.version]), this.publicKeyId.write(), new Uint8Array([_enums2.default.write(_enums2.default.publicKey
, this.publicKeyAlgorithm)])];

  for (var i = 0; i &lt; this.encrypted.length; i++) {
    arr.push(this.encrypted[i].write());
  }

  return _util2.default.concatUint8Array(arr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.PublicSubkey" id="apidoc.module.openpgp.packet.PublicSubkey">module openpgp.packet.PublicSubkey</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicSubkey.PublicSubkey" id="apidoc.element.openpgp.packet.PublicSubkey.PublicSubkey">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>PublicSubkey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PublicSubkey() {
  _public_key2.default.call(this);
  this.tag = _enums2.default.packet.publicSubkey;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.PublicSubkey.prototype" id="apidoc.module.openpgp.packet.PublicSubkey.prototype">module openpgp.packet.PublicSubkey.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicSubkey.prototype.constructor" id="apidoc.element.openpgp.packet.PublicSubkey.prototype.constructor">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicSubkey.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PublicSubkey() {
  _public_key2.default.call(this);
  this.tag = _enums2.default.packet.publicSubkey;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.SecretKey" id="apidoc.module.openpgp.packet.SecretKey">module openpgp.packet.SecretKey</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretKey.SecretKey" id="apidoc.element.openpgp.packet.SecretKey.SecretKey">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>SecretKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SecretKey() {
  _public_key2.default.call(this);
  this.tag = _enums2.default.packet.secretKey;
  // encrypted secret-key data
  this.encrypted = null;
  // indicator if secret-key data is available in decrypted form
  this.isDecrypted = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.SecretKey.prototype" id="apidoc.module.openpgp.packet.SecretKey.prototype">module openpgp.packet.SecretKey.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretKey.prototype.clearPrivateMPIs" id="apidoc.element.openpgp.packet.SecretKey.prototype.clearPrivateMPIs">
        function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>clearPrivateMPIs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearPrivateMPIs = function () {
  if (!this.encrypted) {
    throw new Error('If secret key is not encrypted, clearing private MPIs is irreversible.');
  }
  this.mpi = this.mpi.slice(0, _crypto2.default.getPublicMpiCount(this.algorithm));
  this.isDecrypted = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretKey.prototype.constructor" id="apidoc.element.openpgp.packet.SecretKey.prototype.constructor">
        function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SecretKey() {
  _public_key2.default.call(this);
  this.tag = _enums2.default.packet.secretKey;
  // encrypted secret-key data
  this.encrypted = null;
  // indicator if secret-key data is available in decrypted form
  this.isDecrypted = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretKey.prototype.decrypt" id="apidoc.element.openpgp.packet.SecretKey.prototype.decrypt">
        function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(passphrase)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (passphrase) {
  if (this.isDecrypted) {
    return true;
  }

  var i = 0,
      symmetric,
      key;

  var s2k_usage = this.encrypted[i++];

  // - [Optional] If string-to-key usage octet was 255 or 254, a one-
  //   octet symmetric encryption algorithm.
  if (s2k_usage === 255 || s2k_usage === 254) {
    symmetric = this.encrypted[i++];
    symmetric = _enums2.default.read(_enums2.default.symmetric, symmetric);

    // - [Optional] If string-to-key usage octet was 255 or 254, a
    //   string-to-key specifier.  The length of the string-to-key
    //   specifier is implied by its type, as described above.
    var s2k = new _s2k2.default();
    i += s2k.read(this.encrypted.subarray(i, this.encrypted.length));

    key = produceEncryptionKey(s2k, passphrase, symmetric);
  } else {
    symmetric = s2k_usage;
    symmetric = _enums2.default.read(_enums2.default.symmetric, symmetric);
    key = _crypto2.default.hash.md5(passphrase);
  }

  // - [Optional] If secret data is encrypted (string-to-key usage octet
  //   not zero), an Initial Vector (IV) of the same length as the
  //   cipher's block size.
  var iv = this.encrypted.subarray(i, i + _crypto2.default.cipher[symmetric].blockSize);

  i += iv.length;

  var cleartext,
      ciphertext = this.encrypted.subarray(i, this.encrypted.length);

  cleartext = _crypto2.default.cfb.normalDecrypt(symmetric, key, ciphertext, iv);

  var hash = s2k_usage === 254 ? 'sha1' : 'mod';

  var parsedMPI = parse_cleartext_mpi(hash, cleartext, this.algorithm);
  if (parsedMPI instanceof Error) {
    return false;
  }
  this.mpi = this.mpi.concat(parsedMPI);
  this.isDecrypted = true;
  this.encrypted = null;
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
options = {
    message: openpgp.message.read(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.<span class="apidocCodeKeywordSpan">decrypt</span>(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
```

#### Encrypt and decrypt *String* data with PGP keys

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretKey.prototype.encrypt" id="apidoc.element.openpgp.packet.SecretKey.prototype.encrypt">
        function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(passphrase)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (passphrase) {
  if (this.isDecrypted &amp;&amp; !passphrase) {
    this.encrypted = null;
    return;
  } else if (!passphrase) {
    throw new Error('The key must be decrypted before removing passphrase protection.');
  }

  var s2k = new _s2k2.default(),
      symmetric = 'aes256',
      cleartext = write_cleartext_mpi('sha1', this.algorithm, this.mpi),
      key = produceEncryptionKey(s2k, passphrase, symmetric),
      blockLen = _crypto2.default.cipher[symmetric].blockSize,
      iv = _crypto2.default.random.getRandomBytes(blockLen);

  var arr = [new Uint8Array([254, _enums2.default.write(_enums2.default.symmetric, symmetric)])];
  arr.push(s2k.write());
  arr.push(iv);
  arr.push(_crypto2.default.cfb.normalEncrypt(symmetric, key, cleartext, iv));

  this.encrypted = _util2.default.concatUint8Array(arr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.<span class="apidocCodeKeywordSpan">encrypt</span>(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretKey.prototype.generate" id="apidoc.element.openpgp.packet.SecretKey.prototype.generate">
        function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>generate
        <span class="apidocSignatureSpan">(bits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate = function (bits) {
  var self = this;

  return _crypto2.default.generateMpi(self.algorithm, bits).then(function (mpi) {
    self.mpi = mpi;
    self.isDecrypted = true;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretKey.prototype.read" id="apidoc.element.openpgp.packet.SecretKey.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  // - A Public-Key or Public-Subkey packet, as described above.
  var len = this.readPublicKey(bytes);

  bytes = bytes.subarray(len, bytes.length);

  // - One octet indicating string-to-key usage conventions.  Zero
  //   indicates that the secret-key data is not encrypted.  255 or 254
  //   indicates that a string-to-key specifier is being given.  Any
  //   other value is a symmetric-key encryption algorithm identifier.
  var isEncrypted = bytes[0];

  if (isEncrypted) {
    this.encrypted = bytes;
  } else {
    // - Plain or encrypted multiprecision integers comprising the secret
    //   key data.  These algorithm-specific fields are as described
    //   below.
    var parsedMPI = parse_cleartext_mpi('mod', bytes.subarray(1, bytes.length), this.algorithm);
    if (parsedMPI instanceof Error) {
      throw parsedMPI;
    }
    this.mpi = this.mpi.concat(parsedMPI);
    this.isDecrypted = true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretKey.prototype.write" id="apidoc.element.openpgp.packet.SecretKey.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  var arr = [this.writePublicKey()];

  if (!this.encrypted) {
    arr.push(new Uint8Array([0]));
    arr.push(write_cleartext_mpi('mod', this.algorithm, this.mpi));
  } else {
    arr.push(this.encrypted);
  }

  return _util2.default.concatUint8Array(arr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.SecretSubkey" id="apidoc.module.openpgp.packet.SecretSubkey">module openpgp.packet.SecretSubkey</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretSubkey.SecretSubkey" id="apidoc.element.openpgp.packet.SecretSubkey.SecretSubkey">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>SecretSubkey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SecretSubkey() {
  _secret_key2.default.call(this);
  this.tag = _enums2.default.packet.secretSubkey;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.SecretSubkey.prototype" id="apidoc.module.openpgp.packet.SecretSubkey.prototype">module openpgp.packet.SecretSubkey.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretSubkey.prototype.constructor" id="apidoc.element.openpgp.packet.SecretSubkey.prototype.constructor">
        function <span class="apidocSignatureSpan">openpgp.packet.SecretSubkey.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SecretSubkey() {
  _secret_key2.default.call(this);
  this.tag = _enums2.default.packet.secretSubkey;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.Signature" id="apidoc.module.openpgp.packet.Signature">module openpgp.packet.Signature</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.Signature.Signature" id="apidoc.element.openpgp.packet.Signature.Signature">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>Signature
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Signature() {
  this.tag = _enums2.default.packet.signature;
  this.version = 4;
  this.signatureType = null;
  this.hashAlgorithm = null;
  this.publicKeyAlgorithm = null;

  this.signatureData = null;
  this.unhashedSubpackets = null;
  this.signedHashValue = null;

  this.created = new Date();
  this.signatureExpirationTime = null;
  this.signatureNeverExpires = true;
  this.exportable = null;
  this.trustLevel = null;
  this.trustAmount = null;
  this.regularExpression = null;
  this.revocable = null;
  this.keyExpirationTime = null;
  this.keyNeverExpires = null;
  this.preferredSymmetricAlgorithms = null;
  this.revocationKeyClass = null;
  this.revocationKeyAlgorithm = null;
  this.revocationKeyFingerprint = null;
  this.issuerKeyId = new _keyid2.default();
  this.notation = null;
  this.preferredHashAlgorithms = null;
  this.preferredCompressionAlgorithms = null;
  this.keyServerPreferences = null;
  this.preferredKeyServer = null;
  this.isPrimaryUserID = null;
  this.policyURI = null;
  this.keyFlags = null;
  this.signersUserId = null;
  this.reasonForRevocationFlag = null;
  this.reasonForRevocationString = null;
  this.features = null;
  this.signatureTargetPublicKeyAlgorithm = null;
  this.signatureTargetHashAlgorithm = null;
  this.signatureTargetHash = null;
  this.embeddedSignature = null;

  this.verified = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.Signature.prototype" id="apidoc.module.openpgp.packet.Signature.prototype">module openpgp.packet.Signature.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.Signature.prototype.calculateTrailer" id="apidoc.element.openpgp.packet.Signature.prototype.calculateTrailer">
        function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>calculateTrailer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">calculateTrailer = function () {
  // calculating the trailer
  // V3 signatures don't have a trailer
  if (this.version === 3) {
    return new Uint8Array(0);
  }
  var first = new Uint8Array([4, 0xFF]); //Version, ?
  return _util2.default.concatUint8Array([first, _util2.default.writeNumber(this.signatureData.length, 4)]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Signature.prototype.isExpired" id="apidoc.element.openpgp.packet.Signature.prototype.isExpired">
        function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>isExpired
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isExpired = function () {
  if (!this.signatureNeverExpires) {
    return Date.now() &gt; this.created.getTime() + this.signatureExpirationTime * 1000;
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Signature.prototype.postCloneTypeFix" id="apidoc.element.openpgp.packet.Signature.prototype.postCloneTypeFix">
        function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>postCloneTypeFix
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">postCloneTypeFix = function () {
  this.issuerKeyId = _keyid2.default.fromClone(this.issuerKeyId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Signature.prototype.read" id="apidoc.element.openpgp.packet.Signature.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  var _this = this;

  var i = 0;
  this.version = bytes[i++];
  // switch on version (3 and 4)
  var sigpos;
  var sigDataLength;

  (function () {
    switch (_this.version) {
      case 3:
        // One-octet length of following hashed material. MUST be 5.
        if (bytes[i++] !== 5) {
          _util2.default.print_debug("packet/signature.js\n" + 'invalid One-octet length of following hashed material.' + 'MUST
be 5. @:' + (i - 1));
        }

        sigpos = i;
        // One-octet signature type.

        _this.signatureType = bytes[i++];

        // Four-octet creation time.
        _this.created = _util2.default.readDate(bytes.subarray(i, i + 4));
        i += 4;

        // storing data appended to data which gets verified
        _this.signatureData = bytes.subarray(sigpos, i);

        // Eight-octet Key ID of signer.
        _this.issuerKeyId.read(bytes.subarray(i, i + 8));
        i += 8;

        // One-octet public-key algorithm.
        _this.publicKeyAlgorithm = bytes[i++];

        // One-octet hash algorithm.
        _this.hashAlgorithm = bytes[i++];
        break;
      case 4:
        _this.signatureType = bytes[i++];
        _this.publicKeyAlgorithm = bytes[i++];
        _this.hashAlgorithm = bytes[i++];

        var subpackets = function subpackets(bytes) {
          // Two-octet scalar octet count for following subpacket data.
          var subpacket_length = _util2.default.readNumber(bytes.subarray(0, 2));

          var i = 2;

          // subpacket data set (zero or more subpackets)
          while (i &lt; 2 + subpacket_length) {

            var len = _packet2.default.readSimpleLength(bytes.subarray(i, bytes.length));
            i += len.offset;

            this.read_sub_packet(bytes.subarray(i, i + len.len));

            i += len.len;
          }

          return i;
        };

        // hashed subpackets


        i += subpackets.call(_this, bytes.subarray(i, bytes.length), true);

        // A V4 signature hashes the packet body
        // starting from its first field, the version number, through the end
        // of the hashed subpacket data.  Thus, the fields hashed are the
        // signature version, the signature type, the public-key algorithm, the
        // hash algorithm, the hashed subpacket length, and the hashed
        // subpacket body.
        _this.signatureData = bytes.subarray(0, i);
        sigDataLength = i;

        // unhashed subpackets

        i += subpackets.call(_this, bytes.subarray(i, bytes.length), false);
        _this.unhashedSubpackets = bytes.subarray(sigDataLength, i);

        break;
      default:
        throw new Error('Version ' + _this.version + ' of the signature is unsupported.');
    }

    // Two-octet field holding left 16 bits of signed hash value.
  })();

  this.signedHashValue = bytes.subarray(i, i + 2);
  i += 2;

  this.signature = bytes.subarray(i, bytes.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Signature.prototype.read_sub_packet" id="apidoc.element.openpgp.packet.Signature.prototype.read_sub_packet">
        function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>read_sub_packet
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read_sub_packet = function (bytes) {
  var mypos = 0;

  function read_array(prop, bytes) {
    this[prop] = [];

    for (var i = 0; i &lt; bytes.length; i++) {
      this[prop].push(bytes[i]);
    }
  }

  // The leftwost bit denotes a "critical" packet, but we ignore it.
  var type = bytes[mypos++] &amp; 0x7F;
  var seconds;

  // subpacket type
  switch (type) {
    case 2:
      // Signature Creation Time
      this.created = _util2.default.readDate(bytes.subarray(mypos, bytes.length));
      break;
    case 3:
      // Signature Expiration Time in seconds
      seconds = _util2.default.readNumber(bytes.subarray(mypos, bytes.length));

      this.signatureNeverExpires = seconds === 0;
      this.signatureExpirationTime = seconds;

      break;
    case 4:
      // Exportable Certification
      this.exportable = bytes[mypos++] === 1;
      break;
    case 5:
      // Trust Signature
      this.trustLevel = bytes[mypos++];
      this.trustAmount = bytes[mypos++];
      break;
    case 6:
      // Regular Expression
      this.regularExpression = bytes[mypos];
      break;
    case 7:
      // Revocable
      this.revocable = bytes[mypos++] === 1;
      break;
    case 9:
      // Key Expiration Time in seconds
      seconds = _util2.default.readNumber(bytes.subarray(mypos, bytes.length));

      this.keyExpirationTime = seconds;
      this.keyNeverExpires = seconds === 0;

      break;
    case 11:
      // Preferred Symmetric Algorithms
      read_array.call(this, 'preferredSymmetricAlgorithms', bytes.subarray(mypos, bytes.length));
      break;
    case 12:
      // Revocation Key
      // (1 octet of class, 1 octet of public-key algorithm ID, 20
      // octets of
      // fingerprint)
      this.revocationKeyClass = bytes[mypos++];
      this.revocationKeyAlgorithm = bytes[mypos++];
      this.revocationKeyFingerprint = bytes.subarray(mypos, 20);
      break;

    case 16:
      // Issuer
      this.issuerKeyId.read(bytes.subarray(mypos, bytes.length));
      break;

    case 20:
      // Notation Data
      // We don't know how to handle anything but a text flagged data.
      if (bytes[mypos] === 0x80) {

        // We extract key/value tuple from the byte stream.
        mypos += 4;
        var m = _util2.default.readNumber(bytes.subarray(mypos, mypos + 2));
        mypos += 2;
        var n = _util2.default.readNumber(bytes.subarray(mypos, mypos + 2));
        mypos += 2;

        var name = _util2.default.Uint8Array2str(bytes.subarray(mypos, mypos + m)),
            value = _util2.default.Uint8Array2str(bytes.subarray(mypos + m, mypos + m + n));

        this.notation = this.notation || {};
        this.notation[name] = value;
      } else {
        _util2.default.print_debug("Unsupported notation flag " + bytes[mypos]);
      }
      break;
    case 21:
      // Preferred Hash Algorithms
      read_array.call(this, 'preferredHashAlgorithms', bytes.subarray(mypos, bytes.length));
      break;
    case 22:
      // Preferred Compression Algorithms
      read_array.call(this, 'preferredCompressionAlgorithms', bytes.subarray(mypos, bytes.length));
      break;
    case 23:
      // Key Server Preferences
      read_array.call(this, 'keyServerPreferencess', bytes.subarray(mypos, bytes.length));
      break;
    case 24:
      // Preferred Key Server
      this.preferredKeyServer = _util2.default.Uint8Array2str(bytes.subarray(mypos, bytes.length));
      break;
    case 25:
      // Primary User ID
      this.isPrimaryUserID = bytes[mypos++] !== 0;
      break;
    case 26:
      // Policy URI
      this.policyURI = _util2.default.Uint8Array2str(bytes.subarray(mypos, bytes.length));
      break;
    case 27:
      // Key Flags
      read_array.call(this, 'keyFlags', bytes.subarray(mypos, bytes.length));
      break;
    case 28:
      // Signer's User ID
      this.signersUserId += _util2.default.Uint8Array2str(bytes.subarray(mypos, bytes.length));
      break;
    case 29:
      // Reason for Revocation
      this.reasonForRevocationFlag = bytes[mypos++];
      this.reasonForRevocationString = _util2.default.Uint8Array2str(bytes.subarra ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Signature.prototype.sign" id="apidoc.element.openpgp.packet.Signature.prototype.sign">
        function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>sign
        <span class="apidocSignatureSpan">(key, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sign = function (key, data) {
  var signatureType = _enums2.default.write(_enums2.default.signature, this.signatureType),
      publicKeyAlgorithm = _enums2.default.write(_enums2.default.publicKey, this.publicKeyAlgorithm),
      hashAlgorithm = _enums2.default.write(_enums2.default.hash, this.hashAlgorithm);

  var arr = [new Uint8Array([4, signatureType, publicKeyAlgorithm, hashAlgorithm])];

  this.issuerKeyId = key.getKeyId();

  // Add hashed subpackets
  arr.push(this.write_all_sub_packets());

  this.signatureData = _util2.default.concatUint8Array(arr);

  var trailer = this.calculateTrailer();

  var toHash = null;

  switch (this.version) {
    case 3:
      toHash = _util2.default.concatUint8Array([this.toSign(signatureType, data), new Uint8Array([signatureType]), _util2.default
.writeDate(this.created)]);
      break;
    case 4:
      toHash = _util2.default.concatUint8Array([this.toSign(signatureType, data), this.signatureData, trailer]);
      break;
    default:
      throw new Error('Version ' + this.version + ' of the signature is unsupported.');
  }

  var hash = _crypto2.default.hash.digest(hashAlgorithm, toHash);

  this.signedHashValue = hash.subarray(0, 2);

  this.signature = _crypto2.default.signature.sign(hashAlgorithm, publicKeyAlgorithm, key.mpi, toHash);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
options = {
data: 'Hello, World!',                             // input as String (or Uint8Array)
privateKeys: privKeyObj // for signing
};

openpgp.<span class="apidocCodeKeywordSpan">sign</span>(options).then(function(signed) {
cleartext = signed.data; // '-----BEGIN PGP SIGNED MESSAGE ... END PGP SIGNATURE-----'
});
```

```js
options = {
message: openpgp.cleartext.readArmored(cleartext), // parse armored message
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Signature.prototype.toSign" id="apidoc.element.openpgp.packet.Signature.prototype.toSign">
        function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>toSign
        <span class="apidocSignatureSpan">(type, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSign = function (type, data) {
  var t = _enums2.default.signature;

  switch (type) {
    case t.binary:
    case t.text:
      return data.getBytes();

    case t.standalone:
      return new Uint8Array(0);

    case t.cert_generic:
    case t.cert_persona:
    case t.cert_casual:
    case t.cert_positive:
    case t.cert_revocation:
      var packet, tag;

      if (data.userid !== undefined) {
        tag = 0xB4;
        packet = data.userid;
      } else if (data.userattribute !== undefined) {
        tag = 0xD1;
        packet = data.userattribute;
      } else {
        throw new Error('Either a userid or userattribute packet needs to be ' + 'supplied for certification.');
      }

      var bytes = packet.write();

      if (this.version === 4) {
        return _util2.default.concatUint8Array([this.toSign(t.key, data), new Uint8Array([tag]), _util2.default.writeNumber(bytes
.length, 4), bytes]);
      } else if (this.version === 3) {
        return _util2.default.concatUint8Array([this.toSign(t.key, data), bytes]);
      }
      break;

    case t.subkey_binding:
    case t.subkey_revocation:
    case t.key_binding:
      return _util2.default.concatUint8Array([this.toSign(t.key, data), this.toSign(t.key, {
        key: data.bind
      })]);

    case t.key:
      if (data.key === undefined) {
        throw new Error('Key packet is required for this signature.');
      }
      return data.key.writeOld();

    case t.key_revocation:
      return this.toSign(t.key, data);
    case t.timestamp:
      return new Uint8Array(0);
    case t.third_party:
      throw new Error('Not implemented');
    default:
      throw new Error('Unknown signature type.');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Signature.prototype.verify" id="apidoc.element.openpgp.packet.Signature.prototype.verify">
        function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>verify
        <span class="apidocSignatureSpan">(key, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verify = function (key, data) {
  var signatureType = _enums2.default.write(_enums2.default.signature, this.signatureType),
      publicKeyAlgorithm = _enums2.default.write(_enums2.default.publicKey, this.publicKeyAlgorithm),
      hashAlgorithm = _enums2.default.write(_enums2.default.hash, this.hashAlgorithm);

  var bytes = this.toSign(signatureType, data),
      trailer = this.calculateTrailer();

  var mpicount = 0;
  // Algorithm-Specific Fields for RSA signatures:
  //      - multiprecision number (MPI) of RSA signature value m**d mod n.
  if (publicKeyAlgorithm &gt; 0 &amp;&amp; publicKeyAlgorithm &lt; 4) {
    mpicount = 1;
  }
  //    Algorithm-Specific Fields for DSA signatures:
  //      - MPI of DSA value r.
  //      - MPI of DSA value s.
  else if (publicKeyAlgorithm === 17) {
      mpicount = 2;
    }

  var mpi = [],
      i = 0;
  for (var j = 0; j &lt; mpicount; j++) {
    mpi[j] = new _mpi2.default();
    i += mpi[j].read(this.signature.subarray(i, this.signature.length));
  }

  this.verified = _crypto2.default.signature.verify(publicKeyAlgorithm, hashAlgorithm, mpi, key.mpi, _util2.default.concatUint8Array
([bytes, this.signatureData, trailer]));

  return this.verified;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
options = {
    message: openpgp.cleartext.readArmored(cleartext), // parse armored message
    publicKeys: openpgp.key.readArmored(pubkey).keys   // for verification
};

openpgp.<span class="apidocCodeKeywordSpan">verify</span>(options).then(function(verified) {
	validity = verified.signatures[0].valid; // true
	if (validity) {
		console.log('signed by key id ' + verified.signatures[0].keyid.toHex());
	}
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Signature.prototype.write" id="apidoc.element.openpgp.packet.Signature.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  var arr = [];
  switch (this.version) {
    case 3:
      arr.push(new Uint8Array([3, 5])); // version, One-octet length of following hashed material.  MUST be 5
      arr.push(new Uint8Array([this.signatureType]));
      arr.push(_util2.default.writeDate(this.created));
      arr.push(this.issuerKeyId.write());
      arr.push(new Uint8Array([_enums2.default.write(_enums2.default.publicKey, this.publicKeyAlgorithm), _enums2.default.write(
_enums2.default.hash, this.hashAlgorithm)]));
      break;
    case 4:
      arr.push(this.signatureData);
      arr.push(this.unhashedSubpackets ? this.unhashedSubpackets : _util2.default.writeNumber(0, 2));
      break;
  }
  arr.push(this.signedHashValue);
  arr.push(this.signature);
  return _util2.default.concatUint8Array(arr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Signature.prototype.write_all_sub_packets" id="apidoc.element.openpgp.packet.Signature.prototype.write_all_sub_packets">
        function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>write_all_sub_packets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write_all_sub_packets = function () {
  var sub = _enums2.default.signatureSubpacket;
  var arr = [];
  var bytes;
  if (this.created !== null) {
    arr.push(write_sub_packet(sub.signature_creation_time, _util2.default.writeDate(this.created)));
  }
  if (this.signatureExpirationTime !== null) {
    arr.push(write_sub_packet(sub.signature_expiration_time, _util2.default.writeNumber(this.signatureExpirationTime, 4)));
  }
  if (this.exportable !== null) {
    arr.push(write_sub_packet(sub.exportable_certification, new Uint8Array([this.exportable ? 1 : 0])));
  }
  if (this.trustLevel !== null) {
    bytes = new Uint8Array([this.trustLevel, this.trustAmount]);
    arr.push(write_sub_packet(sub.trust_signature, bytes));
  }
  if (this.regularExpression !== null) {
    arr.push(write_sub_packet(sub.regular_expression, this.regularExpression));
  }
  if (this.revocable !== null) {
    arr.push(write_sub_packet(sub.revocable, new Uint8Array([this.revocable ? 1 : 0])));
  }
  if (this.keyExpirationTime !== null) {
    arr.push(write_sub_packet(sub.key_expiration_time, _util2.default.writeNumber(this.keyExpirationTime, 4)));
  }
  if (this.preferredSymmetricAlgorithms !== null) {
    bytes = _util2.default.str2Uint8Array(_util2.default.bin2str(this.preferredSymmetricAlgorithms));
    arr.push(write_sub_packet(sub.preferred_symmetric_algorithms, bytes));
  }
  if (this.revocationKeyClass !== null) {

    bytes = new Uint8Array([this.revocationKeyClass, this.revocationKeyAlgorithm]);
    bytes = _util2.default.concatUint8Array([bytes, this.revocationKeyFingerprint]);
    arr.push(write_sub_packet(sub.revocation_key, bytes));
  }
  if (!this.issuerKeyId.isNull()) {
    arr.push(write_sub_packet(sub.issuer, this.issuerKeyId.write()));
  }
  if (this.notation !== null) {
    for (var name in this.notation) {
      if (this.notation.hasOwnProperty(name)) {
        var value = this.notation[name];
        bytes = [new Uint8Array([0x80, 0, 0, 0])];
        // 2 octets of name length
        bytes.push(_util2.default.writeNumber(name.length, 2));
        // 2 octets of value length
        bytes.push(_util2.default.writeNumber(value.length, 2));
        bytes.push(_util2.default.str2Uint8Array(name + value));
        bytes = _util2.default.concatUint8Array(bytes);
        arr.push(write_sub_packet(sub.notation_data, bytes));
      }
    }
  }
  if (this.preferredHashAlgorithms !== null) {
    bytes = _util2.default.str2Uint8Array(_util2.default.bin2str(this.preferredHashAlgorithms));
    arr.push(write_sub_packet(sub.preferred_hash_algorithms, bytes));
  }
  if (this.preferredCompressionAlgorithms !== null) {
    bytes = _util2.default.str2Uint8Array(_util2.default.bin2str(this.preferredCompressionAlgorithms));
    arr.push(write_sub_packet(sub.preferred_compression_algorithms, bytes));
  }
  if (this.keyServerPreferences !== null) {
    bytes = _util2.default.str2Uint8Array(_util2.default.bin2str(this.keyServerPreferences));
    arr.push(write_sub_packet(sub.key_server_preferences, bytes));
  }
  if (this.preferredKeyServer !== null) {
    arr.push(write_sub_packet(sub.preferred_key_server, _util2.default.str2Uint8Array(this.preferredKeyServer)));
  }
  if (this.isPrimaryUserID !== null) {
    arr.push(write_sub_packet(sub.primary_user_id, new Uint8Array([this.isPrimaryUserID ? 1 : 0])));
  }
  if (this.policyURI !== null) {
    arr.push(write_sub_packet(sub.policy_uri, _util2.default.str2Uint8Array(this.policyURI)));
  }
  if (this.keyFlags !== null) {
    bytes = _util2.default.str2Uint8Array(_util2.default.bin2str(this.keyFlags));
    arr.push(write_sub_packet(sub.key_flags, bytes));
  }
  if (this.signersUserId !== null) {
    arr.push(write_sub_packet(sub.signers_user_id, _util2.default.str2Uint8Array(this.signersUserId)));
  }
  if (this.reasonForRevocationFlag !== null) {
    bytes = _util2.default.str2Uint8Array(String.fromCharCode(this.reasonForRevocationFlag) + this.reasonForRevocationString);
    arr.push(write_sub_packet(sub.reason_for_revocation, bytes));
  }
  if (this.features !== null) {
    bytes = _util2.default.str2Uint8Array(_util2.default ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.SymEncryptedAEADProtected" id="apidoc.module.openpgp.packet.SymEncryptedAEADProtected">module openpgp.packet.SymEncryptedAEADProtected</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected.SymEncryptedAEADProtected" id="apidoc.element.openpgp.packet.SymEncryptedAEADProtected.SymEncryptedAEADProtected">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>SymEncryptedAEADProtected
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymEncryptedAEADProtected() {
  this.tag = _enums2.default.packet.symEncryptedAEADProtected;
  this.version = VERSION;
  this.iv = null;
  this.encrypted = null;
  this.packets = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.SymEncryptedAEADProtected.prototype" id="apidoc.module.openpgp.packet.SymEncryptedAEADProtected.prototype">module openpgp.packet.SymEncryptedAEADProtected.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected.prototype.decrypt" id="apidoc.element.openpgp.packet.SymEncryptedAEADProtected.prototype.decrypt">
        function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedAEADProtected.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(sessionKeyAlgorithm, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (sessionKeyAlgorithm, key) {
  var _this = this;

  return _crypto2.default.gcm.decrypt(sessionKeyAlgorithm, this.encrypted, key, this.iv).then(function (decrypted) {
    _this.packets.read(decrypted);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
options = {
    message: openpgp.message.read(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.<span class="apidocCodeKeywordSpan">decrypt</span>(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
```

#### Encrypt and decrypt *String* data with PGP keys

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected.prototype.encrypt" id="apidoc.element.openpgp.packet.SymEncryptedAEADProtected.prototype.encrypt">
        function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedAEADProtected.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(sessionKeyAlgorithm, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (sessionKeyAlgorithm, key) {
  var _this2 = this;

  this.iv = _crypto2.default.random.getRandomValues(new Uint8Array(IV_LEN)); // generate new random IV
  return _crypto2.default.gcm.encrypt(sessionKeyAlgorithm, this.packets.write(), key, this.iv).then(function (encrypted) {
    _this2.encrypted = encrypted;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.<span class="apidocCodeKeywordSpan">encrypt</span>(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected.prototype.read" id="apidoc.element.openpgp.packet.SymEncryptedAEADProtected.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedAEADProtected.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  var offset = 0;
  if (bytes[offset] !== VERSION) {
    // The only currently defined value is 1.
    throw new Error('Invalid packet version.');
  }
  offset++;
  this.iv = bytes.subarray(offset, IV_LEN + offset);
  offset += IV_LEN;
  this.encrypted = bytes.subarray(offset, bytes.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected.prototype.write" id="apidoc.element.openpgp.packet.SymEncryptedAEADProtected.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedAEADProtected.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  return _util2.default.concatUint8Array([new Uint8Array([this.version]), this.iv, this.encrypted]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.SymEncryptedIntegrityProtected" id="apidoc.module.openpgp.packet.SymEncryptedIntegrityProtected">module openpgp.packet.SymEncryptedIntegrityProtected</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.SymEncryptedIntegrityProtected" id="apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.SymEncryptedIntegrityProtected">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>SymEncryptedIntegrityProtected
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymEncryptedIntegrityProtected() {
  this.tag = _enums2.default.packet.symEncryptedIntegrityProtected;
  this.version = VERSION;
<span class="apidocCodeCommentSpan">  /** The encrypted payload. */
</span>  this.encrypted = null; // string
  /**
   * If after decrypting the packet this is set to true,
   * a modification has been detected and thus the contents
   * should be discarded.
   * @type {Boolean}
   */
  this.modification = false;
  this.packets = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.SymEncryptedIntegrityProtected.prototype" id="apidoc.module.openpgp.packet.SymEncryptedIntegrityProtected.prototype">module openpgp.packet.SymEncryptedIntegrityProtected.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.prototype.decrypt" id="apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.prototype.decrypt">
        function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedIntegrityProtected.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(sessionKeyAlgorithm, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (sessionKeyAlgorithm, key) {
  var decrypted = void 0;
  if (sessionKeyAlgorithm.substr(0, 3) === 'aes') {
    // AES optimizations. Native code for node, asmCrypto for browser.
    decrypted = aesDecrypt(sessionKeyAlgorithm, this.encrypted, key);
  } else {
    decrypted = _crypto2.default.cfb.decrypt(sessionKeyAlgorithm, key, this.encrypted, false);
  }

  // there must be a modification detection code packet as the
  // last packet and everything gets hashed except the hash itself
  var prefix = _crypto2.default.cfb.mdc(sessionKeyAlgorithm, key, this.encrypted);
  var bytes = decrypted.subarray(0, decrypted.length - 20);
  var tohash = _util2.default.concatUint8Array([prefix, bytes]);
  this.hash = _util2.default.Uint8Array2str(_crypto2.default.hash.sha1(tohash));
  var mdc = _util2.default.Uint8Array2str(decrypted.subarray(decrypted.length - 20, decrypted.length));

  if (this.hash !== mdc) {
    throw new Error('Modification detected.');
  } else {
    this.packets.read(decrypted.subarray(0, decrypted.length - 22));
  }

  return Promise.resolve();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
options = {
    message: openpgp.message.read(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.<span class="apidocCodeKeywordSpan">decrypt</span>(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
```

#### Encrypt and decrypt *String* data with PGP keys

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.prototype.encrypt" id="apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.prototype.encrypt">
        function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedIntegrityProtected.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(sessionKeyAlgorithm, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (sessionKeyAlgorithm, key) {
  var bytes = this.packets.write();
  var prefixrandom = _crypto2.default.getPrefixRandom(sessionKeyAlgorithm);
  var repeat = new Uint8Array([prefixrandom[prefixrandom.length - 2], prefixrandom[prefixrandom.length - 1]]);
  var prefix = _util2.default.concatUint8Array([prefixrandom, repeat]);
  var mdc = new Uint8Array([0xD3, 0x14]); // modification detection code packet

  var tohash = _util2.default.concatUint8Array([bytes, mdc]);
  var hash = _crypto2.default.hash.sha1(_util2.default.concatUint8Array([prefix, tohash]));
  tohash = _util2.default.concatUint8Array([tohash, hash]);

  if (sessionKeyAlgorithm.substr(0, 3) === 'aes') {
    // AES optimizations. Native code for node, asmCrypto for browser.
    this.encrypted = aesEncrypt(sessionKeyAlgorithm, prefix, tohash, key);
  } else {
    this.encrypted = _crypto2.default.cfb.encrypt(prefixrandom, sessionKeyAlgorithm, tohash, key, false);
    this.encrypted = this.encrypted.subarray(0, prefix.length + tohash.length);
  }

  return Promise.resolve();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.<span class="apidocCodeKeywordSpan">encrypt</span>(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.prototype.read" id="apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedIntegrityProtected.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  // - A one-octet version number. The only currently defined value is 1.
  if (bytes[0] !== VERSION) {
    throw new Error('Invalid packet version.');
  }

  // - Encrypted data, the output of the selected symmetric-key cipher
  //   operating in Cipher Feedback mode with shift amount equal to the
  //   block size of the cipher (CFB-n where n is the block size).
  this.encrypted = bytes.subarray(1, bytes.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.prototype.write" id="apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedIntegrityProtected.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  return _util2.default.concatUint8Array([new Uint8Array([VERSION]), this.encrypted]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.SymEncryptedSessionKey" id="apidoc.module.openpgp.packet.SymEncryptedSessionKey">module openpgp.packet.SymEncryptedSessionKey</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey.SymEncryptedSessionKey" id="apidoc.element.openpgp.packet.SymEncryptedSessionKey.SymEncryptedSessionKey">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>SymEncryptedSessionKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymEncryptedSessionKey() {
  this.tag = _enums2.default.packet.symEncryptedSessionKey;
  this.version = 4;
  this.sessionKey = null;
  this.sessionKeyEncryptionAlgorithm = null;
  this.sessionKeyAlgorithm = 'aes256';
  this.encrypted = null;
  this.s2k = new _s2k2.default();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.SymEncryptedSessionKey.prototype" id="apidoc.module.openpgp.packet.SymEncryptedSessionKey.prototype">module openpgp.packet.SymEncryptedSessionKey.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.decrypt" id="apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.decrypt">
        function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedSessionKey.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(passphrase)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (passphrase) {
  var algo = this.sessionKeyEncryptionAlgorithm !== null ? this.sessionKeyEncryptionAlgorithm : this.sessionKeyAlgorithm;

  var length = _crypto2.default.cipher[algo].keySize;
  var key = this.s2k.produce_key(passphrase, length);

  if (this.encrypted === null) {
    this.sessionKey = key;
  } else {
    var decrypted = _crypto2.default.cfb.normalDecrypt(algo, key, this.encrypted, null);

    this.sessionKeyAlgorithm = _enums2.default.read(_enums2.default.symmetric, decrypted[0]);

    this.sessionKey = decrypted.subarray(1, decrypted.length);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
options = {
    message: openpgp.message.read(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.<span class="apidocCodeKeywordSpan">decrypt</span>(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
```

#### Encrypt and decrypt *String* data with PGP keys

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.encrypt" id="apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.encrypt">
        function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedSessionKey.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(passphrase)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (passphrase) {
  var algo = this.sessionKeyEncryptionAlgorithm !== null ? this.sessionKeyEncryptionAlgorithm : this.sessionKeyAlgorithm;

  this.sessionKeyEncryptionAlgorithm = algo;

  var length = _crypto2.default.cipher[algo].keySize;
  var key = this.s2k.produce_key(passphrase, length);

  var algo_enum = new Uint8Array([_enums2.default.write(_enums2.default.symmetric, this.sessionKeyAlgorithm)]);

  var private_key;
  if (this.sessionKey === null) {
    this.sessionKey = _crypto2.default.getRandomBytes(_crypto2.default.cipher[this.sessionKeyAlgorithm].keySize);
  }
  private_key = _util2.default.concatUint8Array([algo_enum, this.sessionKey]);

  this.encrypted = _crypto2.default.cfb.normalEncrypt(algo, key, private_key, null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.<span class="apidocCodeKeywordSpan">encrypt</span>(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.postCloneTypeFix" id="apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.postCloneTypeFix">
        function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedSessionKey.prototype.</span>postCloneTypeFix
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">postCloneTypeFix = function () {
  this.s2k = _s2k2.default.fromClone(this.s2k);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.read" id="apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedSessionKey.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  // A one-octet version number. The only currently defined version is 4.
  this.version = bytes[0];

  // A one-octet number describing the symmetric algorithm used.
  var algo = _enums2.default.read(_enums2.default.symmetric, bytes[1]);

  // A string-to-key (S2K) specifier, length as defined above.
  var s2klength = this.s2k.read(bytes.subarray(2, bytes.length));

  // Optionally, the encrypted session key itself, which is decrypted
  // with the string-to-key object.
  var done = s2klength + 2;

  if (done &lt; bytes.length) {
    this.encrypted = bytes.subarray(done, bytes.length);
    this.sessionKeyEncryptionAlgorithm = algo;
  } else {
    this.sessionKeyAlgorithm = algo;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.write" id="apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedSessionKey.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  var algo = this.encrypted === null ? this.sessionKeyAlgorithm : this.sessionKeyEncryptionAlgorithm;

  var bytes = _util2.default.concatUint8Array([new Uint8Array([this.version, _enums2.default.write(_enums2.default.symmetric, algo
)]), this.s2k.write()]);

  if (this.encrypted !== null) {
    bytes = _util2.default.concatUint8Array([bytes, this.encrypted]);
  }
  return bytes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.SymmetricallyEncrypted" id="apidoc.module.openpgp.packet.SymmetricallyEncrypted">module openpgp.packet.SymmetricallyEncrypted</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted.SymmetricallyEncrypted" id="apidoc.element.openpgp.packet.SymmetricallyEncrypted.SymmetricallyEncrypted">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>SymmetricallyEncrypted
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymmetricallyEncrypted() {
  this.tag = _enums2.default.packet.symmetricallyEncrypted;
  this.encrypted = null;
<span class="apidocCodeCommentSpan">  /** Decrypted packets contained within.
   * @type {module:packet/packetlist} */
</span>  this.packets = null;
  this.ignore_mdc_error = _config2.default.ignore_mdc_error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.SymmetricallyEncrypted.prototype" id="apidoc.module.openpgp.packet.SymmetricallyEncrypted.prototype">module openpgp.packet.SymmetricallyEncrypted.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted.prototype.decrypt" id="apidoc.element.openpgp.packet.SymmetricallyEncrypted.prototype.decrypt">
        function <span class="apidocSignatureSpan">openpgp.packet.SymmetricallyEncrypted.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(sessionKeyAlgorithm, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (sessionKeyAlgorithm, key) {
  var decrypted = _crypto2.default.cfb.decrypt(sessionKeyAlgorithm, key, this.encrypted, true);
  // for modern cipher (blocklength != 64 bit, except for Twofish) MDC is required
  if (!this.ignore_mdc_error &amp;&amp; (sessionKeyAlgorithm === 'aes128' || sessionKeyAlgorithm === 'aes192' || sessionKeyAlgorithm === '
aes256')) {
    throw new Error('Decryption failed due to missing MDC in combination with modern cipher.');
  }
  this.packets.read(decrypted);

  return Promise.resolve();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
options = {
    message: openpgp.message.read(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.<span class="apidocCodeKeywordSpan">decrypt</span>(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
```

#### Encrypt and decrypt *String* data with PGP keys

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted.prototype.encrypt" id="apidoc.element.openpgp.packet.SymmetricallyEncrypted.prototype.encrypt">
        function <span class="apidocSignatureSpan">openpgp.packet.SymmetricallyEncrypted.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(algo, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (algo, key) {
  var data = this.packets.write();

  this.encrypted = _crypto2.default.cfb.encrypt(_crypto2.default.getPrefixRandom(algo), algo, data, key, true);

  return Promise.resolve();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.<span class="apidocCodeKeywordSpan">encrypt</span>(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted.prototype.read" id="apidoc.element.openpgp.packet.SymmetricallyEncrypted.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.SymmetricallyEncrypted.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  this.encrypted = bytes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted.prototype.write" id="apidoc.element.openpgp.packet.SymmetricallyEncrypted.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.SymmetricallyEncrypted.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  return this.encrypted;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.Trust" id="apidoc.module.openpgp.packet.Trust">module openpgp.packet.Trust</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.Trust.Trust" id="apidoc.element.openpgp.packet.Trust.Trust">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>Trust
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Trust() {
  this.tag = _enums2.default.packet.trust;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.Trust.prototype" id="apidoc.module.openpgp.packet.Trust.prototype">module openpgp.packet.Trust.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.Trust.prototype.read" id="apidoc.element.openpgp.packet.Trust.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.Trust.prototype.</span>read
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.UserAttribute" id="apidoc.module.openpgp.packet.UserAttribute">module openpgp.packet.UserAttribute</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.UserAttribute.UserAttribute" id="apidoc.element.openpgp.packet.UserAttribute.UserAttribute">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>UserAttribute
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UserAttribute() {
  this.tag = _enums2.default.packet.userAttribute;
  this.attributes = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.UserAttribute.prototype" id="apidoc.module.openpgp.packet.UserAttribute.prototype">module openpgp.packet.UserAttribute.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.UserAttribute.prototype.equals" id="apidoc.element.openpgp.packet.UserAttribute.prototype.equals">
        function <span class="apidocSignatureSpan">openpgp.packet.UserAttribute.prototype.</span>equals
        <span class="apidocSignatureSpan">(usrAttr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equals = function (usrAttr) {
  if (!usrAttr || !(usrAttr instanceof UserAttribute)) {
    return false;
  }
  return this.attributes.every(function (attr, index) {
    return attr === usrAttr.attributes[index];
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.UserAttribute.prototype.read" id="apidoc.element.openpgp.packet.UserAttribute.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.UserAttribute.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  var i = 0;
  while (i &lt; bytes.length) {
    var len = _packet2.default.readSimpleLength(bytes.subarray(i, bytes.length));
    i += len.offset;

    this.attributes.push(_util2.default.Uint8Array2str(bytes.subarray(i, i + len.len)));
    i += len.len;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.UserAttribute.prototype.write" id="apidoc.element.openpgp.packet.UserAttribute.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.UserAttribute.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  var arr = [];
  for (var i = 0; i &lt; this.attributes.length; i++) {
    arr.push(_packet2.default.writeSimpleLength(this.attributes[i].length));
    arr.push(_util2.default.str2Uint8Array(this.attributes[i]));
  }
  return _util2.default.concatUint8Array(arr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.Userid" id="apidoc.module.openpgp.packet.Userid">module openpgp.packet.Userid</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.Userid.Userid" id="apidoc.element.openpgp.packet.Userid.Userid">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>Userid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Userid() {
  this.tag = _enums2.default.packet.userid;
<span class="apidocCodeCommentSpan">  /** A string containing the user id. Usually in the form
   * John Doe &lt;john@example.com&gt;
   * @type {String}
   */
</span>  this.userid = '';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.Userid.prototype" id="apidoc.module.openpgp.packet.Userid.prototype">module openpgp.packet.Userid.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.Userid.prototype.read" id="apidoc.element.openpgp.packet.Userid.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.Userid.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  this.userid = _util2.default.decode_utf8(_util2.default.Uint8Array2str(bytes));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Userid.prototype.write" id="apidoc.element.openpgp.packet.Userid.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.Userid.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  return _util2.default.str2Uint8Array(_util2.default.encode_utf8(this.userid));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.clone" id="apidoc.module.openpgp.packet.clone">module openpgp.packet.clone</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.clone.clonePackets" id="apidoc.element.openpgp.packet.clone.clonePackets">
        function <span class="apidocSignatureSpan">openpgp.packet.clone.</span>clonePackets
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clonePackets(options) {
  if (options.publicKeys) {
    options.publicKeys = options.publicKeys.map(function (key) {
      return key.toPacketlist();
    });
  }
  if (options.privateKeys) {
    options.privateKeys = options.privateKeys.map(function (key) {
      return key.toPacketlist();
    });
  }
  if (options.privateKey) {
    options.privateKey = options.privateKey.toPacketlist();
  }
  if (options.key) {
    options.key = options.key.toPacketlist();
  }
  if (options.message) {
    //could be either a Message or CleartextMessage object
    if (options.message instanceof message.Message) {
      options.message = options.message.packets;
    } else if (options.message instanceof cleartext.CleartextMessage) {
      options.message.signature = options.message.signature.packets;
    }
  }
  if (options.signature &amp;&amp; options.signature instanceof signature.Signature) {
    options.signature = options.signature.packets;
  }
  if (options.signatures) {
    options.signatures = options.signatures.map(function (sig) {
      return verificationObjectToClone(sig);
    });
  }
  return options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.clone.parseClonedPackets" id="apidoc.element.openpgp.packet.clone.parseClonedPackets">
        function <span class="apidocSignatureSpan">openpgp.packet.clone.</span>parseClonedPackets
        <span class="apidocSignatureSpan">(options, method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseClonedPackets(options, method) {
  if (options.publicKeys) {
    options.publicKeys = options.publicKeys.map(packetlistCloneToKey);
  }
  if (options.privateKeys) {
    options.privateKeys = options.privateKeys.map(packetlistCloneToKey);
  }
  if (options.privateKey) {
    options.privateKey = packetlistCloneToKey(options.privateKey);
  }
  if (options.key) {
    options.key = packetlistCloneToKey(options.key);
  }
  if (options.message &amp;&amp; (method === 'sign' || method === 'verify')) {
    // sign and verify support only CleartextMessage
    options.message = packetlistCloneToCleartextMessage(options.message);
  } else if (options.message) {
    options.message = packetlistCloneToMessage(options.message);
  }
  if (options.signatures) {
    options.signatures = options.signatures.map(packetlistCloneToSignatures);
  }
  if (options.signature) {
    options.signature = packetlistCloneToSignature(options.signature);
  }
  return options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.signature" id="apidoc.module.openpgp.signature">module openpgp.signature</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.signature.Signature" id="apidoc.element.openpgp.signature.Signature">
        function <span class="apidocSignatureSpan">openpgp.signature.</span>Signature
        <span class="apidocSignatureSpan">(packetlist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Signature(packetlist) {
  if (!(this instanceof Signature)) {
    return new Signature(packetlist);
  }
  this.packets = packetlist || new _packet2.default.List();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.signature.read" id="apidoc.element.openpgp.signature.read">
        function <span class="apidocSignatureSpan">openpgp.signature.</span>read
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read(input) {
  var packetlist = new _packet2.default.List();
  packetlist.read(input);
  return new Signature(packetlist);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.signature.readArmored" id="apidoc.element.openpgp.signature.readArmored">
        function <span class="apidocSignatureSpan">openpgp.signature.</span>readArmored
        <span class="apidocSignatureSpan">(armoredText)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readArmored(armoredText) {
  var input = _armor2.default.decode(armoredText).data;
  return read(input);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var options, encrypted;

var pubkey = '-----BEGIN PGP PUBLIC KEY BLOCK ... END PGP PUBLIC KEY BLOCK-----';
var privkey = '-----BEGIN PGP PRIVATE KEY BLOCK ... END PGP PRIVATE KEY BLOCK-----'; //encrypted private key
var passphrase = 'secret passphrase'; //what the privKey is encrypted with

var privKeyObj = openpgp.key.<span class="apidocCodeKeywordSpan">readArmored</span>(privkey).keys[0];
privKeyObj.decrypt(passphrase);

options = {
    data: 'Hello, World!',                             // input as String (or Uint8Array)
    publicKeys: openpgp.key.readArmored(pubkey).keys,  // for encryption
    privateKeys: privKeyObj // for signing (optional)
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.signature.Signature" id="apidoc.module.openpgp.signature.Signature">module openpgp.signature.Signature</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.signature.Signature.Signature" id="apidoc.element.openpgp.signature.Signature.Signature">
        function <span class="apidocSignatureSpan">openpgp.signature.</span>Signature
        <span class="apidocSignatureSpan">(packetlist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Signature(packetlist) {
  if (!(this instanceof Signature)) {
    return new Signature(packetlist);
  }
  this.packets = packetlist || new _packet2.default.List();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.signature.Signature.prototype" id="apidoc.module.openpgp.signature.Signature.prototype">module openpgp.signature.Signature.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.signature.Signature.prototype.armor" id="apidoc.element.openpgp.signature.Signature.prototype.armor">
        function <span class="apidocSignatureSpan">openpgp.signature.Signature.prototype.</span>armor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">armor = function () {
  return _armor2.default.encode(_enums2.default.armor.signature, this.packets.write());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.util" id="apidoc.module.openpgp.util">module openpgp.util</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.util.Uint8Array2str" id="apidoc.element.openpgp.util.Uint8Array2str">
        function <span class="apidocSignatureSpan">openpgp.util.</span>Uint8Array2str
        <span class="apidocSignatureSpan">(bin)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Uint8Array2str(bin) {
  if (!Uint8Array.prototype.isPrototypeOf(bin)) {
    throw new Error('Uint8Array2str: Data must be in the form of a Uint8Array');
  }

  var result = [],
      bs = 16384,
      j = bin.length;

  for (var i = 0; i &lt; j; i += bs) {
    result.push(String.fromCharCode.apply(String, bin.subarray(i, i + bs &lt; j ? i + bs : j)));
  }
  return result.join('');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.bin2str" id="apidoc.element.openpgp.util.bin2str">
        function <span class="apidocSignatureSpan">openpgp.util.</span>bin2str
        <span class="apidocSignatureSpan">(bin)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bin2str(bin) {
  var result = [];
  for (var i = 0; i &lt; bin.length; i++) {
    result[i] = String.fromCharCode(bin[i]);
  }
  return result.join('');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.calc_checksum" id="apidoc.element.openpgp.util.calc_checksum">
        function <span class="apidocSignatureSpan">openpgp.util.</span>calc_checksum
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function calc_checksum(text) {
  var checksum = {
    s: 0,
    add: function add(sadd) {
      this.s = (this.s + sadd) % 65536;
    }
  };
  for (var i = 0; i &lt; text.length; i++) {
    checksum.add(text[i]);
  }
  return checksum.s;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.collectBuffers" id="apidoc.element.openpgp.util.collectBuffers">
        function <span class="apidocSignatureSpan">openpgp.util.</span>collectBuffers
        <span class="apidocSignatureSpan">(obj, collection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function collectBuffers(obj, collection) {
  if (!obj) {
    return;
  }
  if (this.isUint8Array(obj) &amp;&amp; collection.indexOf(obj.buffer) === -1) {
    collection.push(obj.buffer);
    return;
  }
  if (Object.prototype.isPrototypeOf(obj)) {
    for (var key in obj) {
      // recursively search all children
      this.collectBuffers(obj[key], collection);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.concatUint8Array" id="apidoc.element.openpgp.util.concatUint8Array">
        function <span class="apidocSignatureSpan">openpgp.util.</span>concatUint8Array
        <span class="apidocSignatureSpan">(arrays)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concatUint8Array(arrays) {
  var totalLength = 0;
  arrays.forEach(function (element) {
    if (!Uint8Array.prototype.isPrototypeOf(element)) {
      throw new Error('concatUint8Array: Data must be in the form of a Uint8Array');
    }

    totalLength += element.length;
  });

  var result = new Uint8Array(totalLength);
  var pos = 0;
  arrays.forEach(function (element) {
    result.set(element, pos);
    pos += element.length;
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.copyUint8Array" id="apidoc.element.openpgp.util.copyUint8Array">
        function <span class="apidocSignatureSpan">openpgp.util.</span>copyUint8Array
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function copyUint8Array(array) {
  if (!Uint8Array.prototype.isPrototypeOf(array)) {
    throw new Error('Data must be in the form of a Uint8Array');
  }

  var copy = new Uint8Array(array.length);
  copy.set(array);
  return copy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.decode_utf8" id="apidoc.element.openpgp.util.decode_utf8">
        function <span class="apidocSignatureSpan">openpgp.util.</span>decode_utf8
        <span class="apidocSignatureSpan">(utf8)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decode_utf8(utf8) {
  if (typeof utf8 !== 'string') {
    throw new Error('Parameter "utf8" is not of type string');
  }
  try {
    return decodeURIComponent(escape(utf8));
  } catch (e) {
    return utf8;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.detectNode" id="apidoc.element.openpgp.util.detectNode">
        function <span class="apidocSignatureSpan">openpgp.util.</span>detectNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function detectNode() {
  return typeof window === 'undefined';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.encode_utf8" id="apidoc.element.openpgp.util.encode_utf8">
        function <span class="apidocSignatureSpan">openpgp.util.</span>encode_utf8
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encode_utf8(str) {
  return unescape(encodeURIComponent(str));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.equalsUint8Array" id="apidoc.element.openpgp.util.equalsUint8Array">
        function <span class="apidocSignatureSpan">openpgp.util.</span>equalsUint8Array
        <span class="apidocSignatureSpan">(array1, array2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function equalsUint8Array(array1, array2) {
  if (!Uint8Array.prototype.isPrototypeOf(array1) || !Uint8Array.prototype.isPrototypeOf(array2)) {
    throw new Error('Data must be in the form of a Uint8Array');
  }

  if (array1.length !== array2.length) {
    return false;
  }

  for (var i = 0; i &lt; array1.length; i++) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.getLeftNBits" id="apidoc.element.openpgp.util.getLeftNBits">
        function <span class="apidocSignatureSpan">openpgp.util.</span>getLeftNBits
        <span class="apidocSignatureSpan">(string, bitcount)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLeftNBits(string, bitcount) {
  var rest = bitcount % 8;
  if (rest === 0) {
    return string.substring(0, bitcount / 8);
  }
  var bytes = (bitcount - rest) / 8 + 1;
  var result = string.substring(0, bytes);
  return this.shiftRight(result, 8 - rest); // +String.fromCharCode(string.charCodeAt(bytes -1) &lt;&lt; (8-rest) &amp; 0xFF);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.getNodeBuffer" id="apidoc.element.openpgp.util.getNodeBuffer">
        function <span class="apidocSignatureSpan">openpgp.util.</span>getNodeBuffer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNodeBuffer() {
  if (!this.detectNode()) {
    return;
  }

  return _dereq_('buffer').Buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.getNodeCrypto" id="apidoc.element.openpgp.util.getNodeCrypto">
        function <span class="apidocSignatureSpan">openpgp.util.</span>getNodeCrypto
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNodeCrypto() {
  if (!this.detectNode() || !_config2.default.use_native) {
    return;
  }

  return _dereq_('crypto');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.getTransferables" id="apidoc.element.openpgp.util.getTransferables">
        function <span class="apidocSignatureSpan">openpgp.util.</span>getTransferables
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTransferables(obj) {
  if (_config2.default.zero_copy &amp;&amp; Object.prototype.isPrototypeOf(obj)) {
    var transferables = [];
    this.collectBuffers(obj, transferables);
    return transferables.length ? transferables : undefined;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.getWebCrypto" id="apidoc.element.openpgp.util.getWebCrypto">
        function <span class="apidocSignatureSpan">openpgp.util.</span>getWebCrypto
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getWebCrypto() {
  if (!_config2.default.use_native) {
    return;
  }

  return typeof window !== 'undefined' &amp;&amp; window.crypto &amp;&amp; window.crypto.subtle;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.getWebCryptoAll" id="apidoc.element.openpgp.util.getWebCryptoAll">
        function <span class="apidocSignatureSpan">openpgp.util.</span>getWebCryptoAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getWebCryptoAll() {
  if (!_config2.default.use_native) {
    return;
  }

  if (typeof window !== 'undefined') {
    if (window.crypto) {
      return window.crypto.subtle || window.crypto.webkitSubtle;
    }
    if (window.msCrypto) {
      return window.msCrypto.subtle;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.get_hashAlgorithmString" id="apidoc.element.openpgp.util.get_hashAlgorithmString">
        function <span class="apidocSignatureSpan">openpgp.util.</span>get_hashAlgorithmString
        <span class="apidocSignatureSpan">(algo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function get_hashAlgorithmString(algo) {
  switch (algo) {
    case 1:
      return "MD5";
    case 2:
      return "SHA1";
    case 3:
      return "RIPEMD160";
    case 8:
      return "SHA256";
    case 9:
      return "SHA384";
    case 10:
      return "SHA512";
    case 11:
      return "SHA224";
  }
  return "unknown";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.hex2bin" id="apidoc.element.openpgp.util.hex2bin">
        function <span class="apidocSignatureSpan">openpgp.util.</span>hex2bin
        <span class="apidocSignatureSpan">(hex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hex2bin(hex) {
  var str = '';
  for (var i = 0; i &lt; hex.length; i += 2) {
    str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
  }
  return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.hexdump" id="apidoc.element.openpgp.util.hexdump">
        function <span class="apidocSignatureSpan">openpgp.util.</span>hexdump
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hexdump(str) {
  var r = [];
  var e = str.length;
  var c = 0;
  var h;
  var i = 0;
  while (c &lt; e) {
    h = str.charCodeAt(c++).toString(16);
    while (h.length &lt; 2) {
      h = "0" + h;
    }
    r.push(" " + h);
    i++;
    if (i % 32 === 0) {
      r.push("\n           ");
    }
  }
  return r.join('');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.hexidump" id="apidoc.element.openpgp.util.hexidump">
        function <span class="apidocSignatureSpan">openpgp.util.</span>hexidump
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hexidump(str) {
  var r = [];
  var e = str.length;
  var c = 0;
  var h;
  while (c &lt; e) {
    h = str[c++].toString(16);
    while (h.length &lt; 2) {
      h = "0" + h;
    }
    r.push("" + h);
  }
  return r.join('');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.hexstrdump" id="apidoc.element.openpgp.util.hexstrdump">
        function <span class="apidocSignatureSpan">openpgp.util.</span>hexstrdump
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hexstrdump(str) {
  if (str === null) {
    return "";
  }
  var r = [];
  var e = str.length;
  var c = 0;
  var h;
  while (c &lt; e) {
    h = str.charCodeAt(c++).toString(16);
    while (h.length &lt; 2) {
      h = "0" + h;
    }
    r.push("" + h);
  }
  return r.join('');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.isArray" id="apidoc.element.openpgp.util.isArray">
        function <span class="apidocSignatureSpan">openpgp.util.</span>isArray
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isArray(data) {
  return Array.prototype.isPrototypeOf(data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.isEmailAddress" id="apidoc.element.openpgp.util.isEmailAddress">
        function <span class="apidocSignatureSpan">openpgp.util.</span>isEmailAddress
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isEmailAddress(data) {
  if (!this.isString(data)) {
    return false;
  }
  var re = /^(([^&lt;&gt;()[\]\\.,;:\s@\"]+(\.[^&lt;&gt;()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([
a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  return re.test(data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.isString" id="apidoc.element.openpgp.util.isString">
        function <span class="apidocSignatureSpan">openpgp.util.</span>isString
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isString(data) {
  return typeof data === 'string' || String.prototype.isPrototypeOf(data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.isUint8Array" id="apidoc.element.openpgp.util.isUint8Array">
        function <span class="apidocSignatureSpan">openpgp.util.</span>isUint8Array
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isUint8Array(data) {
  return Uint8Array.prototype.isPrototypeOf(data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.isUserId" id="apidoc.element.openpgp.util.isUserId">
        function <span class="apidocSignatureSpan">openpgp.util.</span>isUserId
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isUserId(data) {
  if (!this.isString(data)) {
    return false;
  }
  return (/&lt;/.test(data) &amp;&amp; /&gt;$/.test(data)
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.print_debug" id="apidoc.element.openpgp.util.print_debug">
        function <span class="apidocSignatureSpan">openpgp.util.</span>print_debug
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function print_debug(str) {
  if (_config2.default.debug) {
    console.log(str);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.print_debug_hexstr_dump" id="apidoc.element.openpgp.util.print_debug_hexstr_dump">
        function <span class="apidocSignatureSpan">openpgp.util.</span>print_debug_hexstr_dump
        <span class="apidocSignatureSpan">(str, strToHex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function print_debug_hexstr_dump(str, strToHex) {
  if (_config2.default.debug) {
    str = str + this.hexstrdump(strToHex);
    console.log(str);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.promisify" id="apidoc.element.openpgp.util.promisify">
        function <span class="apidocSignatureSpan">openpgp.util.</span>promisify
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function promisify(fn) {
  return function () {
    var args = arguments;
    return new Promise(function (resolve) {
      var result = fn.apply(null, args);
      resolve(result);
    });
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.promisifyIE11Op" id="apidoc.element.openpgp.util.promisifyIE11Op">
        function <span class="apidocSignatureSpan">openpgp.util.</span>promisifyIE11Op
        <span class="apidocSignatureSpan">(cryptoOp, errmsg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function promisifyIE11Op(cryptoOp, errmsg) {
  return new Promise(function (resolve, reject) {
    cryptoOp.onerror = function () {
      reject(new Error(errmsg));
    };
    cryptoOp.oncomplete = function (e) {
      resolve(e.target.result);
    };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.readDate" id="apidoc.element.openpgp.util.readDate">
        function <span class="apidocSignatureSpan">openpgp.util.</span>readDate
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readDate(bytes) {
  var n = this.readNumber(bytes);
  var d = new Date();
  d.setTime(n * 1000);
  return d;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.readNumber" id="apidoc.element.openpgp.util.readNumber">
        function <span class="apidocSignatureSpan">openpgp.util.</span>readNumber
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readNumber(bytes) {
  var n = 0;

  for (var i = 0; i &lt; bytes.length; i++) {
    n &lt;&lt;= 8;
    n += bytes[i];
  }

  return n;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.shiftRight" id="apidoc.element.openpgp.util.shiftRight">
        function <span class="apidocSignatureSpan">openpgp.util.</span>shiftRight
        <span class="apidocSignatureSpan">(value, bitcount)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shiftRight(value, bitcount) {
  var temp = this.str2bin(value);
  if (bitcount % 8 !== 0) {
    for (var i = temp.length - 1; i &gt;= 0; i--) {
      temp[i] &gt;&gt;= bitcount % 8;
      if (i &gt; 0) {
        temp[i] |= temp[i - 1] &lt;&lt; 8 - bitcount % 8 &amp; 0xFF;
      }
    }
  } else {
    return value;
  }
  return this.bin2str(temp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.str2Uint8Array" id="apidoc.element.openpgp.util.str2Uint8Array">
        function <span class="apidocSignatureSpan">openpgp.util.</span>str2Uint8Array
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function str2Uint8Array(str) {
  if (typeof str !== 'string' &amp;&amp; !String.prototype.isPrototypeOf(str)) {
    throw new Error('str2Uint8Array: Data must be in the form of a string');
  }

  var result = new Uint8Array(str.length);
  for (var i = 0; i &lt; str.length; i++) {
    result[i] = str.charCodeAt(i);
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.str2bin" id="apidoc.element.openpgp.util.str2bin">
        function <span class="apidocSignatureSpan">openpgp.util.</span>str2bin
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function str2bin(str) {
  var result = [];
  for (var i = 0; i &lt; str.length; i++) {
    result[i] = str.charCodeAt(i);
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.writeDate" id="apidoc.element.openpgp.util.writeDate">
        function <span class="apidocSignatureSpan">openpgp.util.</span>writeDate
        <span class="apidocSignatureSpan">(time)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeDate(time) {
  var numeric = Math.round(time.getTime() / 1000);

  return this.writeNumber(numeric, 4);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.writeNumber" id="apidoc.element.openpgp.util.writeNumber">
        function <span class="apidocSignatureSpan">openpgp.util.</span>writeNumber
        <span class="apidocSignatureSpan">(n, bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeNumber(n, bytes) {
  var b = new Uint8Array(bytes);
  for (var i = 0; i &lt; bytes; i++) {
    b[i] = n &gt;&gt; 8 * (bytes - i - 1) &amp; 0xFF;
  }

  return b;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>