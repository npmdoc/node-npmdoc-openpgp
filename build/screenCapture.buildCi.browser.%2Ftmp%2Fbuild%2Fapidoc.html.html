<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://openpgpjs.org/">openpgp (v2.5.4)</a>
</h1>
<h4>OpenPGP.js is a Javascript implementation of the OpenPGP protocol. This is defined in RFC 4880.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp">module openpgp</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.AsyncProxy">
            function <span class="apidocSignatureSpan">openpgp.</span>AsyncProxy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.HKP">
            function <span class="apidocSignatureSpan">openpgp.</span>HKP
            <span class="apidocSignatureSpan">(keyServerBaseUrl)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyid">
            function <span class="apidocSignatureSpan">openpgp.</span>Keyid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring">
            function <span class="apidocSignatureSpan">openpgp.</span>Keyring
            <span class="apidocSignatureSpan">(storeHandler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring.localstore">
            function <span class="apidocSignatureSpan">openpgp.</span>Keyring.localstore
            <span class="apidocSignatureSpan">(prefix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.MPI">
            function <span class="apidocSignatureSpan">openpgp.</span>MPI
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.S2K">
            function <span class="apidocSignatureSpan">openpgp.</span>S2K
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.cleartext.CleartextMessage">
            function <span class="apidocSignatureSpan">openpgp.</span>cleartext.CleartextMessage
            <span class="apidocSignatureSpan">(text, signature)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.decrypt">
            function <span class="apidocSignatureSpan">openpgp.</span>decrypt
            <span class="apidocSignatureSpan">(_ref6)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.decryptKey">
            function <span class="apidocSignatureSpan">openpgp.</span>decryptKey
            <span class="apidocSignatureSpan">(_ref4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.decryptSessionKey">
            function <span class="apidocSignatureSpan">openpgp.</span>decryptSessionKey
            <span class="apidocSignatureSpan">(_ref10)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.destroyWorker">
            function <span class="apidocSignatureSpan">openpgp.</span>destroyWorker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.encrypt">
            function <span class="apidocSignatureSpan">openpgp.</span>encrypt
            <span class="apidocSignatureSpan">(_ref5)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.encryptSessionKey">
            function <span class="apidocSignatureSpan">openpgp.</span>encryptSessionKey
            <span class="apidocSignatureSpan">(_ref9)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.generateKey">
            function <span class="apidocSignatureSpan">openpgp.</span>generateKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.getWorker">
            function <span class="apidocSignatureSpan">openpgp.</span>getWorker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.initWorker">
            function <span class="apidocSignatureSpan">openpgp.</span>initWorker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key">
            function <span class="apidocSignatureSpan">openpgp.</span>key.Key
            <span class="apidocSignatureSpan">(packetlist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message">
            function <span class="apidocSignatureSpan">openpgp.</span>message.Message
            <span class="apidocSignatureSpan">(packetlist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Compressed">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.Compressed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.List
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Literal">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.Literal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Marker">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.Marker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.OnePassSignature">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.OnePassSignature
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKey">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.PublicKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.PublicKeyEncryptedSessionKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicSubkey">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.PublicSubkey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretKey">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.SecretKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretSubkey">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.SecretSubkey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Signature">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.Signature
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.SymEncryptedAEADProtected
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.SymEncryptedIntegrityProtected
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.SymEncryptedSessionKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.SymmetricallyEncrypted
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Trust">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.Trust
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.UserAttribute">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.UserAttribute
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Userid">
            function <span class="apidocSignatureSpan">openpgp.</span>packet.Userid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.reformatKey">
            function <span class="apidocSignatureSpan">openpgp.</span>reformatKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.sign">
            function <span class="apidocSignatureSpan">openpgp.</span>sign
            <span class="apidocSignatureSpan">(_ref7)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.signature.Signature">
            function <span class="apidocSignatureSpan">openpgp.</span>signature.Signature
            <span class="apidocSignatureSpan">(packetlist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.verify">
            function <span class="apidocSignatureSpan">openpgp.</span>verify
            <span class="apidocSignatureSpan">(_ref8)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>AsyncProxy.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>HKP.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>Keyid.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>Keyring.localstore.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>Keyring.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>MPI.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>S2K.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>armor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>cleartext</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>cleartext.CleartextMessage.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>crypto</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>crypto.cfb</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>crypto.cipher</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>crypto.gcm</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>crypto.hash</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>crypto.publicKey</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>crypto.random</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>crypto.signature</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>default</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>enums</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>key</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>key.Key.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>message</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>message.Message.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.Compressed.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.List.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.Literal.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.Marker.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.OnePassSignature.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.PublicKey.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.PublicKeyEncryptedSessionKey.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.PublicSubkey.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.SecretKey.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.SecretSubkey.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.Signature.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.SymEncryptedAEADProtected.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.SymEncryptedIntegrityProtected.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.SymEncryptedSessionKey.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.SymmetricallyEncrypted.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.Trust.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.UserAttribute.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.Userid.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>packet.clone</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>signature</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>signature.Signature.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.</span>util</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.AsyncProxy">module openpgp.AsyncProxy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.AsyncProxy.AsyncProxy">
            function <span class="apidocSignatureSpan">openpgp.</span>AsyncProxy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.AsyncProxy.prototype">module openpgp.AsyncProxy.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.AsyncProxy.prototype.delegate">
            function <span class="apidocSignatureSpan">openpgp.AsyncProxy.prototype.</span>delegate
            <span class="apidocSignatureSpan">(method, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.AsyncProxy.prototype.getID">
            function <span class="apidocSignatureSpan">openpgp.AsyncProxy.prototype.</span>getID
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.AsyncProxy.prototype.getRandomBuffer">
            function <span class="apidocSignatureSpan">openpgp.AsyncProxy.prototype.</span>getRandomBuffer
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.AsyncProxy.prototype.onMessage">
            function <span class="apidocSignatureSpan">openpgp.AsyncProxy.prototype.</span>onMessage
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.AsyncProxy.prototype.seedRandom">
            function <span class="apidocSignatureSpan">openpgp.AsyncProxy.prototype.</span>seedRandom
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.AsyncProxy.prototype.terminate">
            function <span class="apidocSignatureSpan">openpgp.AsyncProxy.prototype.</span>terminate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.HKP">module openpgp.HKP</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.HKP.HKP">
            function <span class="apidocSignatureSpan">openpgp.</span>HKP
            <span class="apidocSignatureSpan">(keyServerBaseUrl)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.HKP.prototype">module openpgp.HKP.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.HKP.prototype.lookup">
            function <span class="apidocSignatureSpan">openpgp.HKP.prototype.</span>lookup
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.HKP.prototype.upload">
            function <span class="apidocSignatureSpan">openpgp.HKP.prototype.</span>upload
            <span class="apidocSignatureSpan">(publicKeyArmored)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.Keyid">module openpgp.Keyid</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyid.Keyid">
            function <span class="apidocSignatureSpan">openpgp.</span>Keyid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyid.fromClone">
            function <span class="apidocSignatureSpan">openpgp.Keyid.</span>fromClone
            <span class="apidocSignatureSpan">(clone)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyid.fromId">
            function <span class="apidocSignatureSpan">openpgp.Keyid.</span>fromId
            <span class="apidocSignatureSpan">(hex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyid.mapToHex">
            function <span class="apidocSignatureSpan">openpgp.Keyid.</span>mapToHex
            <span class="apidocSignatureSpan">(keyId)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.Keyid.prototype">module openpgp.Keyid.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyid.prototype.equals">
            function <span class="apidocSignatureSpan">openpgp.Keyid.prototype.</span>equals
            <span class="apidocSignatureSpan">(keyid)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyid.prototype.isNull">
            function <span class="apidocSignatureSpan">openpgp.Keyid.prototype.</span>isNull
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyid.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.Keyid.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyid.prototype.toHex">
            function <span class="apidocSignatureSpan">openpgp.Keyid.prototype.</span>toHex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyid.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.Keyid.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.Keyring">module openpgp.Keyring</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring.Keyring">
            function <span class="apidocSignatureSpan">openpgp.</span>Keyring
            <span class="apidocSignatureSpan">(storeHandler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring.localstore">
            function <span class="apidocSignatureSpan">openpgp.Keyring.</span>localstore
            <span class="apidocSignatureSpan">(prefix)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.Keyring.localstore">module openpgp.Keyring.localstore</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring.localstore.localstore">
            function <span class="apidocSignatureSpan">openpgp.Keyring.</span>localstore
            <span class="apidocSignatureSpan">(prefix)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.Keyring.localstore.prototype">module openpgp.Keyring.localstore.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring.localstore.prototype.loadPrivate">
            function <span class="apidocSignatureSpan">openpgp.Keyring.localstore.prototype.</span>loadPrivate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring.localstore.prototype.loadPublic">
            function <span class="apidocSignatureSpan">openpgp.Keyring.localstore.prototype.</span>loadPublic
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring.localstore.prototype.storePrivate">
            function <span class="apidocSignatureSpan">openpgp.Keyring.localstore.prototype.</span>storePrivate
            <span class="apidocSignatureSpan">(keys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring.localstore.prototype.storePublic">
            function <span class="apidocSignatureSpan">openpgp.Keyring.localstore.prototype.</span>storePublic
            <span class="apidocSignatureSpan">(keys)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">openpgp.Keyring.localstore.prototype.</span>privateKeysItem</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">openpgp.Keyring.localstore.prototype.</span>publicKeysItem</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.Keyring.prototype">module openpgp.Keyring.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring.prototype.clear">
            function <span class="apidocSignatureSpan">openpgp.Keyring.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring.prototype.getAllKeys">
            function <span class="apidocSignatureSpan">openpgp.Keyring.prototype.</span>getAllKeys
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring.prototype.getKeysForId">
            function <span class="apidocSignatureSpan">openpgp.Keyring.prototype.</span>getKeysForId
            <span class="apidocSignatureSpan">(keyId, deep)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring.prototype.removeKeysForId">
            function <span class="apidocSignatureSpan">openpgp.Keyring.prototype.</span>removeKeysForId
            <span class="apidocSignatureSpan">(keyId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.Keyring.prototype.store">
            function <span class="apidocSignatureSpan">openpgp.Keyring.prototype.</span>store
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.MPI">module openpgp.MPI</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.MPI.MPI">
            function <span class="apidocSignatureSpan">openpgp.</span>MPI
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.MPI.fromClone">
            function <span class="apidocSignatureSpan">openpgp.MPI.</span>fromClone
            <span class="apidocSignatureSpan">(clone)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.MPI.prototype">module openpgp.MPI.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.MPI.prototype.byteLength">
            function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>byteLength
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.MPI.prototype.fromBigInteger">
            function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>fromBigInteger
            <span class="apidocSignatureSpan">(bn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.MPI.prototype.fromBytes">
            function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>fromBytes
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.MPI.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.MPI.prototype.toBigInteger">
            function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>toBigInteger
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.MPI.prototype.toBytes">
            function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>toBytes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.MPI.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.S2K">module openpgp.S2K</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.S2K.S2K">
            function <span class="apidocSignatureSpan">openpgp.</span>S2K
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.S2K.fromClone">
            function <span class="apidocSignatureSpan">openpgp.S2K.</span>fromClone
            <span class="apidocSignatureSpan">(clone)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.S2K.prototype">module openpgp.S2K.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.S2K.prototype.get_count">
            function <span class="apidocSignatureSpan">openpgp.S2K.prototype.</span>get_count
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.S2K.prototype.produce_key">
            function <span class="apidocSignatureSpan">openpgp.S2K.prototype.</span>produce_key
            <span class="apidocSignatureSpan">(passphrase, numBytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.S2K.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.S2K.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.S2K.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.S2K.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.armor">module openpgp.armor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.armor.decode">
            function <span class="apidocSignatureSpan">openpgp.armor.</span>decode
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.armor.encode">
            function <span class="apidocSignatureSpan">openpgp.armor.</span>encode
            <span class="apidocSignatureSpan">(messagetype, body, partindex, parttotal)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.cleartext">module openpgp.cleartext</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.cleartext.CleartextMessage">
            function <span class="apidocSignatureSpan">openpgp.cleartext.</span>CleartextMessage
            <span class="apidocSignatureSpan">(text, signature)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.cleartext.readArmored">
            function <span class="apidocSignatureSpan">openpgp.cleartext.</span>readArmored
            <span class="apidocSignatureSpan">(armoredText)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.cleartext.CleartextMessage">module openpgp.cleartext.CleartextMessage</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.cleartext.CleartextMessage.CleartextMessage">
            function <span class="apidocSignatureSpan">openpgp.cleartext.</span>CleartextMessage
            <span class="apidocSignatureSpan">(text, signature)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.cleartext.CleartextMessage.prototype">module openpgp.cleartext.CleartextMessage.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.armor">
            function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>armor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.getSigningKeyIds">
            function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>getSigningKeyIds
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.getText">
            function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>getText
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.sign">
            function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>sign
            <span class="apidocSignatureSpan">(privateKeys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.signDetached">
            function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>signDetached
            <span class="apidocSignatureSpan">(privateKeys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.verify">
            function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>verify
            <span class="apidocSignatureSpan">(keys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.verifyDetached">
            function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>verifyDetached
            <span class="apidocSignatureSpan">(signature, keys)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.crypto">module openpgp.crypto</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.generateMpi">
            function <span class="apidocSignatureSpan">openpgp.crypto.</span>generateMpi
            <span class="apidocSignatureSpan">(algo, bits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.generateSessionKey">
            function <span class="apidocSignatureSpan">openpgp.crypto.</span>generateSessionKey
            <span class="apidocSignatureSpan">(algo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.getPrefixRandom">
            function <span class="apidocSignatureSpan">openpgp.crypto.</span>getPrefixRandom
            <span class="apidocSignatureSpan">(algo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.getPrivateMpiCount">
            function <span class="apidocSignatureSpan">openpgp.crypto.</span>getPrivateMpiCount
            <span class="apidocSignatureSpan">(algo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.getPublicMpiCount">
            function <span class="apidocSignatureSpan">openpgp.crypto.</span>getPublicMpiCount
            <span class="apidocSignatureSpan">(algo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.publicKeyDecrypt">
            function <span class="apidocSignatureSpan">openpgp.crypto.</span>publicKeyDecrypt
            <span class="apidocSignatureSpan">(algo, keyIntegers, dataIntegers)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.publicKeyEncrypt">
            function <span class="apidocSignatureSpan">openpgp.crypto.</span>publicKeyEncrypt
            <span class="apidocSignatureSpan">(algo, publicMPIs, data)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.crypto.</span>cfb</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.crypto.</span>cipher</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.crypto.</span>gcm</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.crypto.</span>hash</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.crypto.</span>pkcs1</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.crypto.</span>publicKey</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.crypto.</span>random</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.crypto.</span>signature</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.crypto.cfb">module openpgp.crypto.cfb</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cfb.decrypt">
            function <span class="apidocSignatureSpan">openpgp.crypto.cfb.</span>decrypt
            <span class="apidocSignatureSpan">(cipherfn, key, ciphertext, resync)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cfb.encrypt">
            function <span class="apidocSignatureSpan">openpgp.crypto.cfb.</span>encrypt
            <span class="apidocSignatureSpan">(prefixrandom, cipherfn, plaintext, key, resync)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cfb.mdc">
            function <span class="apidocSignatureSpan">openpgp.crypto.cfb.</span>mdc
            <span class="apidocSignatureSpan">(cipherfn, key, ciphertext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cfb.normalDecrypt">
            function <span class="apidocSignatureSpan">openpgp.crypto.cfb.</span>normalDecrypt
            <span class="apidocSignatureSpan">(cipherfn, key, ciphertext, iv)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cfb.normalEncrypt">
            function <span class="apidocSignatureSpan">openpgp.crypto.cfb.</span>normalEncrypt
            <span class="apidocSignatureSpan">(cipherfn, key, plaintext, iv)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.crypto.cipher">module openpgp.crypto.cipher</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cipher.aes128">
            function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>aes128
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cipher.aes192">
            function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>aes192
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cipher.aes256">
            function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>aes256
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cipher.blowfish">
            function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>blowfish
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cipher.cast5">
            function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>cast5
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cipher.des">
            function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>des
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cipher.idea">
            function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>idea
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cipher.tripledes">
            function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>tripledes
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.cipher.twofish">
            function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>twofish
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.crypto.gcm">module openpgp.crypto.gcm</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.gcm.decrypt">
            function <span class="apidocSignatureSpan">openpgp.crypto.gcm.</span>decrypt
            <span class="apidocSignatureSpan">(cipher, ciphertext, key, iv)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.gcm.encrypt">
            function <span class="apidocSignatureSpan">openpgp.crypto.gcm.</span>encrypt
            <span class="apidocSignatureSpan">(cipher, plaintext, key, iv)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">openpgp.crypto.gcm.</span>ivLength</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.crypto.hash">module openpgp.crypto.hash</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.hash.digest">
            function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>digest
            <span class="apidocSignatureSpan">(algo, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.hash.getHashByteLength">
            function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>getHashByteLength
            <span class="apidocSignatureSpan">(algo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.hash.md5">
            function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>md5
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.hash.ripemd">
            function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>ripemd
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.hash.sha1">
            function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>sha1
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.hash.sha224">
            function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>sha224
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.hash.sha256">
            function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>sha256
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.hash.sha384">
            function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>sha384
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.hash.sha512">
            function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>sha512
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.crypto.publicKey">module openpgp.crypto.publicKey</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.publicKey.dsa">
            function <span class="apidocSignatureSpan">openpgp.crypto.publicKey.</span>dsa
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.publicKey.elgamal">
            function <span class="apidocSignatureSpan">openpgp.crypto.publicKey.</span>elgamal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.publicKey.rsa">
            function <span class="apidocSignatureSpan">openpgp.crypto.publicKey.</span>rsa
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.crypto.random">module openpgp.crypto.random</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.random.getRandomBigInteger">
            function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getRandomBigInteger
            <span class="apidocSignatureSpan">(bits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.random.getRandomBigIntegerInRange">
            function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getRandomBigIntegerInRange
            <span class="apidocSignatureSpan">(min, max)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.random.getRandomBytes">
            function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getRandomBytes
            <span class="apidocSignatureSpan">(length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.random.getRandomValues">
            function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getRandomValues
            <span class="apidocSignatureSpan">(buf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.random.getSecureRandom">
            function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getSecureRandom
            <span class="apidocSignatureSpan">(from, to)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.random.getSecureRandomOctet">
            function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getSecureRandomOctet
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.random.getSecureRandomUint">
            function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getSecureRandomUint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.crypto.random.</span>randomBuffer</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.crypto.signature">module openpgp.crypto.signature</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.signature.sign">
            function <span class="apidocSignatureSpan">openpgp.crypto.signature.</span>sign
            <span class="apidocSignatureSpan">(hash_algo, algo, keyIntegers, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.crypto.signature.verify">
            function <span class="apidocSignatureSpan">openpgp.crypto.signature.</span>verify
            <span class="apidocSignatureSpan">(algo, hash_algo, msg_MPIs, publickey_MPIs, data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.default">module openpgp.default</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.default.decrypt">
            function <span class="apidocSignatureSpan">openpgp.default.</span>decrypt
            <span class="apidocSignatureSpan">(_ref6)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.default.decryptKey">
            function <span class="apidocSignatureSpan">openpgp.default.</span>decryptKey
            <span class="apidocSignatureSpan">(_ref4)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.default.decryptSessionKey">
            function <span class="apidocSignatureSpan">openpgp.default.</span>decryptSessionKey
            <span class="apidocSignatureSpan">(_ref10)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.default.destroyWorker">
            function <span class="apidocSignatureSpan">openpgp.default.</span>destroyWorker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.default.encrypt">
            function <span class="apidocSignatureSpan">openpgp.default.</span>encrypt
            <span class="apidocSignatureSpan">(_ref5)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.default.encryptSessionKey">
            function <span class="apidocSignatureSpan">openpgp.default.</span>encryptSessionKey
            <span class="apidocSignatureSpan">(_ref9)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.default.generateKey">
            function <span class="apidocSignatureSpan">openpgp.default.</span>generateKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.default.getWorker">
            function <span class="apidocSignatureSpan">openpgp.default.</span>getWorker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.default.initWorker">
            function <span class="apidocSignatureSpan">openpgp.default.</span>initWorker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.default.reformatKey">
            function <span class="apidocSignatureSpan">openpgp.default.</span>reformatKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.default.sign">
            function <span class="apidocSignatureSpan">openpgp.default.</span>sign
            <span class="apidocSignatureSpan">(_ref7)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.default.verify">
            function <span class="apidocSignatureSpan">openpgp.default.</span>verify
            <span class="apidocSignatureSpan">(_ref8)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.enums">module openpgp.enums</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.enums.read">
            function <span class="apidocSignatureSpan">openpgp.enums.</span>read
            <span class="apidocSignatureSpan">(type, e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.enums.write">
            function <span class="apidocSignatureSpan">openpgp.enums.</span>write
            <span class="apidocSignatureSpan">(type, e)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.enums.</span>armor</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.enums.</span>compression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.enums.</span>hash</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.enums.</span>keyFlags</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.enums.</span>keyStatus</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.enums.</span>literal</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.enums.</span>packet</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.enums.</span>publicKey</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.enums.</span>s2k</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.enums.</span>signature</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.enums.</span>signatureSubpacket</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.enums.</span>symmetric</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.key">module openpgp.key</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key">
            function <span class="apidocSignatureSpan">openpgp.key.</span>Key
            <span class="apidocSignatureSpan">(packetlist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.generate">
            function <span class="apidocSignatureSpan">openpgp.key.</span>generate
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.getPreferredSymAlgo">
            function <span class="apidocSignatureSpan">openpgp.key.</span>getPreferredSymAlgo
            <span class="apidocSignatureSpan">(keys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.readArmored">
            function <span class="apidocSignatureSpan">openpgp.key.</span>readArmored
            <span class="apidocSignatureSpan">(armoredText)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.reformat">
            function <span class="apidocSignatureSpan">openpgp.key.</span>reformat
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.key.Key">module openpgp.key.Key</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.Key">
            function <span class="apidocSignatureSpan">openpgp.key.</span>Key
            <span class="apidocSignatureSpan">(packetlist)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.key.Key.prototype">module openpgp.key.Key.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.armor">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>armor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.decrypt">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(passphrase)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.decryptKeyPacket">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>decryptKeyPacket
            <span class="apidocSignatureSpan">(keyIds, passphrase)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.encrypt">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(passphrase)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.getAllKeyPackets">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getAllKeyPackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.getEncryptionKeyPacket">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getEncryptionKeyPacket
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.getExpirationTime">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getExpirationTime
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.getKeyIds">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getKeyIds
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.getKeyPacket">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getKeyPacket
            <span class="apidocSignatureSpan">(keyIds)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.getPreferredHashAlgorithm">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getPreferredHashAlgorithm
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.getPrimaryUser">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getPrimaryUser
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.getSigningKeyPacket">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getSigningKeyPacket
            <span class="apidocSignatureSpan">(keyId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.getSubkeyPackets">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getSubkeyPackets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.getUserIds">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getUserIds
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.isPrivate">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>isPrivate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.isPublic">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>isPublic
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.packetlist2structure">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>packetlist2structure
            <span class="apidocSignatureSpan">(packetlist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.revoke">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>revoke
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.signAllUsers">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>signAllUsers
            <span class="apidocSignatureSpan">(privateKeys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.signPrimaryUser">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>signPrimaryUser
            <span class="apidocSignatureSpan">(privateKeys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.toPacketlist">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>toPacketlist
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.toPublic">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>toPublic
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.update">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>update
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.verifyAllUsers">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>verifyAllUsers
            <span class="apidocSignatureSpan">(keys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.verifyPrimaryKey">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>verifyPrimaryKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.key.Key.prototype.verifyPrimaryUser">
            function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>verifyPrimaryUser
            <span class="apidocSignatureSpan">(keys)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.message">module openpgp.message</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message">
            function <span class="apidocSignatureSpan">openpgp.message.</span>Message
            <span class="apidocSignatureSpan">(packetlist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.encryptSessionKey">
            function <span class="apidocSignatureSpan">openpgp.message.</span>encryptSessionKey
            <span class="apidocSignatureSpan">(sessionKey, symAlgo, publicKeys, passwords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.fromBinary">
            function <span class="apidocSignatureSpan">openpgp.message.</span>fromBinary
            <span class="apidocSignatureSpan">(bytes, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.fromText">
            function <span class="apidocSignatureSpan">openpgp.message.</span>fromText
            <span class="apidocSignatureSpan">(text, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.read">
            function <span class="apidocSignatureSpan">openpgp.message.</span>read
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.readArmored">
            function <span class="apidocSignatureSpan">openpgp.message.</span>readArmored
            <span class="apidocSignatureSpan">(armoredText)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.readSignedContent">
            function <span class="apidocSignatureSpan">openpgp.message.</span>readSignedContent
            <span class="apidocSignatureSpan">(content, detachedSignature)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.message.Message">module openpgp.message.Message</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.Message">
            function <span class="apidocSignatureSpan">openpgp.message.</span>Message
            <span class="apidocSignatureSpan">(packetlist)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.message.Message.prototype">module openpgp.message.Message.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.armor">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>armor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.decrypt">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(privateKey, sessionKey, password)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.decryptSessionKey">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>decryptSessionKey
            <span class="apidocSignatureSpan">(privateKey, password)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.encrypt">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(keys, passwords)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.getEncryptionKeyIds">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>getEncryptionKeyIds
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.getFilename">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>getFilename
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.getLiteralData">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>getLiteralData
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.getSigningKeyIds">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>getSigningKeyIds
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.getText">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>getText
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.sign">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>sign
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.signDetached">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>signDetached
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.unwrapCompressed">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>unwrapCompressed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.verify">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>verify
            <span class="apidocSignatureSpan">(keys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.message.Message.prototype.verifyDetached">
            function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>verifyDetached
            <span class="apidocSignatureSpan">(signature, keys)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet">module openpgp.packet</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Compressed">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>Compressed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>List
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Literal">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>Literal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Marker">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>Marker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.OnePassSignature">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>OnePassSignature
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKey">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>PublicKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>PublicKeyEncryptedSessionKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicSubkey">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>PublicSubkey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretKey">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>SecretKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretSubkey">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>SecretSubkey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Signature">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>Signature
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>SymEncryptedAEADProtected
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>SymEncryptedIntegrityProtected
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>SymEncryptedSessionKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>SymmetricallyEncrypted
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Trust">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>Trust
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.UserAttribute">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>UserAttribute
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Userid">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>Userid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.fromStructuredClone">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>fromStructuredClone
            <span class="apidocSignatureSpan">(packetClone)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.newPacketFromTag">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>newPacketFromTag
            <span class="apidocSignatureSpan">(tag)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.</span>clone</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.Compressed">module openpgp.packet.Compressed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Compressed.Compressed">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>Compressed
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.Compressed.prototype">module openpgp.packet.Compressed.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Compressed.prototype.compress">
            function <span class="apidocSignatureSpan">openpgp.packet.Compressed.prototype.</span>compress
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Compressed.prototype.decompress">
            function <span class="apidocSignatureSpan">openpgp.packet.Compressed.prototype.</span>decompress
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Compressed.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.Compressed.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Compressed.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.Compressed.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.List">module openpgp.packet.List</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List.List">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>List
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List.fromStructuredClone">
            function <span class="apidocSignatureSpan">openpgp.packet.List.</span>fromStructuredClone
            <span class="apidocSignatureSpan">(packetlistClone)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.List.prototype">module openpgp.packet.List.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List.prototype.concat">
            function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>concat
            <span class="apidocSignatureSpan">(packetlist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List.prototype.filter">
            function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>filter
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List.prototype.filterByTag">
            function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>filterByTag
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List.prototype.findPacket">
            function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>findPacket
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List.prototype.forEach">
            function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>forEach
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List.prototype.indexOfTag">
            function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>indexOfTag
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List.prototype.pop">
            function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>pop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List.prototype.push">
            function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>push
            <span class="apidocSignatureSpan">(packet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List.prototype.slice">
            function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>slice
            <span class="apidocSignatureSpan">(begin, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.List.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.Literal">module openpgp.packet.Literal</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Literal.Literal">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>Literal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.Literal.prototype">module openpgp.packet.Literal.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Literal.prototype.getBytes">
            function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>getBytes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Literal.prototype.getFilename">
            function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>getFilename
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Literal.prototype.getText">
            function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>getText
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Literal.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Literal.prototype.setBytes">
            function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>setBytes
            <span class="apidocSignatureSpan">(bytes, format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Literal.prototype.setFilename">
            function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>setFilename
            <span class="apidocSignatureSpan">(filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Literal.prototype.setText">
            function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>setText
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Literal.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.Marker">module openpgp.packet.Marker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Marker.Marker">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>Marker
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.Marker.prototype">module openpgp.packet.Marker.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Marker.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.Marker.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.OnePassSignature">module openpgp.packet.OnePassSignature</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.OnePassSignature.OnePassSignature">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>OnePassSignature
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.OnePassSignature.prototype">module openpgp.packet.OnePassSignature.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.OnePassSignature.prototype.postCloneTypeFix">
            function <span class="apidocSignatureSpan">openpgp.packet.OnePassSignature.prototype.</span>postCloneTypeFix
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.OnePassSignature.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.OnePassSignature.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.OnePassSignature.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.OnePassSignature.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.PublicKey">module openpgp.packet.PublicKey</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKey.PublicKey">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>PublicKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.PublicKey.prototype">module openpgp.packet.PublicKey.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKey.prototype.getBitSize">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>getBitSize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKey.prototype.getFingerprint">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>getFingerprint
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKey.prototype.getKeyId">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>getKeyId
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKey.prototype.postCloneTypeFix">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>postCloneTypeFix
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKey.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKey.prototype.readPublicKey">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>readPublicKey
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKey.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKey.prototype.writeOld">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>writeOld
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKey.prototype.writePublicKey">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>writePublicKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.PublicKeyEncryptedSessionKey">module openpgp.packet.PublicKeyEncryptedSessionKey</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.PublicKeyEncryptedSessionKey">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>PublicKeyEncryptedSessionKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.PublicKeyEncryptedSessionKey.prototype">module openpgp.packet.PublicKeyEncryptedSessionKey.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.decrypt">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKeyEncryptedSessionKey.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.encrypt">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKeyEncryptedSessionKey.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.postCloneTypeFix">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKeyEncryptedSessionKey.prototype.</span>postCloneTypeFix
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKeyEncryptedSessionKey.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicKeyEncryptedSessionKey.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.PublicSubkey">module openpgp.packet.PublicSubkey</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicSubkey.PublicSubkey">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>PublicSubkey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.PublicSubkey.prototype">module openpgp.packet.PublicSubkey.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.PublicSubkey.prototype.constructor">
            function <span class="apidocSignatureSpan">openpgp.packet.PublicSubkey.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">openpgp.packet.PublicSubkey.prototype.</span>expirationTimeV3</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">openpgp.packet.PublicSubkey.prototype.</span>tag</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">openpgp.packet.PublicSubkey.prototype.</span>version</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.PublicSubkey.prototype.</span>created</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.PublicSubkey.prototype.</span>fingerprint</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.PublicSubkey.prototype.</span>keyid</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.PublicSubkey.prototype.</span>mpi</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">openpgp.packet.PublicSubkey.prototype.</span>algorithm</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.SecretKey">module openpgp.packet.SecretKey</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretKey.SecretKey">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>SecretKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.SecretKey.prototype">module openpgp.packet.SecretKey.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretKey.prototype.clearPrivateMPIs">
            function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>clearPrivateMPIs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretKey.prototype.constructor">
            function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretKey.prototype.decrypt">
            function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(passphrase)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretKey.prototype.encrypt">
            function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(passphrase)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretKey.prototype.generate">
            function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>generate
            <span class="apidocSignatureSpan">(bits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretKey.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretKey.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>expirationTimeV3</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>tag</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>version</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>created</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>fingerprint</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>keyid</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>mpi</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>algorithm</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.SecretSubkey">module openpgp.packet.SecretSubkey</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretSubkey.SecretSubkey">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>SecretSubkey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.SecretSubkey.prototype">module openpgp.packet.SecretSubkey.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">openpgp.packet.SecretSubkey.prototype.</span>isDecrypted</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SecretSubkey.prototype.constructor">
            function <span class="apidocSignatureSpan">openpgp.packet.SecretSubkey.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">openpgp.packet.SecretSubkey.prototype.</span>expirationTimeV3</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">openpgp.packet.SecretSubkey.prototype.</span>tag</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">openpgp.packet.SecretSubkey.prototype.</span>version</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.SecretSubkey.prototype.</span>created</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.SecretSubkey.prototype.</span>encrypted</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.SecretSubkey.prototype.</span>fingerprint</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.SecretSubkey.prototype.</span>keyid</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">openpgp.packet.SecretSubkey.prototype.</span>mpi</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">openpgp.packet.SecretSubkey.prototype.</span>algorithm</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.Signature">module openpgp.packet.Signature</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Signature.Signature">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>Signature
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.Signature.prototype">module openpgp.packet.Signature.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Signature.prototype.calculateTrailer">
            function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>calculateTrailer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Signature.prototype.isExpired">
            function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>isExpired
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Signature.prototype.postCloneTypeFix">
            function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>postCloneTypeFix
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Signature.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Signature.prototype.read_sub_packet">
            function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>read_sub_packet
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Signature.prototype.sign">
            function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>sign
            <span class="apidocSignatureSpan">(key, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Signature.prototype.toSign">
            function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>toSign
            <span class="apidocSignatureSpan">(type, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Signature.prototype.verify">
            function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>verify
            <span class="apidocSignatureSpan">(key, data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Signature.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Signature.prototype.write_all_sub_packets">
            function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>write_all_sub_packets
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.SymEncryptedAEADProtected">module openpgp.packet.SymEncryptedAEADProtected</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected.SymEncryptedAEADProtected">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>SymEncryptedAEADProtected
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.SymEncryptedAEADProtected.prototype">module openpgp.packet.SymEncryptedAEADProtected.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected.prototype.decrypt">
            function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedAEADProtected.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(sessionKeyAlgorithm, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected.prototype.encrypt">
            function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedAEADProtected.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(sessionKeyAlgorithm, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedAEADProtected.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedAEADProtected.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.SymEncryptedIntegrityProtected">module openpgp.packet.SymEncryptedIntegrityProtected</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.SymEncryptedIntegrityProtected">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>SymEncryptedIntegrityProtected
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.SymEncryptedIntegrityProtected.prototype">module openpgp.packet.SymEncryptedIntegrityProtected.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.prototype.decrypt">
            function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedIntegrityProtected.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(sessionKeyAlgorithm, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.prototype.encrypt">
            function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedIntegrityProtected.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(sessionKeyAlgorithm, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedIntegrityProtected.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedIntegrityProtected.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.SymEncryptedSessionKey">module openpgp.packet.SymEncryptedSessionKey</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey.SymEncryptedSessionKey">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>SymEncryptedSessionKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.SymEncryptedSessionKey.prototype">module openpgp.packet.SymEncryptedSessionKey.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.decrypt">
            function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedSessionKey.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(passphrase)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.encrypt">
            function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedSessionKey.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(passphrase)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.postCloneTypeFix">
            function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedSessionKey.prototype.</span>postCloneTypeFix
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedSessionKey.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedSessionKey.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.SymmetricallyEncrypted">module openpgp.packet.SymmetricallyEncrypted</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted.SymmetricallyEncrypted">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>SymmetricallyEncrypted
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.SymmetricallyEncrypted.prototype">module openpgp.packet.SymmetricallyEncrypted.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted.prototype.decrypt">
            function <span class="apidocSignatureSpan">openpgp.packet.SymmetricallyEncrypted.prototype.</span>decrypt
            <span class="apidocSignatureSpan">(sessionKeyAlgorithm, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted.prototype.encrypt">
            function <span class="apidocSignatureSpan">openpgp.packet.SymmetricallyEncrypted.prototype.</span>encrypt
            <span class="apidocSignatureSpan">(algo, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.SymmetricallyEncrypted.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.SymmetricallyEncrypted.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.Trust">module openpgp.packet.Trust</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Trust.Trust">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>Trust
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.Trust.prototype">module openpgp.packet.Trust.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Trust.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.Trust.prototype.</span>read
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.UserAttribute">module openpgp.packet.UserAttribute</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.UserAttribute.UserAttribute">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>UserAttribute
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.UserAttribute.prototype">module openpgp.packet.UserAttribute.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.UserAttribute.prototype.equals">
            function <span class="apidocSignatureSpan">openpgp.packet.UserAttribute.prototype.</span>equals
            <span class="apidocSignatureSpan">(usrAttr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.UserAttribute.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.UserAttribute.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.UserAttribute.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.UserAttribute.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.Userid">module openpgp.packet.Userid</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Userid.Userid">
            function <span class="apidocSignatureSpan">openpgp.packet.</span>Userid
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.Userid.prototype">module openpgp.packet.Userid.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Userid.prototype.read">
            function <span class="apidocSignatureSpan">openpgp.packet.Userid.prototype.</span>read
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.Userid.prototype.write">
            function <span class="apidocSignatureSpan">openpgp.packet.Userid.prototype.</span>write
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.packet.clone">module openpgp.packet.clone</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.clone.clonePackets">
            function <span class="apidocSignatureSpan">openpgp.packet.clone.</span>clonePackets
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.packet.clone.parseClonedPackets">
            function <span class="apidocSignatureSpan">openpgp.packet.clone.</span>parseClonedPackets
            <span class="apidocSignatureSpan">(options, method)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.signature">module openpgp.signature</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.signature.Signature">
            function <span class="apidocSignatureSpan">openpgp.signature.</span>Signature
            <span class="apidocSignatureSpan">(packetlist)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.signature.read">
            function <span class="apidocSignatureSpan">openpgp.signature.</span>read
            <span class="apidocSignatureSpan">(input)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.signature.readArmored">
            function <span class="apidocSignatureSpan">openpgp.signature.</span>readArmored
            <span class="apidocSignatureSpan">(armoredText)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.signature.Signature">module openpgp.signature.Signature</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.signature.Signature.Signature">
            function <span class="apidocSignatureSpan">openpgp.signature.</span>Signature
            <span class="apidocSignatureSpan">(packetlist)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.signature.Signature.prototype">module openpgp.signature.Signature.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.signature.Signature.prototype.armor">
            function <span class="apidocSignatureSpan">openpgp.signature.Signature.prototype.</span>armor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.openpgp.util">module openpgp.util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.Uint8Array2str">
            function <span class="apidocSignatureSpan">openpgp.util.</span>Uint8Array2str
            <span class="apidocSignatureSpan">(bin)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.bin2str">
            function <span class="apidocSignatureSpan">openpgp.util.</span>bin2str
            <span class="apidocSignatureSpan">(bin)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.calc_checksum">
            function <span class="apidocSignatureSpan">openpgp.util.</span>calc_checksum
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.collectBuffers">
            function <span class="apidocSignatureSpan">openpgp.util.</span>collectBuffers
            <span class="apidocSignatureSpan">(obj, collection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.concatUint8Array">
            function <span class="apidocSignatureSpan">openpgp.util.</span>concatUint8Array
            <span class="apidocSignatureSpan">(arrays)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.copyUint8Array">
            function <span class="apidocSignatureSpan">openpgp.util.</span>copyUint8Array
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.decode_utf8">
            function <span class="apidocSignatureSpan">openpgp.util.</span>decode_utf8
            <span class="apidocSignatureSpan">(utf8)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.detectNode">
            function <span class="apidocSignatureSpan">openpgp.util.</span>detectNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.encode_utf8">
            function <span class="apidocSignatureSpan">openpgp.util.</span>encode_utf8
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.equalsUint8Array">
            function <span class="apidocSignatureSpan">openpgp.util.</span>equalsUint8Array
            <span class="apidocSignatureSpan">(array1, array2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.getLeftNBits">
            function <span class="apidocSignatureSpan">openpgp.util.</span>getLeftNBits
            <span class="apidocSignatureSpan">(string, bitcount)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.getNodeBuffer">
            function <span class="apidocSignatureSpan">openpgp.util.</span>getNodeBuffer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.getNodeCrypto">
            function <span class="apidocSignatureSpan">openpgp.util.</span>getNodeCrypto
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.getTransferables">
            function <span class="apidocSignatureSpan">openpgp.util.</span>getTransferables
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.getWebCrypto">
            function <span class="apidocSignatureSpan">openpgp.util.</span>getWebCrypto
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.getWebCryptoAll">
            function <span class="apidocSignatureSpan">openpgp.util.</span>getWebCryptoAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.get_hashAlgorithmString">
            function <span class="apidocSignatureSpan">openpgp.util.</span>get_hashAlgorithmString
            <span class="apidocSignatureSpan">(algo)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.hex2bin">
            function <span class="apidocSignatureSpan">openpgp.util.</span>hex2bin
            <span class="apidocSignatureSpan">(hex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.hexdump">
            function <span class="apidocSignatureSpan">openpgp.util.</span>hexdump
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.hexidump">
            function <span class="apidocSignatureSpan">openpgp.util.</span>hexidump
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.hexstrdump">
            function <span class="apidocSignatureSpan">openpgp.util.</span>hexstrdump
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.isArray">
            function <span class="apidocSignatureSpan">openpgp.util.</span>isArray
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.isEmailAddress">
            function <span class="apidocSignatureSpan">openpgp.util.</span>isEmailAddress
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.isString">
            function <span class="apidocSignatureSpan">openpgp.util.</span>isString
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.isUint8Array">
            function <span class="apidocSignatureSpan">openpgp.util.</span>isUint8Array
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.isUserId">
            function <span class="apidocSignatureSpan">openpgp.util.</span>isUserId
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.print_debug">
            function <span class="apidocSignatureSpan">openpgp.util.</span>print_debug
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.print_debug_hexstr_dump">
            function <span class="apidocSignatureSpan">openpgp.util.</span>print_debug_hexstr_dump
            <span class="apidocSignatureSpan">(str, strToHex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.promisify">
            function <span class="apidocSignatureSpan">openpgp.util.</span>promisify
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.promisifyIE11Op">
            function <span class="apidocSignatureSpan">openpgp.util.</span>promisifyIE11Op
            <span class="apidocSignatureSpan">(cryptoOp, errmsg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.readDate">
            function <span class="apidocSignatureSpan">openpgp.util.</span>readDate
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.readNumber">
            function <span class="apidocSignatureSpan">openpgp.util.</span>readNumber
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.shiftRight">
            function <span class="apidocSignatureSpan">openpgp.util.</span>shiftRight
            <span class="apidocSignatureSpan">(value, bitcount)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.str2Uint8Array">
            function <span class="apidocSignatureSpan">openpgp.util.</span>str2Uint8Array
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.str2bin">
            function <span class="apidocSignatureSpan">openpgp.util.</span>str2bin
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.writeDate">
            function <span class="apidocSignatureSpan">openpgp.util.</span>writeDate
            <span class="apidocSignatureSpan">(time)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.openpgp.util.writeNumber">
            function <span class="apidocSignatureSpan">openpgp.util.</span>writeNumber
            <span class="apidocSignatureSpan">(n, bytes)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp" id="apidoc.module.openpgp">module openpgp</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.AsyncProxy" id="apidoc.element.openpgp.AsyncProxy">
        function <span class="apidocSignatureSpan">openpgp.</span>AsyncProxy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AsyncProxy() {
  var _ref = arguments.length &lt;= 0 || arguments[0] === undefined ? {} : arguments[0];

  var _ref$path = _ref.path;
  var path = _ref$path === undefined ? 'openpgp.worker.js' : _ref$path;
  var worker = _ref.worker;
  var config = _ref.config;

  this.worker = worker || new Worker(path);
  this.worker.onmessage = this.onMessage.bind(this);
  this.worker.onerror = function (e) {
    throw new Error('Unhandled error in openpgp worker: ' + e.message + ' (' + e.filename + ':' + e.lineno + ')');
  };
  this.seedRandom(INITIAL_RANDOM_SEED);

  if (config) {
    this.worker.postMessage({ event: 'configure', config: config });
  }

  // Cannot rely on task order being maintained, use object keyed by request ID to track tasks
  this.tasks = {};
  this.currentID = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.HKP" id="apidoc.element.openpgp.HKP">
        function <span class="apidocSignatureSpan">openpgp.</span>HKP
        <span class="apidocSignatureSpan">(keyServerBaseUrl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HKP(keyServerBaseUrl) {
  this._baseUrl = keyServerBaseUrl ? keyServerBaseUrl : _config2.default.keyserver;
  this._fetch = typeof window !== 'undefined' ? window.fetch : _dereq_('node-fetch');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var pubkey = key.publicKeyArmored;   // '-----BEGIN PGP PUBLIC KEY BLOCK ... '
});
```

#### Lookup public key on HKP server

```js
var hkp = new openpgp.<span class="apidocCodeKeywordSpan">HKP</span>('https://pgp.mit.edu');

var options = {
query: 'alice@example.com'
};

hkp.lookup(options).then(function(key) {
var pubkey = openpgp.key.readArmored(key);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyid" id="apidoc.element.openpgp.Keyid">
        function <span class="apidocSignatureSpan">openpgp.</span>Keyid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Keyid() {
  this.bytes = '';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyring" id="apidoc.element.openpgp.Keyring">
        function <span class="apidocSignatureSpan">openpgp.</span>Keyring
        <span class="apidocSignatureSpan">(storeHandler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Keyring(storeHandler) {
  this.storeHandler = storeHandler || new _localstore2.default();
  this.publicKeys = new KeyArray(this.storeHandler.loadPublic());
  this.privateKeys = new KeyArray(this.storeHandler.loadPrivate());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...



'use strict';

var openpgp = typeof window != 'undefined' &amp;&amp; window.openpgp ? window.openpgp : require('../../dist/openpgp
');

var keyring = new openpgp.<span class="apidocCodeKeywordSpan">Keyring</span>(),
chai = require('chai'),
expect = chai.expect;

describe("Keyring", function() {
var user = 'whiteout.test@t-online.de',
  passphrase = 'asdf',
  keySize = 512,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyring.localstore" id="apidoc.element.openpgp.Keyring.localstore">
        function <span class="apidocSignatureSpan">openpgp.</span>Keyring.localstore
        <span class="apidocSignatureSpan">(prefix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LocalStore(prefix) {
  prefix = prefix || 'openpgp-';
  this.publicKeysItem = prefix + this.publicKeysItem;
  this.privateKeysItem = prefix + this.privateKeysItem;
  if (typeof window !== 'undefined' &amp;&amp; window.localStorage) {
    this.storage = window.localStorage;
  } else {
    this.storage = new (_dereq_('node-localstorage').LocalStorage)(_config2.default.node_store);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var key = keyring.publicKeys.removeForId(keyFingerP2);
  expect(key).to.exist.and.be.an.instanceof(openpgp.key.Key);
  expect(key.primaryKey.getKeyId().toHex()).equals(keyId2);
  expect(keyring.publicKeys.keys).to.be.empty;
});

it('customize localstorage itemname', function() {
  var localstore1 = new openpgp.<span class="apidocCodeKeywordSpan">Keyring.localstore</span>('my-custom-prefix-');
  var localstore2 = new openpgp.Keyring.localstore('my-custom-prefix-');
  var localstore3 = new openpgp.Keyring.localstore();
  localstore3.storePublic([]);
  var key = openpgp.key.readArmored(pubkey).keys[0];
  localstore1.storePublic([key]);
  expect(localstore2.loadPublic()[0].primaryKey.getKeyId().equals(key.primaryKey.getKeyId())).to.be.true;
  expect(localstore3.loadPublic()).to.have.length(0);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.MPI" id="apidoc.element.openpgp.MPI">
        function <span class="apidocSignatureSpan">openpgp.</span>MPI
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MPI() {
<span class="apidocCodeCommentSpan">  /** An implementation dependent integer */
</span>  this.data = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  new Uint8Array([0x01,0x52,0x02,0x80,0x87,0xf6,0xe4,0x49,0xd7,0x2e,0x3e,0xfe,0x60,0xb9,0xa3,
                0x2a,0xf0,0x67,0x58,0xe9,0xf6,0x47,0x83,0xde,0x7e,0xfb,0xbb,0xbd,0xdf,0x48,
                0x12,0x1b,0x06,0x7d,0x13,0xbc,0x3b,0x49,0xf9,0x86,0xd4,0x53,0xed,0x2d,0x68])];

var RSApubMPIs = [];
var i;
for (i = 0; i &lt; 2; i++) {
  RSApubMPIs[i] = new openpgp.<span class="apidocCodeKeywordSpan">MPI</span>();
  RSApubMPIs[i].read(RSApubMPIstrs[i]);
}

var RSAsecMPIs = [];
for (i = 0; i &lt; 4; i++) {
  RSAsecMPIs[i] = new openpgp.MPI();
  RSAsecMPIs[i].read(RSAsecMPIstrs[i]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.S2K" id="apidoc.element.openpgp.S2K">
        function <span class="apidocSignatureSpan">openpgp.</span>S2K
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function S2K() {
<span class="apidocCodeCommentSpan">  /** @type {module:enums.hash} */
</span>  this.algorithm = 'sha256';
  /** @type {module:enums.s2k} */
  this.type = 'iterated';
  this.c = 96;
  /** Eight bytes of salt in a binary string.
   * @type {String}
   */
  this.salt = _crypto2.default.random.getRandomBytes(8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.cleartext.CleartextMessage" id="apidoc.element.openpgp.cleartext.CleartextMessage">
        function <span class="apidocSignatureSpan">openpgp.</span>cleartext.CleartextMessage
        <span class="apidocSignatureSpan">(text, signature)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CleartextMessage(text, signature) {
  if (!(this instanceof CleartextMessage)) {
    return new CleartextMessage(text, signature);
  }
  // normalize EOL to canonical form &lt;CR&gt;&lt;LF&gt;
  this.text = text.replace(/\r/g, '').replace(/[\t ]+\n/g, "\n").replace(/\n/g, "\r\n");
  if (signature &amp;&amp; !(signature instanceof sigModule.Signature)) {
    throw new Error('Invalid signature input');
  }
  this.signature = signature || new sigModule.Signature(new _packet2.default.List());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.decrypt" id="apidoc.element.openpgp.decrypt">
        function <span class="apidocSignatureSpan">openpgp.</span>decrypt
        <span class="apidocSignatureSpan">(_ref6)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decrypt(_ref6) {
  var message = _ref6.message;
  var privateKey = _ref6.privateKey;
  var publicKeys = _ref6.publicKeys;
  var sessionKey = _ref6.sessionKey;
  var password = _ref6.password;
  var _ref6$format = _ref6.format;
  var format = _ref6$format === undefined ? 'utf8' : _ref6$format;
  var _ref6$signature = _ref6.signature;
  var signature = _ref6$signature === undefined ? null : _ref6$signature;

  checkMessage(message);publicKeys = toArray(publicKeys);

  if (!nativeAEAD() &amp;&amp; asyncProxy) {
    // use web worker if web crypto apis are not supported
    return asyncProxy.delegate('decrypt', { message: message, privateKey: privateKey, publicKeys: publicKeys, sessionKey: sessionKey
, password: password, format: format, signature: signature });
  }

  return message.decrypt(privateKey, sessionKey, password).then(function (message) {

    var result = parseMessage(message, format);
    if (result.data) {
      // verify
      if (!publicKeys) {
        publicKeys = [];
      }
      if (signature) {
        //detached signature
        result.signatures = message.verifyDetached(signature, publicKeys);
      } else {
        result.signatures = message.verify(publicKeys);
      }
    }
    return result;
  }).catch(onError.bind(null, 'Error decrypting message'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
options = {
    message: openpgp.message.read(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.<span class="apidocCodeKeywordSpan">decrypt</span>(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
```

#### Encrypt and decrypt *String* data with PGP keys

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.decryptKey" id="apidoc.element.openpgp.decryptKey">
        function <span class="apidocSignatureSpan">openpgp.</span>decryptKey
        <span class="apidocSignatureSpan">(_ref4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decryptKey(_ref4) {
  var privateKey = _ref4.privateKey;
  var passphrase = _ref4.passphrase;

  if (asyncProxy) {
    // use web worker if available
    return asyncProxy.delegate('decryptKey', { privateKey: privateKey, passphrase: passphrase });
  }

  return execute(function () {

    if (!privateKey.decrypt(passphrase)) {
      throw new Error('Invalid passphrase');
    }
    return {
      key: privateKey
    };
  }, 'Error decrypting private key');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    expect(error.message).to.match(/not decrypted/);
    done();
  });
});

describe('decryptKey', function() {
  it('should work for correct passphrase', function(done) {
    openpgp.<span class="apidocCodeKeywordSpan">decryptKey</span>({
      privateKey: privateKey.keys[0],
      passphrase: passphrase
    }).then(function(unlocked){
      expect(unlocked.key.primaryKey.getKeyId().toHex()).to.equal(privateKey.keys[0].primaryKey.getKeyId().toHex());
      expect(unlocked.key.primaryKey.isDecrypted).to.be.true;
      done();
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.decryptSessionKey" id="apidoc.element.openpgp.decryptSessionKey">
        function <span class="apidocSignatureSpan">openpgp.</span>decryptSessionKey
        <span class="apidocSignatureSpan">(_ref10)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decryptSessionKey(_ref10) {
  var message = _ref10.message;
  var privateKey = _ref10.privateKey;
  var password = _ref10.password;

  checkMessage(message);

  if (asyncProxy) {
    // use web worker if available
    return asyncProxy.delegate('decryptSessionKey', { message: message, privateKey: privateKey, password: password });
  }

  return execute(function () {
    return message.decryptSessionKey(privateKey, password);
  }, 'Error decrypting session key');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {String} password     (optional) password used to decrypt
 * @return {Message}             new message with decrypted content
 */
Message.prototype.decrypt = function (privateKey, sessionKey, password) {
  var _this = this;

  return Promise.resolve().then(function () {
var keyObj = sessionKey || _this.<span class="apidocCodeKeywordSpan">decryptSessionKey</span>(privateKey, password);
if (!keyObj || !_util2.default.isUint8Array(keyObj.data) || !_util2.default.isString(keyObj.algorithm)) {
  throw new Error('Invalid session key for decryption.');
}

var symEncryptedPacketlist = _this.packets.filterByTag(_enums2.default.packet.symmetricallyEncrypted, _enums2.default.packet.symEncryptedIntegrityProtected
, _enums2.default.packet.symEncryptedAEADProtected);

if (symEncryptedPacketlist.length === 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.destroyWorker" id="apidoc.element.openpgp.destroyWorker">
        function <span class="apidocSignatureSpan">openpgp.</span>destroyWorker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyWorker() {
  asyncProxy = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var password1 = 'I am a password';
var password2 = 'I am another password';

describe('OpenPGP.js public api tests', function() {

  describe('initWorker, getWorker, destroyWorker - unit tests', function() {
afterEach(function() {
  openpgp.<span class="apidocCodeKeywordSpan">destroyWorker</span>(); // cleanup worker in case of failure
});

it('should work', function() {
  var workerStub = {
    postMessage: function() {}
  };
  openpgp.initWorker({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.encrypt" id="apidoc.element.openpgp.encrypt">
        function <span class="apidocSignatureSpan">openpgp.</span>encrypt
        <span class="apidocSignatureSpan">(_ref5)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encrypt(_ref5) {
  var data = _ref5.data;
  var publicKeys = _ref5.publicKeys;
  var privateKeys = _ref5.privateKeys;
  var passwords = _ref5.passwords;
  var filename = _ref5.filename;
  var _ref5$armor = _ref5.armor;
  var armor = _ref5$armor === undefined ? true : _ref5$armor;
  var _ref5$detached = _ref5.detached;
  var detached = _ref5$detached === undefined ? false : _ref5$detached;
  var _ref5$signature = _ref5.signature;
  var signature = _ref5$signature === undefined ? null : _ref5$signature;

  checkData(data);publicKeys = toArray(publicKeys);privateKeys = toArray(privateKeys);passwords = toArray(passwords);

  if (!nativeAEAD() &amp;&amp; asyncProxy) {
    // use web worker if web crypto apis are not supported
    return asyncProxy.delegate('encrypt', { data: data, publicKeys: publicKeys, privateKeys: privateKeys, passwords: passwords,
filename: filename, armor: armor, detached: detached, signature: signature });
  }
  var result = {};
  return Promise.resolve().then(function () {

    var message = createMessage(data, filename);
    if (!privateKeys) {
      privateKeys = [];
    }
    if (privateKeys.length || signature) {
      // sign the message only if private keys or signature is specified
      if (detached) {
        var detachedSignature = message.signDetached(privateKeys, signature);
        if (armor) {
          result.signature = detachedSignature.armor();
        } else {
          result.signature = detachedSignature;
        }
      } else {
        message = message.sign(privateKeys, signature);
      }
    }
    return message.encrypt(publicKeys, passwords);
  }).then(function (message) {
    if (armor) {
      result.data = message.armor();
    } else {
      result.message = message;
    }
    return result;
  }).catch(onError.bind(null, 'Error encrypting message'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.<span class="apidocCodeKeywordSpan">encrypt</span>(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.encryptSessionKey" id="apidoc.element.openpgp.encryptSessionKey">
        function <span class="apidocSignatureSpan">openpgp.</span>encryptSessionKey
        <span class="apidocSignatureSpan">(_ref9)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encryptSessionKey(_ref9) {
  var data = _ref9.data;
  var algorithm = _ref9.algorithm;
  var publicKeys = _ref9.publicKeys;
  var passwords = _ref9.passwords;

  checkbinary(data);checkString(algorithm, 'algorithm');publicKeys = toArray(publicKeys);passwords = toArray(passwords);

  if (asyncProxy) {
    // use web worker if available
    return asyncProxy.delegate('encryptSessionKey', { data: data, algorithm: algorithm, publicKeys: publicKeys, passwords: passwords
 });
  }

  return execute(function () {
    return {

      message: messageLib.encryptSessionKey(data, algorithm, publicKeys, passwords)

    };
  }, 'Error encrypting session key');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   // use web worker if available
   return asyncProxy.delegate('encryptSessionKey', { data: data, algorithm: algorithm, publicKeys: publicKeys, passwords
: passwords });
 }

 return execute(function () {
   return {

     message: messageLib.<span class="apidocCodeKeywordSpan">encryptSessionKey</span>(data, algorithm, publicKeys, passwords)

   };
 }, 'Error encrypting session key');
}

/**
* Decrypt a symmetric session key with a private key or password. Either a private key or
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.generateKey" id="apidoc.element.openpgp.generateKey">
        function <span class="apidocSignatureSpan">openpgp.</span>generateKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generateKey() {
  var _ref2 = arguments.length &lt;= 0 || arguments[0] === undefined ? {} : arguments[0];

  var _ref2$userIds = _ref2.userIds;
  var userIds = _ref2$userIds === undefined ? [] : _ref2$userIds;
  var passphrase = _ref2.passphrase;
  var _ref2$numBits = _ref2.numBits;
  var numBits = _ref2$numBits === undefined ? 2048 : _ref2$numBits;
  var _ref2$unlocked = _ref2.unlocked;
  var unlocked = _ref2$unlocked === undefined ? false : _ref2$unlocked;
  var _ref2$keyExpirationTi = _ref2.keyExpirationTime;
  var keyExpirationTime = _ref2$keyExpirationTi === undefined ? 0 : _ref2$keyExpirationTi;

  var options = formatUserIds({ userIds: userIds, passphrase: passphrase, numBits: numBits, unlocked: unlocked, keyExpirationTime
: keyExpirationTime });

  if (!_util2.default.getWebCryptoAll() &amp;&amp; asyncProxy) {
    // use web worker if web crypto apis are not supported
    return asyncProxy.delegate('generateKey', options);
  }

  return key.generate(options).then(function (newKey) {
    return {

      key: newKey,
      privateKeyArmored: newKey.armor(),
      publicKeyArmored: newKey.toPublic().armor()

    };
  }).catch(onError.bind(null, 'Error generating keypair'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var options = {
    userIds: [{ name:'Jon Smith', email:'jon@example.com' }], // multiple user IDs
    numBits: 4096,                                            // RSA key size
    passphrase: 'super long and hard to guess secret'         // protects the private key
};

openpgp.<span class="apidocCodeKeywordSpan">generateKey</span>(options).then(function(key) {
    var privkey = key.privateKeyArmored; // '-----BEGIN PGP PRIVATE KEY BLOCK ... '
    var pubkey = key.publicKeyArmored;   // '-----BEGIN PGP PUBLIC KEY BLOCK ... '
});
```

#### Lookup public key on HKP server
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.getWorker" id="apidoc.element.openpgp.getWorker">
        function <span class="apidocSignatureSpan">openpgp.</span>getWorker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getWorker() {
  return asyncProxy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  it('should work', function() {
    var workerStub = {
      postMessage: function() {}
    };
    openpgp.initWorker({
      worker: workerStub
    });
    expect(openpgp.<span class="apidocCodeKeywordSpan">getWorker</span>()).to.exist;
    openpgp.destroyWorker();
    expect(openpgp.getWorker()).to.not.exist;
  });
});

describe('generateKey - unit tests', function() {
  var keyGenStub, keyObjStub, getWebCryptoAllStub;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.initWorker" id="apidoc.element.openpgp.initWorker">
        function <span class="apidocSignatureSpan">openpgp.</span>initWorker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function initWorker() {
  var _ref = arguments.length &lt;= 0 || arguments[0] === undefined ? {} : arguments[0];

  var _ref$path = _ref.path;
  var path = _ref$path === undefined ? 'openpgp.worker.js' : _ref$path;
  var worker = _ref.worker;

  if (worker || typeof window !== 'undefined' &amp;&amp; window.Worker) {
    asyncProxy = new _async_proxy2.default({ path: path, worker: worker, config: _config2.default });
    return true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Here are some examples of how to use the v2.x api. For more elaborate examples and working code, please check out the [public api
 unit tests](https://github.com/openpgpjs/openpgpjs/blob/master/test/general/openpgp.js). If you're upgrading from v1.x it
might help to check out the [documentation](https://github.com/openpgpjs/openpgpjs#documentation).

#### Set up

```js
var openpgp = require('openpgp'); // use as CommonJS, AMD, ES6 module or via window.openpgp

openpgp.<span class="apidocCodeKeywordSpan">initWorker</span>({ path:'openpgp.worker.js' }) // set the relative web worker
 path

openpgp.config.aead_protect = true // activate fast AES-GCM mode (not yet OpenPGP standard)
```

#### Encrypt and decrypt *Uint8Array* data with a password

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key" id="apidoc.element.openpgp.key.Key">
        function <span class="apidocSignatureSpan">openpgp.</span>key.Key
        <span class="apidocSignatureSpan">(packetlist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Key(packetlist) {
  if (!(this instanceof Key)) {
    return new Key(packetlist);
  }
  // same data as in packetlist but in structured form
  this.primaryKey = null;
  this.revocationSignature = null;
  this.directSignatures = null;
  this.users = null;
  this.subKeys = null;
  this.packetlist2structure(packetlist);
  if (!this.primaryKey || !this.users) {
    throw new Error('Invalid key: need at least key and user ID packet');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message" id="apidoc.element.openpgp.message.Message">
        function <span class="apidocSignatureSpan">openpgp.</span>message.Message
        <span class="apidocSignatureSpan">(packetlist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Message(packetlist) {
  if (!(this instanceof Message)) {
    return new Message(packetlist);
  }
  this.packets = packetlist || new _packet2.default.List();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Compressed" id="apidoc.element.openpgp.packet.Compressed">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.Compressed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Compressed() {
<span class="apidocCodeCommentSpan">  /**
   * Packet type
   * @type {module:enums.packet}
   */
</span>  this.tag = _enums2.default.packet.compressed;
  /**
   * List of packets
   * @type {module:packet/packetlist}
   */
  this.packets = null;
  /**
   * Compression algorithm
   * @type {compression}
   */
  this.algorithm = 'zip';

  /**
   * Compressed packet data
   * @type {String}
   */
  this.compressed = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.List" id="apidoc.element.openpgp.packet.List">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.List
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Packetlist() {
<span class="apidocCodeCommentSpan">  /** The number of packets contained within the list.
   * @readonly
   * @type {Integer} */
</span>  this.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
expect(pubKeys).to.exist;
expect(pubKeys.err).to.not.exist;
expect(pubKeys.keys).to.have.length(1);

var pubKey = pubKeys.keys[0];
expect(pubKey).to.exist;

var packetlist = new openpgp.<span class="apidocCodeKeywordSpan">packet.List</span>();

packetlist.read(openpgp.armor.decode(pub_sig_test).data);

var subkeys = pubKey.getSubkeyPackets();
expect(subkeys).to.exist;
expect(subkeys).to.have.length(2);
expect(subkeys[0].getKeyId().equals(packetlist[8].getKeyId())).to.be.true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Literal" id="apidoc.element.openpgp.packet.Literal">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.Literal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Literal() {
  this.tag = _enums2.default.packet.literal;
  this.format = 'utf8'; // default format for literal data packets
  this.date = new Date();
  this.data = new Uint8Array(0); // literal data representation
  this.filename = 'msg.txt';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  'YRlci72GHhlyos8YHA==\n' +
  '=KXkj\n' +
  '-----END PGP PRIVATE KEY BLOCK-----';

  it('Symmetrically encrypted packet', function(done) {
var message = new openpgp.packet.List();

var literal = new openpgp.<span class="apidocCodeKeywordSpan">packet.Literal</span>();
literal.setText('Hello world');

var enc = new openpgp.packet.SymmetricallyEncrypted();
message.push(enc);
enc.packets.push(literal);

var key = new Uint8Array([1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2]),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Marker" id="apidoc.element.openpgp.packet.Marker">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.Marker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Marker() {
  this.tag = _enums2.default.packet.marker;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.OnePassSignature" id="apidoc.element.openpgp.packet.OnePassSignature">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.OnePassSignature
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OnePassSignature() {
  this.tag = _enums2.default.packet.onePassSignature; // The packet type
  this.version = null; // A one-octet version number.  The current version is 3.
  this.type = null; // A one-octet signature type.  Signature types are described in {@link http://tools.ietf.org/html/rfc4880#section
-5.2.1|RFC4880 Section 5.2.1}.
  this.hashAlgorithm = null; // A one-octet number describing the hash algorithm used. (See {@link http://tools.ietf.org/html/rfc4880
#section-9.4|RFC4880 9.4})
  this.publicKeyAlgorithm = null; // A one-octet number describing the public-key algorithm used. (See {@link http://tools.ietf.
org/html/rfc4880#section-9.1|RFC4880 9.1})
  this.signingKeyId = null; // An eight-octet number holding the Key ID of the signing key.
  this.flags = null; //  A one-octet number holding a flag showing whether the signature is nested.  A zero value indicates that
 the next packet is another One-Pass Signature packet that describes another signature to be applied to the same message data.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKey" id="apidoc.element.openpgp.packet.PublicKey">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.PublicKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PublicKey() {
  this.tag = _enums2.default.packet.publicKey;
  this.version = 4;
<span class="apidocCodeCommentSpan">  /** Key creation date.
   * @type {Date} */
</span>  this.created = new Date();
  /** A list of multiprecision integers
   * @type {module:type/mpi} */
  this.mpi = [];
  /** Public key algorithm
   * @type {module:enums.publicKey} */
  this.algorithm = 'rsa_sign';
  // time in days (V3 only)
  this.expirationTimeV3 = 0;
  /**
   * Fingerprint in lowercase hex
   * @type {String}
   */
  this.fingerprint = null;
  /**
   * Keyid
   * @type {module:type/keyid}
   */
  this.keyid = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey" id="apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.PublicKeyEncryptedSessionKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PublicKeyEncryptedSessionKey() {
  this.tag = _enums2.default.packet.publicKeyEncryptedSessionKey;
  this.version = 3;

  this.publicKeyId = new _keyid2.default();
  this.publicKeyAlgorithm = 'rsa_encrypt';

  this.sessionKey = null;
  this.sessionKeyAlgorithm = 'aes256';

<span class="apidocCodeCommentSpan">  /** @type {Array&lt;module:type/mpi&gt;} */
</span>  this.encrypted = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var mpi = [mpiGen.n, mpiGen.ee, mpiGen.d, mpiGen.p, mpiGen.q, mpiGen.u];
mpi = mpi.map(function(k) {
  var mpi = new openpgp.MPI();
  mpi.fromBigInteger(k);
  return mpi;
});

var enc = new openpgp.<span class="apidocCodeKeywordSpan">packet.PublicKeyEncryptedSessionKey</span>(),
    msg = new openpgp.packet.List(),
    msg2 = new openpgp.packet.List();

enc.sessionKey = new Uint8Array([1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2]);
enc.publicKeyAlgorithm = 'rsa_encrypt';
enc.sessionKeyAlgorithm = 'aes256';
enc.publicKeyId.bytes = '12345678';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicSubkey" id="apidoc.element.openpgp.packet.PublicSubkey">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.PublicSubkey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PublicSubkey() {
  _public_key2.default.call(this);
  this.tag = _enums2.default.packet.publicSubkey;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretKey" id="apidoc.element.openpgp.packet.SecretKey">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.SecretKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SecretKey() {
  _public_key2.default.call(this);
  this.tag = _enums2.default.packet.secretKey;
  // encrypted secret-key data
  this.encrypted = null;
  // indicator if secret-key data is available in decrypted form
  this.isDecrypted = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

expect(verified).to.be.true;
done();
  });

  it('Writing and encryption of a secret key packet.', function(done) {
var key = new openpgp.packet.List();
key.push(new openpgp.<span class="apidocCodeKeywordSpan">packet.SecretKey</span>());

var rsa = new openpgp.crypto.publicKey.rsa();
var keySize = openpgp.util.getWebCryptoAll() ? 2048 : 512; // webkit webcrypto accepts minimum 2048 bit keys

rsa.generate(keySize, "10001").then(function(mipGen) {
  var mpi = [mipGen.n, mipGen.ee, mipGen.d, mipGen.p, mipGen.q, mipGen.u];
  mpi = mpi.map(function(k) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretSubkey" id="apidoc.element.openpgp.packet.SecretSubkey">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.SecretSubkey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SecretSubkey() {
  _secret_key2.default.call(this);
  this.tag = _enums2.default.packet.secretSubkey;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Signature" id="apidoc.element.openpgp.packet.Signature">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.Signature
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Signature() {
  this.tag = _enums2.default.packet.signature;
  this.version = 4;
  this.signatureType = null;
  this.hashAlgorithm = null;
  this.publicKeyAlgorithm = null;

  this.signatureData = null;
  this.unhashedSubpackets = null;
  this.signedHashValue = null;

  this.created = new Date();
  this.signatureExpirationTime = null;
  this.signatureNeverExpires = true;
  this.exportable = null;
  this.trustLevel = null;
  this.trustAmount = null;
  this.regularExpression = null;
  this.revocable = null;
  this.keyExpirationTime = null;
  this.keyNeverExpires = null;
  this.preferredSymmetricAlgorithms = null;
  this.revocationKeyClass = null;
  this.revocationKeyAlgorithm = null;
  this.revocationKeyFingerprint = null;
  this.issuerKeyId = new _keyid2.default();
  this.notation = null;
  this.preferredHashAlgorithms = null;
  this.preferredCompressionAlgorithms = null;
  this.keyServerPreferences = null;
  this.preferredKeyServer = null;
  this.isPrimaryUserID = null;
  this.policyURI = null;
  this.keyFlags = null;
  this.signersUserId = null;
  this.reasonForRevocationFlag = null;
  this.reasonForRevocationString = null;
  this.features = null;
  this.signatureTargetPublicKeyAlgorithm = null;
  this.signatureTargetHashAlgorithm = null;
  this.signatureTargetHash = null;
  this.embeddedSignature = null;

  this.verified = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return mpi;
});

key.mpi = mpi;

var signed = new openpgp.packet.List(),
    literal = new openpgp.packet.Literal(),
    signature = new openpgp.<span class="apidocCodeKeywordSpan">packet.Signature</span>();

literal.setText('Hello world');

signature.hashAlgorithm = 'sha256';
signature.publicKeyAlgorithm = 'rsa_sign';
signature.signatureType = 'binary';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected" id="apidoc.element.openpgp.packet.SymEncryptedAEADProtected">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.SymEncryptedAEADProtected
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymEncryptedAEADProtected() {
  this.tag = _enums2.default.packet.symEncryptedAEADProtected;
  this.version = VERSION;
  this.iv = null;
  this.encrypted = null;
  this.packets = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });

  it('Sym. encrypted AEAD protected packet', function(done) {
var key = new Uint8Array([1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2]),
    algo = 'aes256';

var literal = new openpgp.packet.Literal(),
    enc = new openpgp.<span class="apidocCodeKeywordSpan">packet.SymEncryptedAEADProtected</span>(),
    msg = new openpgp.packet.List();

msg.push(enc);
literal.setText('Hello world!');
enc.packets.push(literal);

var msg2 = new openpgp.packet.List();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected" id="apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.SymEncryptedIntegrityProtected
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymEncryptedIntegrityProtected() {
  this.tag = _enums2.default.packet.symEncryptedIntegrityProtected;
  this.version = VERSION;
<span class="apidocCodeCommentSpan">  /** The encrypted payload. */
</span>  this.encrypted = null; // string
  /**
   * If after decrypting the packet this is set to true,
   * a modification has been detected and thus the contents
   * should be discarded.
   * @type {Boolean}
   */
  this.modification = false;
  this.packets = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });

  it('Sym. encrypted integrity protected packet', function(done) {
var key = new Uint8Array([1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2]),
    algo = 'aes256';

var literal = new openpgp.packet.Literal(),
    enc = new openpgp.<span class="apidocCodeKeywordSpan">packet.SymEncryptedIntegrityProtected</span>(),
    msg = new openpgp.packet.List();

msg.push(enc);
literal.setText('Hello world!');
enc.packets.push(literal);
enc.encrypt(algo, key);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey" id="apidoc.element.openpgp.packet.SymEncryptedSessionKey">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.SymEncryptedSessionKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymEncryptedSessionKey() {
  this.tag = _enums2.default.packet.symEncryptedSessionKey;
  this.version = 4;
  this.sessionKey = null;
  this.sessionKeyEncryptionAlgorithm = null;
  this.sessionKeyAlgorithm = 'aes256';
  this.encrypted = null;
  this.s2k = new _s2k2.default();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });

  it('Sym encrypted session key reading/writing', function(done) {
var passphrase = 'hello',
    algo = 'aes256';

var literal = new openpgp.packet.Literal(),
    key_enc = new openpgp.<span class="apidocCodeKeywordSpan">packet.SymEncryptedSessionKey</span>(),
    enc = new openpgp.packet.SymEncryptedIntegrityProtected(),
    msg = new openpgp.packet.List();

msg.push(key_enc);
msg.push(enc);

key_enc.sessionKeyAlgorithm = algo;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted" id="apidoc.element.openpgp.packet.SymmetricallyEncrypted">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.SymmetricallyEncrypted
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymmetricallyEncrypted() {
  this.tag = _enums2.default.packet.symmetricallyEncrypted;
  this.encrypted = null;
<span class="apidocCodeCommentSpan">  /** Decrypted packets contained within.
   * @type {module:packet/packetlist} */
</span>  this.packets = null;
  this.ignore_mdc_error = _config2.default.ignore_mdc_error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  it('Symmetrically encrypted packet', function(done) {
var message = new openpgp.packet.List();

var literal = new openpgp.packet.Literal();
literal.setText('Hello world');

var enc = new openpgp.<span class="apidocCodeKeywordSpan">packet.SymmetricallyEncrypted</span>();
message.push(enc);
enc.packets.push(literal);

var key = new Uint8Array([1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2]),
    algo = 'aes256';

enc.encrypt(algo, key);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Trust" id="apidoc.element.openpgp.packet.Trust">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.Trust
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Trust() {
  this.tag = _enums2.default.packet.trust;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.UserAttribute" id="apidoc.element.openpgp.packet.UserAttribute">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.UserAttribute
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UserAttribute() {
  this.tag = _enums2.default.packet.userAttribute;
  this.attributes = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Userid" id="apidoc.element.openpgp.packet.Userid">
        function <span class="apidocSignatureSpan">openpgp.</span>packet.Userid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Userid() {
  this.tag = _enums2.default.packet.userid;
<span class="apidocCodeCommentSpan">  /** A string containing the user id. Usually in the form
   * John Doe &lt;john@example.com&gt;
   * @type {String}
   */
</span>  this.userid = '';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.reformatKey" id="apidoc.element.openpgp.reformatKey">
        function <span class="apidocSignatureSpan">openpgp.</span>reformatKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reformatKey() {
  var _ref3 = arguments.length &lt;= 0 || arguments[0] === undefined ? {} : arguments[0];

  var privateKey = _ref3.privateKey;
  var _ref3$userIds = _ref3.userIds;
  var userIds = _ref3$userIds === undefined ? [] : _ref3$userIds;
  var _ref3$passphrase = _ref3.passphrase;
  var passphrase = _ref3$passphrase === undefined ? "" : _ref3$passphrase;
  var _ref3$unlocked = _ref3.unlocked;
  var unlocked = _ref3$unlocked === undefined ? false : _ref3$unlocked;
  var _ref3$keyExpirationTi = _ref3.keyExpirationTime;
  var keyExpirationTime = _ref3$keyExpirationTi === undefined ? 0 : _ref3$keyExpirationTi;

  var options = formatUserIds({ privateKey: privateKey, userIds: userIds, passphrase: passphrase, unlocked: unlocked, keyExpirationTime
: keyExpirationTime });

  if (asyncProxy) {
    return asyncProxy.delegate('reformatKey', options);
  }

  return key.reformat(options).then(function (newKey) {
    return {

      key: newKey,
      privateKeyArmored: newKey.armor(),
      publicKeyArmored: newKey.toPublic().armor()

    };
  }).catch(onError.bind(null, 'Error reformatting keypair'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.generateKey(opt).then(function(key) {
  key = key.key
  expect(key.users.length).to.equal(1);
  expect(key.users[0].userId.userid).to.equal(userId1);
  expect(key.primaryKey.isDecrypted).to.be.true;
  opt.privateKey = key;
  opt.userIds = userId2;
  openpgp.<span class="apidocCodeKeywordSpan">reformatKey</span>(opt).then(function(newKey) {
    newKey = newKey.key
    expect(newKey.users.length).to.equal(1);
    expect(newKey.users[0].userId.userid).to.equal(userId2);
    expect(newKey.primaryKey.isDecrypted).to.be.true;
    done();
  }).catch(done);
}).catch(done);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.sign" id="apidoc.element.openpgp.sign">
        function <span class="apidocSignatureSpan">openpgp.</span>sign
        <span class="apidocSignatureSpan">(_ref7)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sign(_ref7) {
  var data = _ref7.data;
  var privateKeys = _ref7.privateKeys;
  var _ref7$armor = _ref7.armor;
  var armor = _ref7$armor === undefined ? true : _ref7$armor;
  var _ref7$detached = _ref7.detached;
  var detached = _ref7$detached === undefined ? false : _ref7$detached;

  checkString(data);
  privateKeys = toArray(privateKeys);

  if (asyncProxy) {
    // use web worker if available
    return asyncProxy.delegate('sign', { data: data, privateKeys: privateKeys, armor: armor, detached: detached });
  }

  var result = {};
  return execute(function () {

    var cleartextMessage = new cleartext.CleartextMessage(data);

    if (detached) {
      var signature = cleartextMessage.signDetached(privateKeys);
      if (armor) {
        result.signature = signature.armor();
      } else {
        result.signature = signature;
      }
    } else {
      cleartextMessage.sign(privateKeys);
    }

    if (armor) {
      result.data = cleartextMessage.armor();
    } else {
      result.message = cleartextMessage;
    }
    return result;
  }, 'Error signing cleartext message');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
options = {
data: 'Hello, World!',                             // input as String (or Uint8Array)
privateKeys: privKeyObj // for signing
};

openpgp.<span class="apidocCodeKeywordSpan">sign</span>(options).then(function(signed) {
cleartext = signed.data; // '-----BEGIN PGP SIGNED MESSAGE ... END PGP SIGNATURE-----'
});
```

```js
options = {
message: openpgp.cleartext.readArmored(cleartext), // parse armored message
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.signature.Signature" id="apidoc.element.openpgp.signature.Signature">
        function <span class="apidocSignatureSpan">openpgp.</span>signature.Signature
        <span class="apidocSignatureSpan">(packetlist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Signature(packetlist) {
  if (!(this instanceof Signature)) {
    return new Signature(packetlist);
  }
  this.packets = packetlist || new _packet2.default.List();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.verify" id="apidoc.element.openpgp.verify">
        function <span class="apidocSignatureSpan">openpgp.</span>verify
        <span class="apidocSignatureSpan">(_ref8)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function verify(_ref8) {
  var message = _ref8.message;
  var publicKeys = _ref8.publicKeys;
  var _ref8$signature = _ref8.signature;
  var signature = _ref8$signature === undefined ? null : _ref8$signature;

  checkCleartextMessage(message);
  publicKeys = toArray(publicKeys);

  if (asyncProxy) {
    // use web worker if available
    return asyncProxy.delegate('verify', { message: message, publicKeys: publicKeys, signature: signature });
  }

  var result = {};
  return execute(function () {
    result.data = message.getText();

    if (signature) {
      //detached signature
      result.signatures = message.verifyDetached(signature, publicKeys);
    } else {
      result.signatures = message.verify(publicKeys);
    }
    return result;
  }, 'Error verifying cleartext signed message');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
options = {
    message: openpgp.cleartext.readArmored(cleartext), // parse armored message
    publicKeys: openpgp.key.readArmored(pubkey).keys   // for verification
};

openpgp.<span class="apidocCodeKeywordSpan">verify</span>(options).then(function(verified) {
	validity = verified.signatures[0].valid; // true
	if (validity) {
		console.log('signed by key id ' + verified.signatures[0].keyid.toHex());
	}
});
```
...</pre></li>
    </ul>


































































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.AsyncProxy" id="apidoc.module.openpgp.AsyncProxy">module openpgp.AsyncProxy</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.AsyncProxy.AsyncProxy" id="apidoc.element.openpgp.AsyncProxy.AsyncProxy">
        function <span class="apidocSignatureSpan">openpgp.</span>AsyncProxy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AsyncProxy() {
  var _ref = arguments.length &lt;= 0 || arguments[0] === undefined ? {} : arguments[0];

  var _ref$path = _ref.path;
  var path = _ref$path === undefined ? 'openpgp.worker.js' : _ref$path;
  var worker = _ref.worker;
  var config = _ref.config;

  this.worker = worker || new Worker(path);
  this.worker.onmessage = this.onMessage.bind(this);
  this.worker.onerror = function (e) {
    throw new Error('Unhandled error in openpgp worker: ' + e.message + ' (' + e.filename + ':' + e.lineno + ')');
  };
  this.seedRandom(INITIAL_RANDOM_SEED);

  if (config) {
    this.worker.postMessage({ event: 'configure', config: config });
  }

  // Cannot rely on task order being maintained, use object keyed by request ID to track tasks
  this.tasks = {};
  this.currentID = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.AsyncProxy.prototype" id="apidoc.module.openpgp.AsyncProxy.prototype">module openpgp.AsyncProxy.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.AsyncProxy.prototype.delegate" id="apidoc.element.openpgp.AsyncProxy.prototype.delegate">
        function <span class="apidocSignatureSpan">openpgp.AsyncProxy.prototype.</span>delegate
        <span class="apidocSignatureSpan">(method, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delegate = function (method, options) {
  var _this = this;

  var id = this.getID();

  return new Promise(function (_resolve, reject) {
    // clone packets (for web worker structured cloning algorithm)
    _this.worker.postMessage({ id: id, event: method, options: _packet2.default.clone.clonePackets(options) }, _util2.default.getTransferables
.call(_util2.default, options));

    // remember to handle parsing cloned packets from worker
    _this.tasks[id] = { resolve: function resolve(data) {
        return _resolve(_packet2.default.clone.parseClonedPackets(data, method));
      }, reject: reject };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var _ref2$keyExpirationTi = _ref2.keyExpirationTime;
  var keyExpirationTime = _ref2$keyExpirationTi === undefined ? 0 : _ref2$keyExpirationTi;

  var options = formatUserIds({ userIds: userIds, passphrase: passphrase, numBits: numBits, unlocked: unlocked, keyExpirationTime
: keyExpirationTime });

  if (!_util2.default.getWebCryptoAll() &amp;&amp; asyncProxy) {
    // use web worker if web crypto apis are not supported
    return asyncProxy.<span class="apidocCodeKeywordSpan">delegate</span>('generateKey', options);
  }

  return key.generate(options).then(function (newKey) {
    return {

key: newKey,
privateKeyArmored: newKey.armor(),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.AsyncProxy.prototype.getID" id="apidoc.element.openpgp.AsyncProxy.prototype.getID">
        function <span class="apidocSignatureSpan">openpgp.AsyncProxy.prototype.</span>getID
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getID = function () {
  return this.currentID++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {String} method    the public api function to be delegated to the worker thread
 * @param  {Object} options   the api function's options
 * @return {Promise}          see the corresponding public api functions for their return types
 */
AsyncProxy.prototype.delegate = function (method, options) {
  var _this = this;

  var id = this.<span class="apidocCodeKeywordSpan">getID</span>();

  return new Promise(function (_resolve, reject) {
// clone packets (for web worker structured cloning algorithm)
_this.worker.postMessage({ id: id, event: method, options: _packet2.default.clone.clonePackets(options) }, _util2.default.getTransferables
.call(_util2.default, options));

// remember to handle parsing cloned packets from worker
_this.tasks[id] = { resolve: function resolve(data) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.AsyncProxy.prototype.getRandomBuffer" id="apidoc.element.openpgp.AsyncProxy.prototype.getRandomBuffer">
        function <span class="apidocSignatureSpan">openpgp.AsyncProxy.prototype.</span>getRandomBuffer
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRandomBuffer = function (size) {
  if (!size) {
    return null;
  }
  var buf = new Uint8Array(size);
  _crypto2.default.random.getRandomValues(buf);
  return buf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
* Send message to worker with random data
* @param  {Integer} size Number of bytes to send
*/
AsyncProxy.prototype.seedRandom = function (size) {
 var buf = this.<span class="apidocCodeKeywordSpan">getRandomBuffer</span>(size);
 this.worker.postMessage({ event: 'seed-random', buf: buf }, _util2.default.getTransferables.call(_util2.default, buf));
};

/**
* Get Uint8Array with random numbers
* @param  {Integer} size Length of buffer
* @return {Uint8Array}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.AsyncProxy.prototype.onMessage" id="apidoc.element.openpgp.AsyncProxy.prototype.onMessage">
        function <span class="apidocSignatureSpan">openpgp.AsyncProxy.prototype.</span>onMessage
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onMessage = function (event) {
  var msg = event.data;
  switch (msg.event) {
    case 'method-return':
      if (msg.err) {
        // fail
        this.tasks[msg.id].reject(new Error(msg.err));
      } else {
        // success
        this.tasks[msg.id].resolve(msg.data);
      }
      delete this.tasks[msg.id];
      break;
    case 'request-seed':
      this.seedRandom(RANDOM_SEED_REQUEST);
      break;
    default:
      throw new Error('Unknown Worker Event.');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.AsyncProxy.prototype.seedRandom" id="apidoc.element.openpgp.AsyncProxy.prototype.seedRandom">
        function <span class="apidocSignatureSpan">openpgp.AsyncProxy.prototype.</span>seedRandom
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">seedRandom = function (size) {
  var buf = this.getRandomBuffer(size);
  this.worker.postMessage({ event: 'seed-random', buf: buf }, _util2.default.getTransferables.call(_util2.default, buf));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var config = _ref.config;

this.worker = worker || new Worker(path);
this.worker.onmessage = this.onMessage.bind(this);
this.worker.onerror = function (e) {
  throw new Error('Unhandled error in openpgp worker: ' + e.message + ' (' + e.filename + ':' + e.
lineno + ')');
};
this.<span class="apidocCodeKeywordSpan">seedRandom</span>(INITIAL_RANDOM_SEED);

if (config) {
  this.worker.postMessage({ event: 'configure', config: config });
}

// Cannot rely on task order being maintained, use object keyed by request ID to track tasks
this.tasks = {};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.AsyncProxy.prototype.terminate" id="apidoc.element.openpgp.AsyncProxy.prototype.terminate">
        function <span class="apidocSignatureSpan">openpgp.AsyncProxy.prototype.</span>terminate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">terminate = function () {
  this.worker.terminate();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 return buf;
};

/**
* Terminates the worker
*/
AsyncProxy.prototype.terminate = function () {
 this.worker.<span class="apidocCodeKeywordSpan">terminate</span>();
};

/**
* Generic proxy function that handles all commands from the public api.
* @param  {String} method    the public api function to be delegated to the worker thread
* @param  {Object} options   the api function's options
* @return {Promise}          see the corresponding public api functions for their return types
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.HKP" id="apidoc.module.openpgp.HKP">module openpgp.HKP</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.HKP.HKP" id="apidoc.element.openpgp.HKP.HKP">
        function <span class="apidocSignatureSpan">openpgp.</span>HKP
        <span class="apidocSignatureSpan">(keyServerBaseUrl)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HKP(keyServerBaseUrl) {
  this._baseUrl = keyServerBaseUrl ? keyServerBaseUrl : _config2.default.keyserver;
  this._fetch = typeof window !== 'undefined' ? window.fetch : _dereq_('node-fetch');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var pubkey = key.publicKeyArmored;   // '-----BEGIN PGP PUBLIC KEY BLOCK ... '
});
```

#### Lookup public key on HKP server

```js
var hkp = new openpgp.<span class="apidocCodeKeywordSpan">HKP</span>('https://pgp.mit.edu');

var options = {
query: 'alice@example.com'
};

hkp.lookup(options).then(function(key) {
var pubkey = openpgp.key.readArmored(key);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.HKP.prototype" id="apidoc.module.openpgp.HKP.prototype">module openpgp.HKP.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.HKP.prototype.lookup" id="apidoc.element.openpgp.HKP.prototype.lookup">
        function <span class="apidocSignatureSpan">openpgp.HKP.prototype.</span>lookup
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookup = function (options) {
  var uri = this._baseUrl + '/pks/lookup?op=get&amp;options=mr&amp;search=',
      fetch = this._fetch;

  if (options.keyId) {
    uri += '0x' + encodeURIComponent(options.keyId);
  } else if (options.query) {
    uri += encodeURIComponent(options.query);
  } else {
    throw new Error('You must provide a query parameter!');
  }

  return fetch(uri).then(function (response) {
    if (response.status === 200) {
      return response.text();
    }
  }).then(function (publicKeyArmored) {
    if (!publicKeyArmored || publicKeyArmored.indexOf('-----END PGP PUBLIC KEY BLOCK-----') &lt; 0) {
      return;
    }
    return publicKeyArmored.trim();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var hkp = new openpgp.HKP('https://pgp.mit.edu');

var options = {
    query: 'alice@example.com'
};

hkp.<span class="apidocCodeKeywordSpan">lookup</span>(options).then(function(key) {
    var pubkey = openpgp.key.readArmored(key);
});
```

#### Upload public key to HKP server

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.HKP.prototype.upload" id="apidoc.element.openpgp.HKP.prototype.upload">
        function <span class="apidocSignatureSpan">openpgp.HKP.prototype.</span>upload
        <span class="apidocSignatureSpan">(publicKeyArmored)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">upload = function (publicKeyArmored) {
  var uri = this._baseUrl + '/pks/add',
      fetch = this._fetch;

  return fetch(uri, {
    method: 'post',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
    },
    body: 'keytext=' + encodeURIComponent(publicKeyArmored)
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### Upload public key to HKP server

```js
var hkp = new openpgp.HKP('https://pgp.mit.edu');

var pubkey = '-----BEGIN PGP PUBLIC KEY BLOCK ... END PGP PUBLIC KEY BLOCK-----';

hkp.<span class="apidocCodeKeywordSpan">upload</span>(pubkey).then(function() { ... });
```

#### Sign and verify cleartext messages

```js
var options, cleartext, validity;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.Keyid" id="apidoc.module.openpgp.Keyid">module openpgp.Keyid</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.Keyid.Keyid" id="apidoc.element.openpgp.Keyid.Keyid">
        function <span class="apidocSignatureSpan">openpgp.</span>Keyid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Keyid() {
  this.bytes = '';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyid.fromClone" id="apidoc.element.openpgp.Keyid.fromClone">
        function <span class="apidocSignatureSpan">openpgp.Keyid.</span>fromClone
        <span class="apidocSignatureSpan">(clone)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromClone = function (clone) {
  var keyid = new Keyid();
  keyid.bytes = clone.bytes;
  return keyid;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function packetlistCloneToCleartextMessage(clone) {
var packetlist = _packetlist2.default.fromStructuredClone(clone.signature);
return new cleartext.CleartextMessage(clone.text, new signature.Signature(packetlist));
}

//verification objects
function packetlistCloneToSignatures(clone) {
clone.keyid = _keyid2.default.<span class="apidocCodeKeywordSpan">fromClone</span>(clone.keyid);
clone.signature = new signature.Signature(clone.signature);
return clone;
}

function packetlistCloneToSignature(clone) {
if (typeof clone === "string") {
  //signature is armored
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyid.fromId" id="apidoc.element.openpgp.Keyid.fromId">
        function <span class="apidocSignatureSpan">openpgp.Keyid.</span>fromId
        <span class="apidocSignatureSpan">(hex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromId = function (hex) {
  var keyid = new Keyid();
  keyid.read(_util2.default.str2Uint8Array(_util2.default.hex2bin(hex)));
  return keyid;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
expect(pubKeyV3.primaryKey.getFingerprint()).to.equal('a44fcee620436a443bc4913640ab3e49');
done();
  });

  it('Create new key ID with fromId()', function() {
var pubKeyV4 = openpgp.key.readArmored(twoKeys).keys[0];
var keyId = pubKeyV4.primaryKey.getKeyId();
var newKeyId = keyId.constructor.<span class="apidocCodeKeywordSpan">fromId</span>(keyId.toHex());
expect(newKeyId.toHex()).to.equal(keyId.toHex());
  });

  it('Testing key method getSubkeyPackets', function(done) {
var pubKeys = openpgp.key.readArmored(pub_sig_test);

expect(pubKeys).to.exist;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyid.mapToHex" id="apidoc.element.openpgp.Keyid.mapToHex">
        function <span class="apidocSignatureSpan">openpgp.Keyid.</span>mapToHex
        <span class="apidocSignatureSpan">(keyId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapToHex = function (keyId) {
  return keyId.toHex();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.Keyid.prototype" id="apidoc.module.openpgp.Keyid.prototype">module openpgp.Keyid.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.Keyid.prototype.equals" id="apidoc.element.openpgp.Keyid.prototype.equals">
        function <span class="apidocSignatureSpan">openpgp.Keyid.prototype.</span>equals
        <span class="apidocSignatureSpan">(keyid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equals = function (keyid) {
  return this.bytes === keyid.bytes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case _enums2.default.signature.cert_persona:
case _enums2.default.signature.cert_casual:
case _enums2.default.signature.cert_positive:
  if (!user) {
    _util2.default.print_debug('Dropping certification signatures without preceding user packet');
    continue;
  }
  if (packetlist[i].issuerKeyId.<span class="apidocCodeKeywordSpan">equals</span>(primaryKeyId)) {
    if (!user.selfCertifications) {
      user.selfCertifications = [];
    }
    user.selfCertifications.push(packetlist[i]);
  } else {
    if (!user.otherCertifications) {
      user.otherCertifications = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyid.prototype.isNull" id="apidoc.element.openpgp.Keyid.prototype.isNull">
        function <span class="apidocSignatureSpan">openpgp.Keyid.prototype.</span>isNull
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNull = function () {
  return this.bytes === '';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (this.revocationKeyClass !== null) {

  bytes = new Uint8Array([this.revocationKeyClass, this.revocationKeyAlgorithm]);
  bytes = _util2.default.concatUint8Array([bytes, this.revocationKeyFingerprint]);
  arr.push(write_sub_packet(sub.revocation_key, bytes));
}
if (!this.issuerKeyId.<span class="apidocCodeKeywordSpan">isNull</span>()) {
  arr.push(write_sub_packet(sub.issuer, this.issuerKeyId.write()));
}
if (this.notation !== null) {
  for (var name in this.notation) {
    if (this.notation.hasOwnProperty(name)) {
      var value = this.notation[name];
      bytes = [new Uint8Array([0x80, 0, 0, 0])];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyid.prototype.read" id="apidoc.element.openpgp.Keyid.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.Keyid.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  this.bytes = _util2.default.Uint8Array2str(bytes.subarray(0, 8));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyid.prototype.toHex" id="apidoc.element.openpgp.Keyid.prototype.toHex">
        function <span class="apidocSignatureSpan">openpgp.Keyid.prototype.</span>toHex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toHex = function () {
  return _util2.default.hexstrdump(this.bytes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    message: openpgp.cleartext.readArmored(cleartext), // parse armored message
    publicKeys: openpgp.key.readArmored(pubkey).keys   // for verification
};

openpgp.verify(options).then(function(verified) {
	validity = verified.signatures[0].valid; // true
	if (validity) {
		console.log('signed by key id ' + verified.signatures[0].keyid.<span class="apidocCodeKeywordSpan">toHex</span>());
	}
});
```

#### Create and verify *detached* signatures

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyid.prototype.write" id="apidoc.element.openpgp.Keyid.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.Keyid.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  return _util2.default.str2Uint8Array(this.bytes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.Keyring" id="apidoc.module.openpgp.Keyring">module openpgp.Keyring</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.Keyring.Keyring" id="apidoc.element.openpgp.Keyring.Keyring">
        function <span class="apidocSignatureSpan">openpgp.</span>Keyring
        <span class="apidocSignatureSpan">(storeHandler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Keyring(storeHandler) {
  this.storeHandler = storeHandler || new _localstore2.default();
  this.publicKeys = new KeyArray(this.storeHandler.loadPublic());
  this.privateKeys = new KeyArray(this.storeHandler.loadPrivate());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...



'use strict';

var openpgp = typeof window != 'undefined' &amp;&amp; window.openpgp ? window.openpgp : require('../../dist/openpgp
');

var keyring = new openpgp.<span class="apidocCodeKeywordSpan">Keyring</span>(),
chai = require('chai'),
expect = chai.expect;

describe("Keyring", function() {
var user = 'whiteout.test@t-online.de',
  passphrase = 'asdf',
  keySize = 512,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyring.localstore" id="apidoc.element.openpgp.Keyring.localstore">
        function <span class="apidocSignatureSpan">openpgp.Keyring.</span>localstore
        <span class="apidocSignatureSpan">(prefix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LocalStore(prefix) {
  prefix = prefix || 'openpgp-';
  this.publicKeysItem = prefix + this.publicKeysItem;
  this.privateKeysItem = prefix + this.privateKeysItem;
  if (typeof window !== 'undefined' &amp;&amp; window.localStorage) {
    this.storage = window.localStorage;
  } else {
    this.storage = new (_dereq_('node-localstorage').LocalStorage)(_config2.default.node_store);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var key = keyring.publicKeys.removeForId(keyFingerP2);
  expect(key).to.exist.and.be.an.instanceof(openpgp.key.Key);
  expect(key.primaryKey.getKeyId().toHex()).equals(keyId2);
  expect(keyring.publicKeys.keys).to.be.empty;
});

it('customize localstorage itemname', function() {
  var localstore1 = new openpgp.Keyring.<span class="apidocCodeKeywordSpan">localstore</span>('my-custom-prefix-');
  var localstore2 = new openpgp.Keyring.localstore('my-custom-prefix-');
  var localstore3 = new openpgp.Keyring.localstore();
  localstore3.storePublic([]);
  var key = openpgp.key.readArmored(pubkey).keys[0];
  localstore1.storePublic([key]);
  expect(localstore2.loadPublic()[0].primaryKey.getKeyId().equals(key.primaryKey.getKeyId())).to.be.true;
  expect(localstore3.loadPublic()).to.have.length(0);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.Keyring.localstore" id="apidoc.module.openpgp.Keyring.localstore">module openpgp.Keyring.localstore</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.Keyring.localstore.localstore" id="apidoc.element.openpgp.Keyring.localstore.localstore">
        function <span class="apidocSignatureSpan">openpgp.Keyring.</span>localstore
        <span class="apidocSignatureSpan">(prefix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LocalStore(prefix) {
  prefix = prefix || 'openpgp-';
  this.publicKeysItem = prefix + this.publicKeysItem;
  this.privateKeysItem = prefix + this.privateKeysItem;
  if (typeof window !== 'undefined' &amp;&amp; window.localStorage) {
    this.storage = window.localStorage;
  } else {
    this.storage = new (_dereq_('node-localstorage').LocalStorage)(_config2.default.node_store);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var key = keyring.publicKeys.removeForId(keyFingerP2);
  expect(key).to.exist.and.be.an.instanceof(openpgp.key.Key);
  expect(key.primaryKey.getKeyId().toHex()).equals(keyId2);
  expect(keyring.publicKeys.keys).to.be.empty;
});

it('customize localstorage itemname', function() {
  var localstore1 = new openpgp.Keyring.<span class="apidocCodeKeywordSpan">localstore</span>('my-custom-prefix-');
  var localstore2 = new openpgp.Keyring.localstore('my-custom-prefix-');
  var localstore3 = new openpgp.Keyring.localstore();
  localstore3.storePublic([]);
  var key = openpgp.key.readArmored(pubkey).keys[0];
  localstore1.storePublic([key]);
  expect(localstore2.loadPublic()[0].primaryKey.getKeyId().equals(key.primaryKey.getKeyId())).to.be.true;
  expect(localstore3.loadPublic()).to.have.length(0);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.Keyring.localstore.prototype" id="apidoc.module.openpgp.Keyring.localstore.prototype">module openpgp.Keyring.localstore.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.Keyring.localstore.prototype.loadPrivate" id="apidoc.element.openpgp.Keyring.localstore.prototype.loadPrivate">
        function <span class="apidocSignatureSpan">openpgp.Keyring.localstore.prototype.</span>loadPrivate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadPrivate = function () {
  return loadKeys(this.storage, this.privateKeysItem);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * keyring from HTML5 local storage and initializes this instance.
 * @constructor
 * @param {class} [storeHandler] class implementing load() and store() methods
 */
function Keyring(storeHandler) {
this.storeHandler = storeHandler || new _localstore2.default();
this.publicKeys = new KeyArray(this.storeHandler.loadPublic());
this.privateKeys = new KeyArray(this.storeHandler.<span class="apidocCodeKeywordSpan">loadPrivate</span>());
}

/**
 * Calls the storeHandler to save the keys
 */
Keyring.prototype.store = function () {
this.storeHandler.storePublic(this.publicKeys.keys);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyring.localstore.prototype.loadPublic" id="apidoc.element.openpgp.Keyring.localstore.prototype.loadPublic">
        function <span class="apidocSignatureSpan">openpgp.Keyring.localstore.prototype.</span>loadPublic
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadPublic = function () {
  return loadKeys(this.storage, this.publicKeysItem);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Initialization routine for the keyring. This method reads the
 * keyring from HTML5 local storage and initializes this instance.
 * @constructor
 * @param {class} [storeHandler] class implementing load() and store() methods
 */
function Keyring(storeHandler) {
  this.storeHandler = storeHandler || new _localstore2.default();
  this.publicKeys = new KeyArray(this.storeHandler.<span class="apidocCodeKeywordSpan">loadPublic</span>());
  this.privateKeys = new KeyArray(this.storeHandler.loadPrivate());
}

/**
 * Calls the storeHandler to save the keys
 */
Keyring.prototype.store = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyring.localstore.prototype.storePrivate" id="apidoc.element.openpgp.Keyring.localstore.prototype.storePrivate">
        function <span class="apidocSignatureSpan">openpgp.Keyring.localstore.prototype.</span>storePrivate
        <span class="apidocSignatureSpan">(keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storePrivate = function (keys) {
  storeKeys(this.storage, this.privateKeysItem, keys);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

/**
 * Calls the storeHandler to save the keys
 */
Keyring.prototype.store = function () {
this.storeHandler.storePublic(this.publicKeys.keys);
this.storeHandler.<span class="apidocCodeKeywordSpan">storePrivate</span>(this.privateKeys.keys);
};

/**
 * Clear the keyring - erase all the keys
 */
Keyring.prototype.clear = function () {
this.publicKeys.keys = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyring.localstore.prototype.storePublic" id="apidoc.element.openpgp.Keyring.localstore.prototype.storePublic">
        function <span class="apidocSignatureSpan">openpgp.Keyring.localstore.prototype.</span>storePublic
        <span class="apidocSignatureSpan">(keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storePublic = function (keys) {
  storeKeys(this.storage, this.publicKeysItem, keys);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.privateKeys = new KeyArray(this.storeHandler.loadPrivate());
}

/**
 * Calls the storeHandler to save the keys
 */
Keyring.prototype.store = function () {
  this.storeHandler.<span class="apidocCodeKeywordSpan">storePublic</span>(this.publicKeys.keys);
  this.storeHandler.storePrivate(this.privateKeys.keys);
};

/**
 * Clear the keyring - erase all the keys
 */
Keyring.prototype.clear = function () {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.Keyring.prototype" id="apidoc.module.openpgp.Keyring.prototype">module openpgp.Keyring.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.Keyring.prototype.clear" id="apidoc.element.openpgp.Keyring.prototype.clear">
        function <span class="apidocSignatureSpan">openpgp.Keyring.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {
  this.publicKeys.keys = [];
  this.privateKeys.keys = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    'IWneczohBvLOarevZj1J+H3Ej/DVF2W7kJZLpvPfh7eo0biClS/GQUVw1rlE',
    'ph10hhUaSJ326LsFJccT3jk=',
    '=4jat',
    '-----END PGP PUBLIC KEY BLOCK-----'].join('\n');

it('Import key pair', function() {
  // clear any keys already in the keychain
  keyring.<span class="apidocCodeKeywordSpan">clear</span>();
  keyring.store();
  keyring.publicKeys.importKey(pubkey);
  keyring.publicKeys.importKey(pubkey2);
  keyring.privateKeys.importKey(privkey);
});

it('getKeysForId() - unknown id', function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyring.prototype.getAllKeys" id="apidoc.element.openpgp.Keyring.prototype.getAllKeys">
        function <span class="apidocSignatureSpan">openpgp.Keyring.prototype.</span>getAllKeys
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAllKeys = function () {
  return this.publicKeys.keys.concat(this.privateKeys.keys);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyring.prototype.getKeysForId" id="apidoc.element.openpgp.Keyring.prototype.getKeysForId">
        function <span class="apidocSignatureSpan">openpgp.Keyring.prototype.</span>getKeysForId
        <span class="apidocSignatureSpan">(keyId, deep)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getKeysForId = function (keyId, deep) {
  var result = [];
  result = result.concat(this.publicKeys.getForId(keyId, deep) || []);
  result = result.concat(this.privateKeys.getForId(keyId, deep) || []);
  return result.length ? result : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  keyring.store();
  keyring.publicKeys.importKey(pubkey);
  keyring.publicKeys.importKey(pubkey2);
  keyring.privateKeys.importKey(privkey);
});

it('getKeysForId() - unknown id', function() {
  var keys = keyring.<span class="apidocCodeKeywordSpan">getKeysForId</span>('01234567890123456');
  expect(keys).to.be.null;
});

it('getKeysForId() - valid id', function() {
  var keys = keyring.getKeysForId(keyId);
  // we get public and private key
  expect(keys).to.exist.and.have.length(2);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyring.prototype.removeKeysForId" id="apidoc.element.openpgp.Keyring.prototype.removeKeysForId">
        function <span class="apidocSignatureSpan">openpgp.Keyring.prototype.</span>removeKeysForId
        <span class="apidocSignatureSpan">(keyId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeKeysForId = function (keyId) {
  var result = [];
  result = result.concat(this.publicKeys.removeForId(keyId) || []);
  result = result.concat(this.privateKeys.removeForId(keyId) || []);
  return result.length ? result : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var keys = keyring.publicKeys.getForAddress(user);
  expect(keys).to.exist.and.have.length(1);
});

it('publicKeys.getForAddress() - valid address, plain email user id', function() {
  keyring.publicKeys.importKey(pubkey3);
  var keys = keyring.publicKeys.getForAddress(user3);
  keyring.<span class="apidocCodeKeywordSpan">removeKeysForId</span>(keyFingerP3);
  expect(keys).to.exist.and.have.length(1);
});

it('publicKeys.getForAddress() - address with regex special char |', function() {
  var keys = keyring.publicKeys.getForAddress('whiteout.test|not@t-online.de');
  expect(keys).to.be.empty;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.Keyring.prototype.store" id="apidoc.element.openpgp.Keyring.prototype.store">
        function <span class="apidocSignatureSpan">openpgp.Keyring.prototype.</span>store
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">store = function () {
  this.storeHandler.storePublic(this.publicKeys.keys);
  this.storeHandler.storePrivate(this.privateKeys.keys);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    'ph10hhUaSJ326LsFJccT3jk=',
    '=4jat',
    '-----END PGP PUBLIC KEY BLOCK-----'].join('\n');

it('Import key pair', function() {
  // clear any keys already in the keychain
  keyring.clear();
  keyring.<span class="apidocCodeKeywordSpan">store</span>();
  keyring.publicKeys.importKey(pubkey);
  keyring.publicKeys.importKey(pubkey2);
  keyring.privateKeys.importKey(privkey);
});

it('getKeysForId() - unknown id', function() {
  var keys = keyring.getKeysForId('01234567890123456');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.MPI" id="apidoc.module.openpgp.MPI">module openpgp.MPI</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.MPI.MPI" id="apidoc.element.openpgp.MPI.MPI">
        function <span class="apidocSignatureSpan">openpgp.</span>MPI
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MPI() {
<span class="apidocCodeCommentSpan">  /** An implementation dependent integer */
</span>  this.data = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  new Uint8Array([0x01,0x52,0x02,0x80,0x87,0xf6,0xe4,0x49,0xd7,0x2e,0x3e,0xfe,0x60,0xb9,0xa3,
                0x2a,0xf0,0x67,0x58,0xe9,0xf6,0x47,0x83,0xde,0x7e,0xfb,0xbb,0xbd,0xdf,0x48,
                0x12,0x1b,0x06,0x7d,0x13,0xbc,0x3b,0x49,0xf9,0x86,0xd4,0x53,0xed,0x2d,0x68])];

var RSApubMPIs = [];
var i;
for (i = 0; i &lt; 2; i++) {
  RSApubMPIs[i] = new openpgp.<span class="apidocCodeKeywordSpan">MPI</span>();
  RSApubMPIs[i].read(RSApubMPIstrs[i]);
}

var RSAsecMPIs = [];
for (i = 0; i &lt; 4; i++) {
  RSAsecMPIs[i] = new openpgp.MPI();
  RSAsecMPIs[i].read(RSAsecMPIstrs[i]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.MPI.fromClone" id="apidoc.element.openpgp.MPI.fromClone">
        function <span class="apidocSignatureSpan">openpgp.MPI.</span>fromClone
        <span class="apidocSignatureSpan">(clone)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromClone = function (clone) {
  clone.data.copyTo = _jsbn2.default.prototype.copyTo;
  var bn = new _jsbn2.default();
  clone.data.copyTo(bn);
  var mpi = new MPI();
  mpi.data = bn;
  return mpi;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function packetlistCloneToCleartextMessage(clone) {
var packetlist = _packetlist2.default.fromStructuredClone(clone.signature);
return new cleartext.CleartextMessage(clone.text, new signature.Signature(packetlist));
}

//verification objects
function packetlistCloneToSignatures(clone) {
clone.keyid = _keyid2.default.<span class="apidocCodeKeywordSpan">fromClone</span>(clone.keyid);
clone.signature = new signature.Signature(clone.signature);
return clone;
}

function packetlistCloneToSignature(clone) {
if (typeof clone === "string") {
  //signature is armored
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.MPI.prototype" id="apidoc.module.openpgp.MPI.prototype">module openpgp.MPI.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.MPI.prototype.byteLength" id="apidoc.element.openpgp.MPI.prototype.byteLength">
        function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>byteLength
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">byteLength = function () {
  return this.toBytes().length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// RSA (Encrypt or Sign) [HAC]
case 2:
// RSA Encrypt-Only [HAC]
case 3:
  // RSA Sign-Only [HAC]
  var rsa = new _public_key2.default.rsa();
  var n = publickey_MPIs[0].toBigInteger();
  var k = publickey_MPIs[0].<span class="apidocCodeKeywordSpan">byteLength</span>();
  var e = publickey_MPIs[1].toBigInteger();
  m = msg_MPIs[0].toBigInteger();
  var EM = rsa.verify(m, e, n);
  var EM2 = _pkcs2.default.emsa.encode(hash_algo, data, k);
  return EM.compareTo(EM2) === 0;
case 16:
  // Elgamal (Encrypt-Only) [ELGAMAL] [HAC]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.MPI.prototype.fromBigInteger" id="apidoc.element.openpgp.MPI.prototype.fromBigInteger">
        function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>fromBigInteger
        <span class="apidocSignatureSpan">(bn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromBigInteger = function (bn) {
  this.data = bn.clone();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      default:
        return [];
    }
  }();

  return result.map(function (bn) {
    var mpi = new _mpi2.default();
    mpi.<span class="apidocCodeKeywordSpan">fromBigInteger</span>(bn);
    return mpi;
  });
},

/**
 * Decrypts data using the specified public key multiprecision integers of the private key,
 * the specified secretMPIs of the private key and the specified algorithm.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.MPI.prototype.fromBytes" id="apidoc.element.openpgp.MPI.prototype.fromBytes">
        function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>fromBytes
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromBytes = function (bytes) {
  this.data = new _jsbn2.default(_util2.default.hexstrdump(bytes), 16);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var randomBits = _util2.default.Uint8Array2str(this.getRandomBytes(numBytes));
  if (bits % 8 &gt; 0) {

    randomBits = String.fromCharCode(Math.pow(2, bits % 8) - 1 &amp; randomBits.charCodeAt(0)) + randomBits.substring(1);
  }
  var mpi = new _mpi2.default();
  mpi.<span class="apidocCodeKeywordSpan">fromBytes</span>(randomBits);
  return mpi.toBigInteger();
},

getRandomBigIntegerInRange: function getRandomBigIntegerInRange(min, max) {
  if (max.compareTo(min) &lt;= 0) {
    throw new Error('Illegal parameter value: max &lt;= min');
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.MPI.prototype.read" id="apidoc.element.openpgp.MPI.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {

  if (typeof bytes === 'string' || String.prototype.isPrototypeOf(bytes)) {
    bytes = _util2.default.str2Uint8Array(bytes);
  }

  var bits = bytes[0] &lt;&lt; 8 | bytes[1];

  // Additional rules:
  //
  //    The size of an MPI is ((MPI.length + 7) / 8) + 2 octets.
  //
  //    The length field of an MPI describes the length starting from its
  //    most significant non-zero bit.  Thus, the MPI [00 02 01] is not
  //    formed correctly.  It should be [00 01 01].

  // TODO: Verification of this size method! This size calculation as
  //      specified above is not applicable in JavaScript
  var bytelen = Math.ceil(bits / 8);

  var raw = _util2.default.Uint8Array2str(bytes.subarray(2, 2 + bytelen));
  this.fromBytes(raw);

  return 2 + bytelen;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.MPI.prototype.toBigInteger" id="apidoc.element.openpgp.MPI.prototype.toBigInteger">
        function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>toBigInteger
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBigInteger = function () {
  return this.data.clone();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  publicKeyEncrypt: function publicKeyEncrypt(algo, publicMPIs, data) {
    var result = function () {
      var m;
      switch (algo) {
case 'rsa_encrypt':
case 'rsa_encrypt_sign':
  var rsa = new _public_key2.default.rsa();
  var n = publicMPIs[0].<span class="apidocCodeKeywordSpan">toBigInteger</span>();
  var e = publicMPIs[1].toBigInteger();
  m = data.toBigInteger();
  return [rsa.encrypt(m, e, n)];

case 'elgamal':
  var elgamal = new _public_key2.default.elgamal();
  var p = publicMPIs[0].toBigInteger();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.MPI.prototype.toBytes" id="apidoc.element.openpgp.MPI.prototype.toBytes">
        function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>toBytes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBytes = function () {
  var bytes = _util2.default.Uint8Array2str(this.write());
  return bytes.substr(2);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var toHash = '';
  if (this.version === 4) {
    toHash = this.writeOld();
    this.fingerprint = _util2.default.Uint8Array2str(_crypto2.default.hash.sha1(toHash));
  } else if (this.version === 3) {
    var mpicount = _crypto2.default.getPublicMpiCount(this.algorithm);
    for (var i = 0; i &lt; mpicount; i++) {
      toHash += this.mpi[i].<span class="apidocCodeKeywordSpan">toBytes</span>();
    }
    this.fingerprint = _util2.default.Uint8Array2str(_crypto2.default.hash.md5(_util2.default.str2Uint8Array(toHash)));
  }
  this.fingerprint = _util2.default.hexstrdump(this.fingerprint);
  return this.fingerprint;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.MPI.prototype.write" id="apidoc.element.openpgp.MPI.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.MPI.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  return _util2.default.str2Uint8Array(this.data.toMPI());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.S2K" id="apidoc.module.openpgp.S2K">module openpgp.S2K</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.S2K.S2K" id="apidoc.element.openpgp.S2K.S2K">
        function <span class="apidocSignatureSpan">openpgp.</span>S2K
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function S2K() {
<span class="apidocCodeCommentSpan">  /** @type {module:enums.hash} */
</span>  this.algorithm = 'sha256';
  /** @type {module:enums.s2k} */
  this.type = 'iterated';
  this.c = 96;
  /** Eight bytes of salt in a binary string.
   * @type {String}
   */
  this.salt = _crypto2.default.random.getRandomBytes(8);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.S2K.fromClone" id="apidoc.element.openpgp.S2K.fromClone">
        function <span class="apidocSignatureSpan">openpgp.S2K.</span>fromClone
        <span class="apidocSignatureSpan">(clone)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromClone = function (clone) {
  var s2k = new S2K();
  s2k.algorithm = clone.algorithm;
  s2k.type = clone.type;
  s2k.c = clone.c;
  s2k.salt = clone.salt;
  return s2k;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function packetlistCloneToCleartextMessage(clone) {
var packetlist = _packetlist2.default.fromStructuredClone(clone.signature);
return new cleartext.CleartextMessage(clone.text, new signature.Signature(packetlist));
}

//verification objects
function packetlistCloneToSignatures(clone) {
clone.keyid = _keyid2.default.<span class="apidocCodeKeywordSpan">fromClone</span>(clone.keyid);
clone.signature = new signature.Signature(clone.signature);
return clone;
}

function packetlistCloneToSignature(clone) {
if (typeof clone === "string") {
  //signature is armored
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.S2K.prototype" id="apidoc.module.openpgp.S2K.prototype">module openpgp.S2K.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.S2K.prototype.get_count" id="apidoc.element.openpgp.S2K.prototype.get_count">
        function <span class="apidocSignatureSpan">openpgp.S2K.prototype.</span>get_count
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_count = function () {
  // Exponent bias, defined in RFC4880
  var expbias = 6;

  return 16 + (this.c &amp; 15) &lt;&lt; (this.c &gt;&gt; 4) + expbias;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return _crypto2.default.hash.digest(algorithm, _util2.default.concatUint8Array([prefix, passphrase]));

      case 'salted':
return _crypto2.default.hash.digest(algorithm, _util2.default.concatUint8Array([prefix, s2k.salt, passphrase]));

      case 'iterated':
var isp = [],
    count = s2k.<span class="apidocCodeKeywordSpan">get_count</span>(),
    data = _util2.default.concatUint8Array([s2k.salt, passphrase]);

while (isp.length * data.length &lt; count) {
  isp.push(data);
}

isp = _util2.default.concatUint8Array(isp);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.S2K.prototype.produce_key" id="apidoc.element.openpgp.S2K.prototype.produce_key">
        function <span class="apidocSignatureSpan">openpgp.S2K.prototype.</span>produce_key
        <span class="apidocSignatureSpan">(passphrase, numBytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">produce_key = function (passphrase, numBytes) {
  passphrase = _util2.default.str2Uint8Array(_util2.default.encode_utf8(passphrase));

  function round(prefix, s2k) {
    var algorithm = _enums2.default.write(_enums2.default.hash, s2k.algorithm);

    switch (s2k.type) {
      case 'simple':
        return _crypto2.default.hash.digest(algorithm, _util2.default.concatUint8Array([prefix, passphrase]));

      case 'salted':
        return _crypto2.default.hash.digest(algorithm, _util2.default.concatUint8Array([prefix, s2k.salt, passphrase]));

      case 'iterated':
        var isp = [],
            count = s2k.get_count(),
            data = _util2.default.concatUint8Array([s2k.salt, passphrase]);

        while (isp.length * data.length &lt; count) {
          isp.push(data);
        }

        isp = _util2.default.concatUint8Array(isp);

        if (isp.length &gt; count) {
          isp = isp.subarray(0, count);
        }

        return _crypto2.default.hash.digest(algorithm, _util2.default.concatUint8Array([prefix, isp]));

      case 'gnu':
        throw new Error("GNU s2k type not supported.");

      default:
        throw new Error("Unknown s2k type.");
    }
  }

  var arr = [],
      rlength = 0,
      prefix = new Uint8Array(numBytes);

  for (var i = 0; i &lt; numBytes; i++) {
    prefix[i] = 0;
  }
  i = 0;

  while (rlength &lt; numBytes) {
    var result = round(prefix.subarray(0, i), this);
    arr.push(result);
    rlength += result.length;
    i++;
  }

  return _util2.default.concatUint8Array(arr).subarray(0, numBytes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 arr.push(iv);
 arr.push(_crypto2.default.cfb.normalEncrypt(symmetric, key, cleartext, iv));

 this.encrypted = _util2.default.concatUint8Array(arr);
};

function produceEncryptionKey(s2k, passphrase, algorithm) {
 return s2k.<span class="apidocCodeKeywordSpan">produce_key</span>(passphrase, _crypto2.default.cipher[algorithm].keySize);
}

/**
* Decrypts the private key MPIs which are needed to use the key.
* @link module:packet/secret_key.isDecrypted should be
* false otherwise a call to this function is not needed
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.S2K.prototype.read" id="apidoc.element.openpgp.S2K.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.S2K.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  var i = 0;
  this.type = _enums2.default.read(_enums2.default.s2k, bytes[i++]);
  this.algorithm = _enums2.default.read(_enums2.default.hash, bytes[i++]);

  switch (this.type) {
    case 'simple':
      break;

    case 'salted':
      this.salt = bytes.subarray(i, i + 8);
      i += 8;
      break;

    case 'iterated':
      this.salt = bytes.subarray(i, i + 8);
      i += 8;

      // Octet 10: count, a one-octet, coded value
      this.c = bytes[i++];
      break;

    case 'gnu':
      if (_util2.default.Uint8Array2str(bytes.subarray(i, 3)) === "GNU") {
        i += 3; // GNU
        var gnuExtType = 1000 + bytes[i++];
        if (gnuExtType === 1001) {
          this.type = gnuExtType;
          // GnuPG extension mode 1001 -- don't write secret key at all
        } else {
          throw new Error("Unknown s2k gnu protection mode.");
        }
      } else {
        throw new Error("Unknown s2k type.");
      }
      break;

    default:
      throw new Error("Unknown s2k type.");
  }

  return i;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.S2K.prototype.write" id="apidoc.element.openpgp.S2K.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.S2K.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {

  var arr = [new Uint8Array([_enums2.default.write(_enums2.default.s2k, this.type), _enums2.default.write(_enums2.default.hash,
this.algorithm)])];

  switch (this.type) {
    case 'simple':
      break;
    case 'salted':
      arr.push(this.salt);
      break;
    case 'iterated':
      arr.push(this.salt);
      arr.push(new Uint8Array([this.c]));
      break;
    case 'gnu':
      throw new Error("GNU s2k type not supported.");
    default:
      throw new Error("Unknown s2k type.");
  }

  return _util2.default.concatUint8Array(arr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.armor" id="apidoc.module.openpgp.armor">module openpgp.armor</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.armor.decode" id="apidoc.element.openpgp.armor.decode">
        function <span class="apidocSignatureSpan">openpgp.armor.</span>decode
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dearmor(text) {
  var reSplit = /^-----[^-]+-----$\n/m;

  // remove trailing whitespace at end of line
  text = text.replace(/[\t\r ]+\n/g, '\n');

  var type = getType(text);

  var splittext = text.split(reSplit);

  // IE has a bug in split with a re. If the pattern matches the beginning of the
  // string it doesn't create an empty array element 0. So we need to detect this
  // so we know the index of the data we are interested in.
  var indexBase = 1;

  var result, checksum, msg;

  if (text.search(reSplit) !== splittext[0].length) {
    indexBase = 0;
  }

  if (type !== 2) {
    msg = splitHeaders(splittext[indexBase]);
    var msg_sum = splitChecksum(msg.body);

    result = {
      data: _base2.default.decode(msg_sum.body),
      headers: msg.headers,
      type: type
    };

    checksum = msg_sum.checksum;
  } else {
    // Reverse dash-escaping for msg
    msg = splitHeaders(splittext[indexBase].replace(/^- /mg, ''));
    var sig = splitHeaders(splittext[indexBase + 1].replace(/^- /mg, ''));
    verifyHeaders(sig.headers);
    var sig_sum = splitChecksum(sig.body);

    result = {
      text: msg.body.replace(/\n$/, '').replace(/\n/g, "\r\n"),
      data: _base2.default.decode(sig_sum.body),
      headers: msg.headers,
      type: type
    };

    checksum = sig_sum.checksum;
  }

  checksum = checksum.substr(0, 4);

  if (!verifyCheckSum(result.data, checksum)) {
    throw new Error("Ascii armor integrity check on message failed: '" + checksum + "' should be '" + getCheckSum(result.data) + "'");
  }

  verifyHeaders(result.headers);

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * reads an OpenPGP cleartext signed message and returns a CleartextMessage object
 * @param {String} armoredText text to be parsed
 * @return {module:cleartext~CleartextMessage} new cleartext message object
 * @static
 */
function readArmored(armoredText) {
var input = _armor2.default.<span class="apidocCodeKeywordSpan">decode</span>(armoredText);
if (input.type !== _enums2.default.armor.signed) {
  throw new Error('No cleartext signed message.');
}
var packetlist = new _packet2.default.List();
packetlist.read(input.data);
verifyHeaders(input.headers, packetlist);
var signature = new sigModule.Signature(packetlist);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.armor.encode" id="apidoc.element.openpgp.armor.encode">
        function <span class="apidocSignatureSpan">openpgp.armor.</span>encode
        <span class="apidocSignatureSpan">(messagetype, body, partindex, parttotal)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function armor(messagetype, body, partindex, parttotal) {
  var result = [];
  switch (messagetype) {
    case _enums2.default.armor.multipart_section:
      result.push("-----BEGIN PGP MESSAGE, PART " + partindex + "/" + parttotal + "-----\r\n");
      result.push(addheader());
      result.push(_base2.default.encode(body));
      result.push("\r\n=" + getCheckSum(body) + "\r\n");
      result.push("-----END PGP MESSAGE, PART " + partindex + "/" + parttotal + "-----\r\n");
      break;
    case _enums2.default.armor.multipart_last:
      result.push("-----BEGIN PGP MESSAGE, PART " + partindex + "-----\r\n");
      result.push(addheader());
      result.push(_base2.default.encode(body));
      result.push("\r\n=" + getCheckSum(body) + "\r\n");
      result.push("-----END PGP MESSAGE, PART " + partindex + "-----\r\n");
      break;
    case _enums2.default.armor.signed:
      result.push("\r\n-----BEGIN PGP SIGNED MESSAGE-----\r\n");
      result.push("Hash: " + body.hash + "\r\n\r\n");
      result.push(body.text.replace(/\n-/g, "\n- -"));
      result.push("\r\n-----BEGIN PGP SIGNATURE-----\r\n");
      result.push(addheader());
      result.push(_base2.default.encode(body.data));
      result.push("\r\n=" + getCheckSum(body.data) + "\r\n");
      result.push("-----END PGP SIGNATURE-----\r\n");
      break;
    case _enums2.default.armor.message:
      result.push("-----BEGIN PGP MESSAGE-----\r\n");
      result.push(addheader());
      result.push(_base2.default.encode(body));
      result.push("\r\n=" + getCheckSum(body) + "\r\n");
      result.push("-----END PGP MESSAGE-----\r\n");
      break;
    case _enums2.default.armor.public_key:
      result.push("-----BEGIN PGP PUBLIC KEY BLOCK-----\r\n");
      result.push(addheader());
      result.push(_base2.default.encode(body));
      result.push("\r\n=" + getCheckSum(body) + "\r\n");
      result.push("-----END PGP PUBLIC KEY BLOCK-----\r\n\r\n");
      break;
    case _enums2.default.armor.private_key:
      result.push("-----BEGIN PGP PRIVATE KEY BLOCK-----\r\n");
      result.push(addheader());
      result.push(_base2.default.encode(body));
      result.push("\r\n=" + getCheckSum(body) + "\r\n");
      result.push("-----END PGP PRIVATE KEY BLOCK-----\r\n");
      break;
    case _enums2.default.armor.signature:
      result.push("-----BEGIN PGP SIGNATURE-----\r\n");
      result.push(addheader());
      result.push(_base2.default.encode(body));
      result.push("\r\n=" + getCheckSum(body) + "\r\n");
      result.push("-----END PGP SIGNATURE-----\r\n");
      break;
  }

  return result.join('');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/
CleartextMessage.prototype.armor = function () {
 var body = {
   hash: _enums2.default.read(_enums2.default.hash, _config2.default.prefer_hash_algorithm).toUpperCase(),
   text: this.text,
   data: this.signature.packets.write()
 };
 return _armor2.default.<span class="apidocCodeKeywordSpan">encode</span>(_enums2.default.armor.signed, body);
};

/**
* reads an OpenPGP cleartext signed message and returns a CleartextMessage object
* @param {String} armoredText text to be parsed
* @return {module:cleartext~CleartextMessage} new cleartext message object
* @static
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.cleartext" id="apidoc.module.openpgp.cleartext">module openpgp.cleartext</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.cleartext.CleartextMessage" id="apidoc.element.openpgp.cleartext.CleartextMessage">
        function <span class="apidocSignatureSpan">openpgp.cleartext.</span>CleartextMessage
        <span class="apidocSignatureSpan">(text, signature)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CleartextMessage(text, signature) {
  if (!(this instanceof CleartextMessage)) {
    return new CleartextMessage(text, signature);
  }
  // normalize EOL to canonical form &lt;CR&gt;&lt;LF&gt;
  this.text = text.replace(/\r/g, '').replace(/[\t ]+\n/g, "\n").replace(/\n/g, "\r\n");
  if (signature &amp;&amp; !(signature instanceof sigModule.Signature)) {
    throw new Error('Invalid signature input');
  }
  this.signature = signature || new sigModule.Signature(new _packet2.default.List());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// use web worker if available
return asyncProxy.delegate('sign', { data: data, privateKeys: privateKeys, armor: armor, detached: detached });
  }

  var result = {};
  return execute(function () {

var cleartextMessage = new cleartext.<span class="apidocCodeKeywordSpan">CleartextMessage</span>(data);

if (detached) {
  var signature = cleartextMessage.signDetached(privateKeys);
  if (armor) {
    result.signature = signature.armor();
  } else {
    result.signature = signature;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.cleartext.readArmored" id="apidoc.element.openpgp.cleartext.readArmored">
        function <span class="apidocSignatureSpan">openpgp.cleartext.</span>readArmored
        <span class="apidocSignatureSpan">(armoredText)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readArmored(armoredText) {
  var input = _armor2.default.decode(armoredText);
  if (input.type !== _enums2.default.armor.signed) {
    throw new Error('No cleartext signed message.');
  }
  var packetlist = new _packet2.default.List();
  packetlist.read(input.data);
  verifyHeaders(input.headers, packetlist);
  var signature = new sigModule.Signature(packetlist);
  var newMessage = new CleartextMessage(input.text, signature);
  return newMessage;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var options, encrypted;

var pubkey = '-----BEGIN PGP PUBLIC KEY BLOCK ... END PGP PUBLIC KEY BLOCK-----';
var privkey = '-----BEGIN PGP PRIVATE KEY BLOCK ... END PGP PRIVATE KEY BLOCK-----'; //encrypted private key
var passphrase = 'secret passphrase'; //what the privKey is encrypted with

var privKeyObj = openpgp.key.<span class="apidocCodeKeywordSpan">readArmored</span>(privkey).keys[0];
privKeyObj.decrypt(passphrase);

options = {
    data: 'Hello, World!',                             // input as String (or Uint8Array)
    publicKeys: openpgp.key.readArmored(pubkey).keys,  // for encryption
    privateKeys: privKeyObj // for signing (optional)
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.cleartext.CleartextMessage" id="apidoc.module.openpgp.cleartext.CleartextMessage">module openpgp.cleartext.CleartextMessage</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.cleartext.CleartextMessage.CleartextMessage" id="apidoc.element.openpgp.cleartext.CleartextMessage.CleartextMessage">
        function <span class="apidocSignatureSpan">openpgp.cleartext.</span>CleartextMessage
        <span class="apidocSignatureSpan">(text, signature)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CleartextMessage(text, signature) {
  if (!(this instanceof CleartextMessage)) {
    return new CleartextMessage(text, signature);
  }
  // normalize EOL to canonical form &lt;CR&gt;&lt;LF&gt;
  this.text = text.replace(/\r/g, '').replace(/[\t ]+\n/g, "\n").replace(/\n/g, "\r\n");
  if (signature &amp;&amp; !(signature instanceof sigModule.Signature)) {
    throw new Error('Invalid signature input');
  }
  this.signature = signature || new sigModule.Signature(new _packet2.default.List());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// use web worker if available
return asyncProxy.delegate('sign', { data: data, privateKeys: privateKeys, armor: armor, detached: detached });
  }

  var result = {};
  return execute(function () {

var cleartextMessage = new cleartext.<span class="apidocCodeKeywordSpan">CleartextMessage</span>(data);

if (detached) {
  var signature = cleartextMessage.signDetached(privateKeys);
  if (armor) {
    result.signature = signature.armor();
  } else {
    result.signature = signature;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.cleartext.CleartextMessage.prototype" id="apidoc.module.openpgp.cleartext.CleartextMessage.prototype">module openpgp.cleartext.CleartextMessage.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.armor" id="apidoc.element.openpgp.cleartext.CleartextMessage.prototype.armor">
        function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>armor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">armor = function () {
  var body = {
    hash: _enums2.default.read(_enums2.default.hash, _config2.default.prefer_hash_algorithm).toUpperCase(),
    text: this.text,
    data: this.signature.packets.write()
  };
  return _armor2.default.encode(_enums2.default.armor.signed, body);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  storeKeys(this.storage, this.privateKeysItem, keys);
};

function storeKeys(storage, itemname, keys) {
  var armoredKeys = [];
  if (keys.length) {
    for (var i = 0; i &lt; keys.length; i++) {
      armoredKeys.push(keys[i].<span class="apidocCodeKeywordSpan">armor</span>());
    }
    storage.setItem(itemname, JSON.stringify(armoredKeys));
  } else {
    storage.removeItem(itemname);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.getSigningKeyIds" id="apidoc.element.openpgp.cleartext.CleartextMessage.prototype.getSigningKeyIds">
        function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>getSigningKeyIds
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSigningKeyIds = function () {
  var keyIds = [];
  var signatureList = this.signature.packets;
  signatureList.forEach(function (packet) {
    keyIds.push(packet.issuerKeyId);
  });
  return keyIds;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ].join('\n');

var plaintext = 'short message\nnext line\ní•œêµ­ì–´/ì¡°ì„&nbsp;ë§';
var sMsg = openpgp.message.readArmored(msg_armor);
var pubKey2 = openpgp.key.readArmored(pub_key_arm2).keys[0];
var pubKey3 = openpgp.key.readArmored(pub_key_arm3).keys[0];

var keyids = sMsg.<span class="apidocCodeKeywordSpan">getSigningKeyIds</span>();

expect(pubKey2.getKeyPacket(keyids)).to.exist;
expect(pubKey3.getKeyPacket(keyids)).to.exist;

expect(sMsg.getText()).to.equal(plaintext);

var verifiedSig = sMsg.verify([pubKey2, pubKey3]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.getText" id="apidoc.element.openpgp.cleartext.CleartextMessage.prototype.getText">
        function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>getText
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getText = function () {
  // normalize end of line to \n
  return this.text.replace(/\r\n/g, "\n");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Get literal data as text
* @return {(String|null)} literal body of the message interpreted as text
*/
Message.prototype.getText = function () {
 var literal = this.packets.findPacket(_enums2.default.packet.literal);
 if (literal) {
   return literal.<span class="apidocCodeKeywordSpan">getText</span>();
 } else {
   return null;
 }
};

/**
* Encrypt the message either with public keys, passwords, or both at once.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.sign" id="apidoc.element.openpgp.cleartext.CleartextMessage.prototype.sign">
        function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>sign
        <span class="apidocSignatureSpan">(privateKeys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sign = function (privateKeys) {
  this.signature = this.signDetached(privateKeys);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
options = {
data: 'Hello, World!',                             // input as String (or Uint8Array)
privateKeys: privKeyObj // for signing
};

openpgp.<span class="apidocCodeKeywordSpan">sign</span>(options).then(function(signed) {
cleartext = signed.data; // '-----BEGIN PGP SIGNED MESSAGE ... END PGP SIGNATURE-----'
});
```

```js
options = {
message: openpgp.cleartext.readArmored(cleartext), // parse armored message
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.signDetached" id="apidoc.element.openpgp.cleartext.CleartextMessage.prototype.signDetached">
        function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>signDetached
        <span class="apidocSignatureSpan">(privateKeys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">signDetached = function (privateKeys) {
  var packetlist = new _packet2.default.List();
  var literalDataPacket = new _packet2.default.Literal();
  literalDataPacket.setText(this.text);
  for (var i = 0; i &lt; privateKeys.length; i++) {
    if (privateKeys[i].isPublic()) {
      throw new Error('Need private key for signing');
    }
    var signaturePacket = new _packet2.default.Signature();
    signaturePacket.signatureType = _enums2.default.signature.text;
    signaturePacket.hashAlgorithm = _config2.default.prefer_hash_algorithm;
    var signingKeyPacket = privateKeys[i].getSigningKeyPacket();
    signaturePacket.publicKeyAlgorithm = signingKeyPacket.algorithm;
    if (!signingKeyPacket.isDecrypted) {
      throw new Error('Private key is not decrypted.');
    }
    signaturePacket.sign(signingKeyPacket, literalDataPacket);
    packetlist.push(signaturePacket);
  }
  return new sigModule.Signature(packetlist);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
* Sign the cleartext message
* @param  {Array&lt;module:key~Key&gt;} privateKeys private keys with decrypted secret key data for signing
*/
CleartextMessage.prototype.sign = function (privateKeys) {
 this.signature = this.<span class="apidocCodeKeywordSpan">signDetached</span>(privateKeys);
};

/**
* Sign the cleartext message
* @param  {Array&lt;module:key~Key&gt;} privateKeys private keys with decrypted secret key data for signing
* @return {module:signature~Signature}      new detached signature of message content
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.verify" id="apidoc.element.openpgp.cleartext.CleartextMessage.prototype.verify">
        function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>verify
        <span class="apidocSignatureSpan">(keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verify = function (keys) {
  return this.verifyDetached(this.signature, keys);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
options = {
    message: openpgp.cleartext.readArmored(cleartext), // parse armored message
    publicKeys: openpgp.key.readArmored(pubkey).keys   // for verification
};

openpgp.<span class="apidocCodeKeywordSpan">verify</span>(options).then(function(verified) {
	validity = verified.signatures[0].valid; // true
	if (validity) {
		console.log('signed by key id ' + verified.signatures[0].keyid.toHex());
	}
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.cleartext.CleartextMessage.prototype.verifyDetached" id="apidoc.element.openpgp.cleartext.CleartextMessage.prototype.verifyDetached">
        function <span class="apidocSignatureSpan">openpgp.cleartext.CleartextMessage.prototype.</span>verifyDetached
        <span class="apidocSignatureSpan">(signature, keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verifyDetached = function (signature, keys) {
  var result = [];
  var signatureList = signature.packets;
  var literalDataPacket = new _packet2.default.Literal();
  // we assume that cleartext signature is generated based on UTF8 cleartext
  literalDataPacket.setText(this.text);
  for (var i = 0; i &lt; signatureList.length; i++) {
    var keyPacket = null;
    for (var j = 0; j &lt; keys.length; j++) {
      keyPacket = keys[j].getSigningKeyPacket(signatureList[i].issuerKeyId);
      if (keyPacket) {
        break;
      }
    }

    var verifiedSig = {};
    if (keyPacket) {
      verifiedSig.keyid = signatureList[i].issuerKeyId;
      verifiedSig.valid = signatureList[i].verify(keyPacket, literalDataPacket);
    } else {
      verifiedSig.keyid = signatureList[i].issuerKeyId;
      verifiedSig.valid = null;
    }
    verifiedSig.signature = new sigModule.Signature([signatureList[i]]);

    result.push(verifiedSig);
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Verify signatures of cleartext signed message
* @param {Array&lt;module:key~Key&gt;} keys array of keys to verify signatures
* @return {Array&lt;{keyid: module:type/keyid, valid: Boolean}&gt;} list of signer's keyid and validity of signature
*/
CleartextMessage.prototype.verify = function (keys) {
 return this.<span class="apidocCodeKeywordSpan">verifyDetached</span>(this.signature, keys);
};

/**
* Verify signatures of cleartext signed message
* @param {Array&lt;module:key~Key&gt;} keys array of keys to verify signatures
* @return {Array&lt;{keyid: module:type/keyid, valid: Boolean}&gt;} list of signer's keyid and validity of signature
*/
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.crypto" id="apidoc.module.openpgp.crypto">module openpgp.crypto</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.crypto.generateMpi" id="apidoc.element.openpgp.crypto.generateMpi">
        function <span class="apidocSignatureSpan">openpgp.crypto.</span>generateMpi
        <span class="apidocSignatureSpan">(algo, bits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generateMpi(algo, bits) {
  switch (algo) {
    case 'rsa_encrypt':
    case 'rsa_encrypt_sign':
    case 'rsa_sign':
      //remember "publicKey" refers to the crypto/public_key dir
      var rsa = new _public_key2.default.rsa();
      return rsa.generate(bits, "10001").then(function (keyObject) {
        var output = [];
        output.push(keyObject.n);
        output.push(keyObject.ee);
        output.push(keyObject.d);
        output.push(keyObject.p);
        output.push(keyObject.q);
        output.push(keyObject.u);
        return mapResult(output);
      });
    default:
      throw new Error('Unsupported algorithm for key generation.');
  }

  function mapResult(result) {
    return result.map(function (bn) {
      var mpi = new _mpi2.default();
      mpi.fromBigInteger(bn);
      return mpi;
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 this.encrypted = null;
 return true;
};

SecretKey.prototype.generate = function (bits) {
 var self = this;

 return _crypto2.default.<span class="apidocCodeKeywordSpan">generateMpi</span>(self.algorithm, bits).then(function (mpi) {
   self.mpi = mpi;
   self.isDecrypted = true;
 });
};

/**
* Clear private MPIs, return to initial state
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.generateSessionKey" id="apidoc.element.openpgp.crypto.generateSessionKey">
        function <span class="apidocSignatureSpan">openpgp.crypto.</span>generateSessionKey
        <span class="apidocSignatureSpan">(algo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generateSessionKey(algo) {
  return _random2.default.getRandomBytes(_cipher2.default[algo].keySize);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  symAlgo = keyModule.getPreferredSymAlgo(keys);
} else if (passwords) {
  symAlgo = _config2.default.encryption_cipher;
} else {
  throw new Error('No keys or passwords');
}

var sessionKey = _crypto2.default.<span class="apidocCodeKeywordSpan">generateSessionKey</span>(_enums2.default.read(_enums2.default
.symmetric, symAlgo));
msg = encryptSessionKey(sessionKey, _enums2.default.read(_enums2.default.symmetric, symAlgo), keys, passwords);

if (_config2.default.aead_protect) {
  symEncryptedPacket = new _packet2.default.SymEncryptedAEADProtected();
} else if (_config2.default.integrity_protect) {
  symEncryptedPacket = new _packet2.default.SymEncryptedIntegrityProtected();
} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.getPrefixRandom" id="apidoc.element.openpgp.crypto.getPrefixRandom">
        function <span class="apidocSignatureSpan">openpgp.crypto.</span>getPrefixRandom
        <span class="apidocSignatureSpan">(algo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getPrefixRandom(algo) {
  return _random2.default.getRandomBytes(_cipher2.default[algo].blockSize);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Encrypt the payload in the packet.
 * @param  {String} sessionKeyAlgorithm   The selected symmetric encryption algorithm to be used e.g. 'aes128'
 * @param  {Uint8Array} key               The key of cipher blocksize length to be used
 * @return {Promise}
 */
SymEncryptedIntegrityProtected.prototype.encrypt = function (sessionKeyAlgorithm, key) {
var bytes = this.packets.write();
var prefixrandom = _crypto2.default.<span class="apidocCodeKeywordSpan">getPrefixRandom</span>(sessionKeyAlgorithm);
var repeat = new Uint8Array([prefixrandom[prefixrandom.length - 2], prefixrandom[prefixrandom.length - 1]]);
var prefix = _util2.default.concatUint8Array([prefixrandom, repeat]);
var mdc = new Uint8Array([0xD3, 0x14]); // modification detection code packet

var tohash = _util2.default.concatUint8Array([bytes, mdc]);
var hash = _crypto2.default.hash.sha1(_util2.default.concatUint8Array([prefix, tohash]));
tohash = _util2.default.concatUint8Array([tohash, hash]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.getPrivateMpiCount" id="apidoc.element.openpgp.crypto.getPrivateMpiCount">
        function <span class="apidocSignatureSpan">openpgp.crypto.</span>getPrivateMpiCount
        <span class="apidocSignatureSpan">(algo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getPrivateMpiCount(algo) {
  switch (algo) {
    case 'rsa_encrypt':
    case 'rsa_encrypt_sign':
    case 'rsa_sign':
      //   Algorithm-Specific Fields for RSA secret keys:
      //   - multiprecision integer (MPI) of RSA secret exponent d.
      //   - MPI of RSA secret prime value p.
      //   - MPI of RSA secret prime value q (p &lt; q).
      //   - MPI of u, the multiplicative inverse of p, mod q.
      return 4;
    case 'elgamal':
      // Algorithm-Specific Fields for Elgamal secret keys:
      //   - MPI of Elgamal secret exponent x.
      return 1;
    case 'dsa':
      // Algorithm-Specific Fields for DSA secret keys:
      //   - MPI of DSA secret exponent x.
      return 1;
    default:
      throw new Error('Unknown algorithm');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var hash = _util2.default.Uint8Array2str(hashfn(cleartext));

if (hash !== hashtext) {
  return new Error("Hash mismatch.");
}

var mpis = _crypto2.default.<span class="apidocCodeKeywordSpan">getPrivateMpiCount</span>(algorithm);

var j = 0;
var mpi = [];

for (var i = 0; i &lt; mpis &amp;&amp; j &lt; cleartext.length; i++) {
  mpi[i] = new _mpi2.default();
  j += mpi[i].read(cleartext.subarray(j, cleartext.length));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.getPublicMpiCount" id="apidoc.element.openpgp.crypto.getPublicMpiCount">
        function <span class="apidocSignatureSpan">openpgp.crypto.</span>getPublicMpiCount
        <span class="apidocSignatureSpan">(algo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getPublicMpiCount(algo) {
  // - A series of multiprecision integers comprising the key material:
  //   Algorithm-Specific Fields for RSA public keys:
  //       - a multiprecision integer (MPI) of RSA public modulus n;
  //       - an MPI of RSA public encryption exponent e.
  switch (algo) {
    case 'rsa_encrypt':
    case 'rsa_encrypt_sign':
    case 'rsa_sign':
      return 2;

    //   Algorithm-Specific Fields for Elgamal public keys:
    //     - MPI of Elgamal prime p;
    //     - MPI of Elgamal group generator g;
    //     - MPI of Elgamal public key value y (= g**x mod p where x  is secret).
    case 'elgamal':
      return 3;

    //   Algorithm-Specific Fields for DSA public keys:
    //       - MPI of DSA prime p;
    //       - MPI of DSA group order q (q is a prime divisor of p-1);
    //       - MPI of DSA group generator g;
    //       - MPI of DSA public-key value y (= g**x mod p where x  is secret).
    case 'dsa':
      return 4;

    default:
      throw new Error('Unknown algorithm.');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.expirationTimeV3 = _util2.default.readNumber(bytes.subarray(pos, pos + 2));
  pos += 2;
}

// - A one-octet number denoting the public-key algorithm of this key.
this.algorithm = _enums2.default.read(_enums2.default.publicKey, bytes[pos++]);

var mpicount = _crypto2.default.<span class="apidocCodeKeywordSpan">getPublicMpiCount</span>(this.algorithm);
this.mpi = [];

var bmpi = bytes.subarray(pos, bytes.length);
var p = 0;

for (var i = 0; i &lt; mpicount &amp;&amp; p &lt; bmpi.length; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.publicKeyDecrypt" id="apidoc.element.openpgp.crypto.publicKeyDecrypt">
        function <span class="apidocSignatureSpan">openpgp.crypto.</span>publicKeyDecrypt
        <span class="apidocSignatureSpan">(algo, keyIntegers, dataIntegers)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function publicKeyDecrypt(algo, keyIntegers, dataIntegers) {
  var p;

  var bn = function () {
    switch (algo) {
      case 'rsa_encrypt_sign':
      case 'rsa_encrypt':
        var rsa = new _public_key2.default.rsa();
        // 0 and 1 are the public key.
        var n = keyIntegers[0].toBigInteger();
        var e = keyIntegers[1].toBigInteger();
        // 2 to 5 are the private key.
        var d = keyIntegers[2].toBigInteger();
        p = keyIntegers[3].toBigInteger();
        var q = keyIntegers[4].toBigInteger();
        var u = keyIntegers[5].toBigInteger();
        var m = dataIntegers[0].toBigInteger();
        return rsa.decrypt(m, n, e, d, p, q, u);
      case 'elgamal':
        var elgamal = new _public_key2.default.elgamal();
        var x = keyIntegers[3].toBigInteger();
        var c1 = dataIntegers[0].toBigInteger();
        var c2 = dataIntegers[1].toBigInteger();
        p = keyIntegers[0].toBigInteger();
        return elgamal.decrypt(c1, c2, p, x);
      default:
        return null;
    }
  }();

  var result = new _mpi2.default();
  result.fromBigInteger(bn);
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * packets (tag 1)
 *
 * @param {module:packet/secret_key} key
 *            Private key with secMPIs unlocked
 * @return {String} The unencrypted session key
 */
PublicKeyEncryptedSessionKey.prototype.decrypt = function (key) {
var result = _crypto2.default.<span class="apidocCodeKeywordSpan">publicKeyDecrypt</span>(this.publicKeyAlgorithm, key.mpi, this
.encrypted).toBytes();

var checksum = _util2.default.readNumber(_util2.default.str2Uint8Array(result.substr(result.length - 2)));

var decoded = _crypto2.default.pkcs1.eme.decode(result);

key = _util2.default.str2Uint8Array(decoded.substring(1, decoded.length - 2));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.publicKeyEncrypt" id="apidoc.element.openpgp.crypto.publicKeyEncrypt">
        function <span class="apidocSignatureSpan">openpgp.crypto.</span>publicKeyEncrypt
        <span class="apidocSignatureSpan">(algo, publicMPIs, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function publicKeyEncrypt(algo, publicMPIs, data) {
  var result = function () {
    var m;
    switch (algo) {
      case 'rsa_encrypt':
      case 'rsa_encrypt_sign':
        var rsa = new _public_key2.default.rsa();
        var n = publicMPIs[0].toBigInteger();
        var e = publicMPIs[1].toBigInteger();
        m = data.toBigInteger();
        return [rsa.encrypt(m, e, n)];

      case 'elgamal':
        var elgamal = new _public_key2.default.elgamal();
        var p = publicMPIs[0].toBigInteger();
        var g = publicMPIs[1].toBigInteger();
        var y = publicMPIs[2].toBigInteger();
        m = data.toBigInteger();
        return elgamal.encrypt(m, g, p, y);

      default:
        return [];
    }
  }();

  return result.map(function (bn) {
    var mpi = new _mpi2.default();
    mpi.fromBigInteger(bn);
    return mpi;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 data += _util2.default.Uint8Array2str(this.sessionKey);
 var checksum = _util2.default.calc_checksum(this.sessionKey);
 data += _util2.default.Uint8Array2str(_util2.default.writeNumber(checksum, 2));

 var mpi = new _mpi2.default();
 mpi.fromBytes(_crypto2.default.pkcs1.eme.encode(data, key.mpi[0].byteLength()));

 this.encrypted = _crypto2.default.<span class="apidocCodeKeywordSpan">publicKeyEncrypt</span>(this.publicKeyAlgorithm, key.mpi,
mpi);
};

/**
* Decrypts the session key (only for public key encrypted session key
* packets (tag 1)
*
* @param {module:packet/secret_key} key
...</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.crypto.cfb" id="apidoc.module.openpgp.crypto.cfb">module openpgp.crypto.cfb</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.crypto.cfb.decrypt" id="apidoc.element.openpgp.crypto.cfb.decrypt">
        function <span class="apidocSignatureSpan">openpgp.crypto.cfb.</span>decrypt
        <span class="apidocSignatureSpan">(cipherfn, key, ciphertext, resync)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decrypt(cipherfn, key, ciphertext, resync) {
  cipherfn = new _cipher2.default[cipherfn](key);
  var block_size = cipherfn.blockSize;

  var iblock = new Uint8Array(block_size);
  var ablock = new Uint8Array(block_size);

  var i, j, n;
  var text = new Uint8Array(ciphertext.length - block_size);

  // initialisation vector
  for (i = 0; i &lt; block_size; i++) {
    iblock[i] = 0;
  }

  iblock = cipherfn.encrypt(iblock);
  for (i = 0; i &lt; block_size; i++) {
    ablock[i] = ciphertext[i];
    iblock[i] ^= ablock[i];
  }

  ablock = cipherfn.encrypt(ablock);

  // test check octets
  if (iblock[block_size - 2] !== (ablock[0] ^ ciphertext[block_size]) || iblock[block_size - 1] !== (ablock[1] ^ ciphertext[block_size
 + 1])) {
    throw new Error('CFB decrypt: invalid key');
  }

<span class="apidocCodeCommentSpan">  /*  RFC4880: Tag 18 and Resync:
   *  [...] Unlike the Symmetrically Encrypted Data Packet, no
   *  special CFB resynchronization is done after encrypting this prefix
   *  data.  See "OpenPGP CFB Mode" below for more details.
    */
</span>
  j = 0;
  if (resync) {
    for (i = 0; i &lt; block_size; i++) {
      iblock[i] = ciphertext[i + 2];
    }
    for (n = block_size + 2; n &lt; ciphertext.length; n += block_size) {
      ablock = cipherfn.encrypt(iblock);

      for (i = 0; i &lt; block_size &amp;&amp; i + n &lt; ciphertext.length; i++) {
        iblock[i] = ciphertext[n + i];
        if (j &lt; text.length) {
          text[j] = ablock[i] ^ iblock[i];
          j++;
        }
      }
    }
  } else {
    for (i = 0; i &lt; block_size; i++) {
      iblock[i] = ciphertext[i];
    }
    for (n = block_size; n &lt; ciphertext.length; n += block_size) {
      ablock = cipherfn.encrypt(iblock);
      for (i = 0; i &lt; block_size &amp;&amp; i + n &lt; ciphertext.length; i++) {
        iblock[i] = ciphertext[n + i];
        if (j &lt; text.length) {
          text[j] = ablock[i] ^ iblock[i];
          j++;
        }
      }
    }
  }

  n = resync ? 0 : 2;

  text = text.subarray(n, ciphertext.length - block_size - 2 + n);

  return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
options = {
    message: openpgp.message.read(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.<span class="apidocCodeKeywordSpan">decrypt</span>(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
```

#### Encrypt and decrypt *String* data with PGP keys

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.cfb.encrypt" id="apidoc.element.openpgp.crypto.cfb.encrypt">
        function <span class="apidocSignatureSpan">openpgp.crypto.cfb.</span>encrypt
        <span class="apidocSignatureSpan">(prefixrandom, cipherfn, plaintext, key, resync)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encrypt(prefixrandom, cipherfn, plaintext, key, resync) {
  cipherfn = new _cipher2.default[cipherfn](key);
  var block_size = cipherfn.blockSize;

  var FR = new Uint8Array(block_size);
  var FRE = new Uint8Array(block_size);

  var new_prefix = new Uint8Array(prefixrandom.length + 2);
  new_prefix.set(prefixrandom);
  new_prefix[prefixrandom.length] = prefixrandom[block_size - 2];
  new_prefix[prefixrandom.length + 1] = prefixrandom[block_size - 1];
  prefixrandom = new_prefix;

  var ciphertext = new Uint8Array(plaintext.length + 2 + block_size * 2);
  var i, n, begin;
  var offset = resync ? 0 : 2;

  // 1.  The feedback register (FR) is set to the IV, which is all zeros.
  for (i = 0; i &lt; block_size; i++) {
    FR[i] = 0;
  }

  // 2.  FR is encrypted to produce FRE (FR Encrypted).  This is the
  //     encryption of an all-zero value.
  FRE = cipherfn.encrypt(FR);
  // 3.  FRE is xored with the first BS octets of random data prefixed to
  //     the plaintext to produce C[1] through C[BS], the first BS octets
  //     of ciphertext.
  for (i = 0; i &lt; block_size; i++) {
    ciphertext[i] = FRE[i] ^ prefixrandom[i];
  }

  // 4.  FR is loaded with C[1] through C[BS].
  FR.set(ciphertext.subarray(0, block_size));

  // 5.  FR is encrypted to produce FRE, the encryption of the first BS
  //     octets of ciphertext.
  FRE = cipherfn.encrypt(FR);

  // 6.  The left two octets of FRE get xored with the next two octets of
  //     data that were prefixed to the plaintext.  This produces C[BS+1]
  //     and C[BS+2], the next two octets of ciphertext.
  ciphertext[block_size] = FRE[0] ^ prefixrandom[block_size];
  ciphertext[block_size + 1] = FRE[1] ^ prefixrandom[block_size + 1];

  if (resync) {
    // 7.  (The resync step) FR is loaded with C[3] through C[BS+2].
    FR.set(ciphertext.subarray(2, block_size + 2));
  } else {
    FR.set(ciphertext.subarray(0, block_size));
  }
  // 8.  FR is encrypted to produce FRE.
  FRE = cipherfn.encrypt(FR);

  // 9.  FRE is xored with the first BS octets of the given plaintext, now
  //     that we have finished encrypting the BS+2 octets of prefixed
  //     data.  This produces C[BS+3] through C[BS+(BS+2)], the next BS
  //     octets of ciphertext.
  for (i = 0; i &lt; block_size; i++) {
    ciphertext[block_size + 2 + i] = FRE[i + offset] ^ plaintext[i];
  }
  for (n = block_size; n &lt; plaintext.length + offset; n += block_size) {
    // 10. FR is loaded with C[BS+3] to C[BS + (BS+2)] (which is C11-C18 for
    // an 8-octet block).
    begin = n + 2 - offset;
    FR.set(ciphertext.subarray(begin, begin + block_size));

    // 11. FR is encrypted to produce FRE.
    FRE = cipherfn.encrypt(FR);

    // 12. FRE is xored with the next BS octets of plaintext, to produce
    // the next BS octets of ciphertext.  These are loaded into FR, and
    // the process is repeated until the plaintext is used up.
    for (i = 0; i &lt; block_size; i++) {
      ciphertext[block_size + begin + i] = FRE[i] ^ plaintext[n + i - offset];
    }
  }

  ciphertext = ciphertext.subarray(0, plaintext.length + 2 + block_size);
  return ciphertext;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.<span class="apidocCodeKeywordSpan">encrypt</span>(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.cfb.mdc" id="apidoc.element.openpgp.crypto.cfb.mdc">
        function <span class="apidocSignatureSpan">openpgp.crypto.cfb.</span>mdc
        <span class="apidocSignatureSpan">(cipherfn, key, ciphertext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mdc(cipherfn, key, ciphertext) {
  cipherfn = new _cipher2.default[cipherfn](key);
  var block_size = cipherfn.blockSize;

  var iblock = new Uint8Array(block_size);
  var ablock = new Uint8Array(block_size);
  var i;

  // initialisation vector
  for (i = 0; i &lt; block_size; i++) {
    iblock[i] = 0;
  }

  iblock = cipherfn.encrypt(iblock);
  for (i = 0; i &lt; block_size; i++) {
    ablock[i] = ciphertext[i];
    iblock[i] ^= ablock[i];
  }

  ablock = cipherfn.encrypt(ablock);

  var result = new Uint8Array(iblock.length + 2);
  result.set(iblock);
  result[iblock.length] = ablock[0] ^ ciphertext[block_size];
  result[iblock.length + 1] = ablock[1] ^ ciphertext[block_size + 1];
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  decrypted = aesDecrypt(sessionKeyAlgorithm, this.encrypted, key);
} else {
  decrypted = _crypto2.default.cfb.decrypt(sessionKeyAlgorithm, key, this.encrypted, false);
}

// there must be a modification detection code packet as the
// last packet and everything gets hashed except the hash itself
var prefix = _crypto2.default.cfb.<span class="apidocCodeKeywordSpan">mdc</span>(sessionKeyAlgorithm, key, this.encrypted);
var bytes = decrypted.subarray(0, decrypted.length - 20);
var tohash = _util2.default.concatUint8Array([prefix, bytes]);
this.hash = _util2.default.Uint8Array2str(_crypto2.default.hash.sha1(tohash));
var mdc = _util2.default.Uint8Array2str(decrypted.subarray(decrypted.length - 20, decrypted.length));

if (this.hash !== mdc) {
  throw new Error('Modification detected.');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.cfb.normalDecrypt" id="apidoc.element.openpgp.crypto.cfb.normalDecrypt">
        function <span class="apidocSignatureSpan">openpgp.crypto.cfb.</span>normalDecrypt
        <span class="apidocSignatureSpan">(cipherfn, key, ciphertext, iv)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function normalDecrypt(cipherfn, key, ciphertext, iv) {
  cipherfn = new _cipher2.default[cipherfn](key);
  var block_size = cipherfn.blockSize;

  var blockp;
  var pos = 0;
  var plaintext = new Uint8Array(ciphertext.length);
  var offset = 0;
  var i,
      j = 0;

  if (iv === null) {
    blockp = new Uint8Array(block_size);
    for (i = 0; i &lt; block_size; i++) {
      blockp[i] = 0;
    }
  } else {
    blockp = iv.subarray(0, block_size);
  }
  while (ciphertext.length &gt; block_size * pos) {
    var decblock = cipherfn.encrypt(blockp);
    blockp = ciphertext.subarray(pos * block_size + offset, pos * block_size + block_size + offset);
    for (i = 0; i &lt; blockp.length; i++) {
      plaintext[j++] = blockp[i] ^ decblock[i];
    }
    pos++;
  }

  return plaintext;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var iv = this.encrypted.subarray(i, i + _crypto2.default.cipher[symmetric].blockSize);

i += iv.length;

var cleartext,
    ciphertext = this.encrypted.subarray(i, this.encrypted.length);

cleartext = _crypto2.default.cfb.<span class="apidocCodeKeywordSpan">normalDecrypt</span>(symmetric, key, ciphertext, iv);

var hash = s2k_usage === 254 ? 'sha1' : 'mod';

var parsedMPI = parse_cleartext_mpi(hash, cleartext, this.algorithm);
if (parsedMPI instanceof Error) {
  return false;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.cfb.normalEncrypt" id="apidoc.element.openpgp.crypto.cfb.normalEncrypt">
        function <span class="apidocSignatureSpan">openpgp.crypto.cfb.</span>normalEncrypt
        <span class="apidocSignatureSpan">(cipherfn, key, plaintext, iv)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function normalEncrypt(cipherfn, key, plaintext, iv) {
  cipherfn = new _cipher2.default[cipherfn](key);
  var block_size = cipherfn.blockSize;

  var blocki = new Uint8Array(block_size);
  var blockc = new Uint8Array(block_size);
  var pos = 0;
  var cyphertext = new Uint8Array(plaintext.length);
  var i,
      j = 0;

  if (iv === null) {
    for (i = 0; i &lt; block_size; i++) {
      blockc[i] = 0;
    }
  } else {
    for (i = 0; i &lt; block_size; i++) {
      blockc[i] = iv[i];
    }
  }
  while (plaintext.length &gt; block_size * pos) {
    var encblock = cipherfn.encrypt(blockc);
    blocki = plaintext.subarray(pos * block_size, pos * block_size + block_size);
    for (i = 0; i &lt; blocki.length; i++) {
      blockc[i] = blocki[i] ^ encblock[i];
      cyphertext[j++] = blockc[i];
    }
    pos++;
  }
  return cyphertext;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      key = produceEncryptionKey(s2k, passphrase, symmetric),
      blockLen = _crypto2.default.cipher[symmetric].blockSize,
      iv = _crypto2.default.random.getRandomBytes(blockLen);

  var arr = [new Uint8Array([254, _enums2.default.write(_enums2.default.symmetric, symmetric)])];
  arr.push(s2k.write());
  arr.push(iv);
  arr.push(_crypto2.default.cfb.<span class="apidocCodeKeywordSpan">normalEncrypt</span>(symmetric, key, cleartext, iv));

  this.encrypted = _util2.default.concatUint8Array(arr);
};

function produceEncryptionKey(s2k, passphrase, algorithm) {
  return s2k.produce_key(passphrase, _crypto2.default.cipher[algorithm].keySize);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.crypto.cipher" id="apidoc.module.openpgp.crypto.cipher">module openpgp.crypto.cipher</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.crypto.cipher.aes128" id="apidoc.element.openpgp.crypto.cipher.aes128">
        function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>aes128
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function c(key) {
  this.key = keyExpansion(key);
  this._temp = new Uint32Array(this.blockSize / 4);

  this.encrypt = function (block) {
    return AESencrypt(block, this.key, this._temp);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var util = openpgp.util,
chai = require('chai'),
expect = chai.expect;

describe('AES Rijndael cipher test with test vectors from ecb_tbl.txt', function() {
function test_aes(input, key, output) {
  var aes = new openpgp.crypto.cipher.<span class="apidocCodeKeywordSpan">aes128</span>(key);

  var result = util.bin2str(aes.encrypt(new Uint8Array(input)));

  return util.hexstrdump(result) == util.hexstrdump(util.bin2str(output));
}

var testvectors128 = [[[0x00,0x01,0x02,0x03,0x05,0x06,0x07,0x08,0x0A,0x0B,0x0C,0x0D,0x0F,0x10,0x11,0x12],[0x50,0x68,0x12,0xA4,0x5F
,0x08,0xC8,0x89,0xB9,0x7F,0x59,0x80,0x03,0x8B,0x83,0x59],[0xD8,0xF5,0x32,0x53,0x82,0x89,0xEF,0x7D,0x06,0xB5,0x06,0xA4,0xFD,0x5B,
0xE9,0xC9]],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.cipher.aes192" id="apidoc.element.openpgp.crypto.cipher.aes192">
        function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>aes192
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function c(key) {
  this.key = keyExpansion(key);
  this._temp = new Uint32Array(this.blockSize / 4);

  this.encrypt = function (block) {
    return AESencrypt(block, this.key, this._temp);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.cipher.aes256" id="apidoc.element.openpgp.crypto.cipher.aes256">
        function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>aes256
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function c(key) {
  this.key = keyExpansion(key);
  this._temp = new Uint32Array(this.blockSize / 4);

  this.encrypt = function (block) {
    return AESencrypt(block, this.key, this._temp);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.cipher.blowfish" id="apidoc.element.openpgp.crypto.cipher.blowfish">
        function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>blowfish
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BF(key) {
  this.bf = new Blowfish();
  this.bf.init(key);

  this.encrypt = function (block) {
    return this.bf.encrypt_block(block);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var util = openpgp.util,
BFencrypt = openpgp.crypto.cipher.blowfish,
chai = require('chai'),
expect = chai.expect;

it('Blowfish cipher test with test vectors from http://www.schneier.com/code/vectors.txt', function(done) {
function test_bf(input, key, output) {
  var blowfish = new openpgp.crypto.cipher.<span class="apidocCodeKeywordSpan">blowfish</span>(util.bin2str(key));
  var result = util.bin2str(blowfish.encrypt(input));

  return (util.hexstrdump(result) == util.hexstrdump(util.bin2str(output)));
}

var testvectors = [[[0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],[0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00],[0x4E,0xF9,0x97,0x45,0x61
,0x98,0xDD,0x78]],
                   [[0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF],[0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF],[0x51,0x86,0x6F,0xD5,0xB8
,0x5E,0xCB,0x8A]],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.cipher.cast5" id="apidoc.element.openpgp.crypto.cipher.cast5">
        function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>cast5
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Cast5(key) {
  this.cast5 = new OpenpgpSymencCast5();
  this.cast5.setKey(key);

  this.encrypt = function (block) {
    return this.cast5.encrypt(block);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var util = openpgp.util,
  chai = require('chai'),
  expect = chai.expect;

it('CAST-128 cipher test with test vectors from RFC2144', function (done) {
	function test_cast(input, key, output) {
		var cast5 = new openpgp.crypto.cipher.<span class="apidocCodeKeywordSpan">cast5</span>(key);
		var result = util.bin2str(cast5.encrypt(input));

		return util.hexstrdump(result) == util.hexstrdump(util.bin2str(output));
	}
	
	var testvectors = [[[0x01,0x23,0x45,0x67,0x12,0x34,0x56,0x78,0x23,0x45,0x67,0x89,0x34,0x56,0x78,0x9A],[0x01,0x23,0x45,0x67,0x89
,0xAB,0xCD,0xEF],[0x23,0x8B,0x4F,0xE5,0x84,0x7E,0x44,0xB2]]];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.cipher.des" id="apidoc.element.openpgp.crypto.cipher.des">
        function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>des
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OriginalDes(key) {
  this.key = key;

  this.encrypt = function (block, padding) {
    var keys = des_createKeys(this.key);
    return des(keys, block, true, 0, null, padding);
  };

  this.decrypt = function (block, padding) {
    var keys = des_createKeys(this.key);
    return des(keys, block, false, 0, null, padding);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
	                  [[0x03, 0x04, 0x05], [0x9A, 0xD7, 0x5A, 0x24, 0xFD, 0x3F, 0xBF, 0x22]],
	                  [[0x04, 0x05, 0x06, 0x07], [0x14, 0x4E, 0x68, 0x6D, 0x2E, 0xC1, 0xB7, 0x52]],
	                  [[0x05, 0x06, 0x07, 0x08, 0x09], [0x12, 0x0A, 0x51, 0x08, 0xF9, 0xA3, 0x03, 0x74]],
	                  [[0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B], [0xB2, 0x07, 0xD1, 0x05, 0xF6, 0x67, 0xAF, 0xBA]],
	                  [[0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D], [0xCA, 0x59, 0x61, 0x3A, 0x83, 0x23, 0x26, 0xDD]],
	                  [[0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F], [0x83, 0x25, 0x79, 0x06, 0x54, 0xA4, 0x44, 0xD9]]];

    var des = new openpgp.crypto.cipher.<span class="apidocCodeKeywordSpan">des</span>(key);

    for (var padding = 0; padding &lt; 3; padding++) {
var thisVectorSet = testvectors[padding];

for (var i = 0; i &lt; thisVectorSet.length; i++) {
  var encrypted = des.encrypt(thisVectorSet[i][0], padding);
  var decrypted = des.decrypt(encrypted, padding);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.cipher.idea" id="apidoc.element.openpgp.crypto.cipher.idea">
        function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>idea
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function idea() {
  throw new Error('IDEA symmetric-key algorithm not implemented');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.cipher.tripledes" id="apidoc.element.openpgp.crypto.cipher.tripledes">
        function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>tripledes
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Des(key) {
  this.key = [];

  for (var i = 0; i &lt; 3; i++) {
    this.key.push(new Uint8Array(key.subarray(i * 8, i * 8 + 8)));
  }

  this.encrypt = function (block) {
    return des(des_createKeys(this.key[2]), des(des_createKeys(this.key[1]), des(des_createKeys(this.key[0]), block, true, 0, null
, null), false, 0, null, null), true, 0, null, null);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
               [[0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08],[0xCC,0x08,0x3F,0x1E,0x6D,0x9E,0x85,0xF6]],
               [[0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04],[0xD2,0xFD,0x88,0x67,0xD5,0x0D,0x2D,0xFE]],
               [[0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02],[0x06,0xE7,0xEA,0x22,0xCE,0x92,0x70,0x8F]],
               [[0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01],[0x16,0x6B,0x40,0xB4,0x4A,0xBA,0x4B,0xD6]]];

  it('3DES EDE test vectors', function (done) {
    for (var i = 0; i &lt; testvectors.length; i++) {
var des = new openpgp.crypto.cipher.<span class="apidocCodeKeywordSpan">tripledes</span>(key);

var encr = util.bin2str(des.encrypt(testvectors[i][0], key));

expect(encr, 'vector with block ' + util.hexidump(testvectors[i][0]) +
             ' and key ' + util.hexstrdump(util.Uint8Array2str(key)) +
             ' should be ' + util.hexidump(testvectors[i][1]) +
             ' != ' + util.hexidump(encr)).to.be.equal(util.bin2str(testvectors[i][1]));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.cipher.twofish" id="apidoc.element.openpgp.crypto.cipher.twofish">
        function <span class="apidocSignatureSpan">openpgp.crypto.cipher.</span>twofish
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TF(key) {
  this.tf = createTwofish();
  this.tf.open(toArray(key), 0);

  this.encrypt = function (block) {
    return this.tf.encrypt(toArray(block), 0);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var util = openpgp.util,
chai = require('chai'),
expect = chai.expect;

it('Twofish with test vectors from http://www.schneier.com/code/ecb_ival.txt', function(done) {
function TFencrypt(block, key) {
  var tf = new openpgp.crypto.cipher.<span class="apidocCodeKeywordSpan">twofish</span>(util.str2Uint8Array(key));

  return tf.encrypt(block);
}

var start = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
var start_short = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
var testvectors = [[0x57,0xFF,0x73,0x9D,0x4D,0xC9,0x2C,0x1B,0xD7,0xFC,0x01,0x70,0x0C,0xC8,0x21,0x6F],
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.crypto.gcm" id="apidoc.module.openpgp.crypto.gcm">module openpgp.crypto.gcm</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.crypto.gcm.decrypt" id="apidoc.element.openpgp.crypto.gcm.decrypt">
        function <span class="apidocSignatureSpan">openpgp.crypto.gcm.</span>decrypt
        <span class="apidocSignatureSpan">(cipher, ciphertext, key, iv)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decrypt(cipher, ciphertext, key, iv) {
  if (cipher.substr(0, 3) !== 'aes') {
    return Promise.reject(new Error('GCM mode supports only AES cipher'));
  }

  if (webCrypto &amp;&amp; _config2.default.use_native &amp;&amp; key.length !== 24) {
    // WebCrypto (no 192 bit support) see: https://www.chromium.org/blink/webcrypto#TOC-AES-support
    return webDecrypt(ciphertext, key, iv);
  } else if (nodeCrypto &amp;&amp; _config2.default.use_native) {
    // Node crypto library
    return nodeDecrypt(ciphertext, key, iv);
  } else {
    // asm.js fallback
    return Promise.resolve(_asmcryptoLite2.default.AES_GCM.decrypt(ciphertext, key, iv));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
options = {
    message: openpgp.message.read(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.<span class="apidocCodeKeywordSpan">decrypt</span>(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
```

#### Encrypt and decrypt *String* data with PGP keys

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.gcm.encrypt" id="apidoc.element.openpgp.crypto.gcm.encrypt">
        function <span class="apidocSignatureSpan">openpgp.crypto.gcm.</span>encrypt
        <span class="apidocSignatureSpan">(cipher, plaintext, key, iv)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encrypt(cipher, plaintext, key, iv) {
  if (cipher.substr(0, 3) !== 'aes') {
    return Promise.reject(new Error('GCM mode supports only AES cipher'));
  }

  if (webCrypto &amp;&amp; _config2.default.use_native &amp;&amp; key.length !== 24) {
    // WebCrypto (no 192 bit support) see: https://www.chromium.org/blink/webcrypto#TOC-AES-support
    return webEncrypt(plaintext, key, iv);
  } else if (nodeCrypto &amp;&amp; _config2.default.use_native) {
    // Node crypto library
    return nodeEncrypt(plaintext, key, iv);
  } else {
    // asm.js fallback
    return Promise.resolve(_asmcryptoLite2.default.AES_GCM.encrypt(plaintext, key, iv));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.<span class="apidocCodeKeywordSpan">encrypt</span>(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.crypto.hash" id="apidoc.module.openpgp.crypto.hash">module openpgp.crypto.hash</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.crypto.hash.digest" id="apidoc.element.openpgp.crypto.hash.digest">
        function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>digest
        <span class="apidocSignatureSpan">(algo, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function digest(algo, data) {
  switch (algo) {
    case 1:
      // - MD5 [HAC]
      return this.md5(data);
    case 2:
      // - SHA-1 [FIPS180]
      return this.sha1(data);
    case 3:
      // - RIPE-MD/160 [HAC]
      return this.ripemd(data);
    case 8:
      // - SHA256 [FIPS180]
      return this.sha256(data);
    case 9:
      // - SHA384 [FIPS180]
      return this.sha384(data);
    case 10:
      // - SHA512 [FIPS180]
      return this.sha512(data);
    case 11:
      // - SHA224 [FIPS180]
      return this.sha224(data);
    default:
      throw new Error('Invalid hash function.');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// messages containing a jobid and a buffer
// or blob object, and return the hash result.
if (typeof FileReaderSync !== 'undefined') {
    var reader = new FileReaderSync(), hasher = new Rusha(4 * 1024 * 1024);
    self.onmessage = function onMessage(event) {
        var hash, data = event.data.data;
        try {
            hash = hasher.<span class="apidocCodeKeywordSpan">digest</span>(data);
            self.postMessage({
                id: event.data.id,
                hash: hash
            });
        } catch (e) {
            self.postMessage({
                id: event.data.id,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.hash.getHashByteLength" id="apidoc.element.openpgp.crypto.hash.getHashByteLength">
        function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>getHashByteLength
        <span class="apidocSignatureSpan">(algo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getHashByteLength(algo) {
  switch (algo) {
    case 1:
      // - MD5 [HAC]
      return 16;
    case 2:
    // - SHA-1 [FIPS180]
    case 3:
      // - RIPE-MD/160 [HAC]
      return 20;
    case 8:
      // - SHA256 [FIPS180]
      return 32;
    case 9:
      // - SHA384 [FIPS180]
      return 48;
    case 10:
      // - SHA512 [FIPS180]
      return 64;
    case 11:
      // - SHA224 [FIPS180]
      return 28;
    default:
      throw new Error('Invalid hash algorithm.');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Integer} emLen intended length in octets of the encoded message
 * @returns {String} encoded message
 */
encode: function encode(algo, M, emLen) {
  var i;
  // Apply the hash function to the message M to produce a hash value H
  var H = _util2.default.Uint8Array2str(_hash2.default.digest(algo, _util2.default.str2Uint8Array(M)));
  if (H.length !== _hash2.default.<span class="apidocCodeKeywordSpan">getHashByteLength</span>(algo)) {
    throw new Error('Invalid hash length');
  }
  // produce an ASN.1 DER value for the hash function used.
  // Let T be the full hash prefix
  var T = '';
  for (i = 0; i &lt; hash_headers[algo].length; i++) {
    T += String.fromCharCode(hash_headers[algo][i]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.hash.md5" id="apidoc.element.openpgp.crypto.hash.md5">
        function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>md5
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">md5 = function (data) {
  var shasum = nodeCrypto.createHash(type);
  shasum.update(new Buffer(data));
  return new Uint8Array(shasum.digest());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Uint8Array} data Data to be hashed
 * @return {Uint8Array} hash value
 */
digest: function digest(algo, data) {
  switch (algo) {
    case 1:
      // - MD5 [HAC]
      return this.<span class="apidocCodeKeywordSpan">md5</span>(data);
    case 2:
      // - SHA-1 [FIPS180]
      return this.sha1(data);
    case 3:
      // - RIPE-MD/160 [HAC]
      return this.ripemd(data);
    case 8:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.hash.ripemd" id="apidoc.element.openpgp.crypto.hash.ripemd">
        function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>ripemd
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ripemd = function (data) {
  var shasum = nodeCrypto.createHash(type);
  shasum.update(new Buffer(data));
  return new Uint8Array(shasum.digest());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // - MD5 [HAC]
  return this.md5(data);
case 2:
  // - SHA-1 [FIPS180]
  return this.sha1(data);
case 3:
  // - RIPE-MD/160 [HAC]
  return this.<span class="apidocCodeKeywordSpan">ripemd</span>(data);
case 8:
  // - SHA256 [FIPS180]
  return this.sha256(data);
case 9:
  // - SHA384 [FIPS180]
  return this.sha384(data);
case 10:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.hash.sha1" id="apidoc.element.openpgp.crypto.hash.sha1">
        function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>sha1
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sha1 = function (data) {
  var shasum = nodeCrypto.createHash(type);
  shasum.update(new Buffer(data));
  return new Uint8Array(shasum.digest());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  digest: function digest(algo, data) {
switch (algo) {
  case 1:
    // - MD5 [HAC]
    return this.md5(data);
  case 2:
    // - SHA-1 [FIPS180]
    return this.<span class="apidocCodeKeywordSpan">sha1</span>(data);
  case 3:
    // - RIPE-MD/160 [HAC]
    return this.ripemd(data);
  case 8:
    // - SHA256 [FIPS180]
    return this.sha256(data);
  case 9:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.hash.sha224" id="apidoc.element.openpgp.crypto.hash.sha224">
        function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>sha224
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sha224 = function (data) {
  var shasum = nodeCrypto.createHash(type);
  shasum.update(new Buffer(data));
  return new Uint8Array(shasum.digest());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      // - SHA384 [FIPS180]
      return this.sha384(data);
    case 10:
      // - SHA512 [FIPS180]
      return this.sha512(data);
    case 11:
      // - SHA224 [FIPS180]
      return this.<span class="apidocCodeKeywordSpan">sha224</span>(data);
    default:
      throw new Error('Invalid hash function.');
  }
},

/**
 * Returns the hash size in bytes of the specified hash algorithm type
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.hash.sha256" id="apidoc.element.openpgp.crypto.hash.sha256">
        function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>sha256
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sha256 = function (data) {
  var shasum = nodeCrypto.createHash(type);
  shasum.update(new Buffer(data));
  return new Uint8Array(shasum.digest());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // - SHA-1 [FIPS180]
  return this.sha1(data);
case 3:
  // - RIPE-MD/160 [HAC]
  return this.ripemd(data);
case 8:
  // - SHA256 [FIPS180]
  return this.<span class="apidocCodeKeywordSpan">sha256</span>(data);
case 9:
  // - SHA384 [FIPS180]
  return this.sha384(data);
case 10:
  // - SHA512 [FIPS180]
  return this.sha512(data);
case 11:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.hash.sha384" id="apidoc.element.openpgp.crypto.hash.sha384">
        function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>sha384
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sha384 = function (data) {
  var shasum = nodeCrypto.createHash(type);
  shasum.update(new Buffer(data));
  return new Uint8Array(shasum.digest());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // - RIPE-MD/160 [HAC]
  return this.ripemd(data);
case 8:
  // - SHA256 [FIPS180]
  return this.sha256(data);
case 9:
  // - SHA384 [FIPS180]
  return this.<span class="apidocCodeKeywordSpan">sha384</span>(data);
case 10:
  // - SHA512 [FIPS180]
  return this.sha512(data);
case 11:
  // - SHA224 [FIPS180]
  return this.sha224(data);
default:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.hash.sha512" id="apidoc.element.openpgp.crypto.hash.sha512">
        function <span class="apidocSignatureSpan">openpgp.crypto.hash.</span>sha512
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sha512 = function (data) {
  var shasum = nodeCrypto.createHash(type);
  shasum.update(new Buffer(data));
  return new Uint8Array(shasum.digest());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      // - SHA256 [FIPS180]
      return this.sha256(data);
    case 9:
      // - SHA384 [FIPS180]
      return this.sha384(data);
    case 10:
      // - SHA512 [FIPS180]
      return this.<span class="apidocCodeKeywordSpan">sha512</span>(data);
    case 11:
      // - SHA224 [FIPS180]
      return this.sha224(data);
    default:
      throw new Error('Invalid hash function.');
  }
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.crypto.publicKey" id="apidoc.module.openpgp.crypto.publicKey">module openpgp.crypto.publicKey</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.crypto.publicKey.dsa" id="apidoc.element.openpgp.crypto.publicKey.dsa">
        function <span class="apidocSignatureSpan">openpgp.crypto.publicKey.</span>dsa
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DSA() {
  // s1 = ((g**s) mod p) mod q
  // s1 = ((s**-1)*(sha-1(m)+(s1*x) mod q)
  function sign(hashalgo, m, g, p, q, x) {
    // If the output size of the chosen hash is larger than the number of
    // bits of q, the hash result is truncated to fit by taking the number
    // of leftmost bits equal to the number of bits of q.  This (possibly
    // truncated) hash function result is treated as a number and used
    // directly in the DSA signature algorithm.
    var hashed_data = _util2.default.getLeftNBits(_util2.default.Uint8Array2str(_hash2.default.digest(hashalgo, _util2.default.str2Uint8Array
(m))), q.bitLength());
    var hash = new _jsbn2.default(_util2.default.hexstrdump(hashed_data), 16);
    // FIPS-186-4, section 4.6:
    // The values of r and s shall be checked to determine if r = 0 or s = 0.
    // If either r = 0 or s = 0, a new value of k shall be generated, and the
    // signature shall be recalculated. It is extremely unlikely that r = 0
    // or s = 0 if signatures are generated properly.
    var k, s1, s2;
    while (true) {
      k = _random2.default.getRandomBigIntegerInRange(_jsbn2.default.ONE, q.subtract(_jsbn2.default.ONE));
      s1 = g.modPow(k, p).mod(q);
      s2 = k.modInverse(q).multiply(hash.add(x.multiply(s1))).mod(q);
      if (s1 !== 0 &amp;&amp; s2 !== 0) {
        break;
      }
    }
    var result = [];
    result[0] = s1.toMPI();
    result[1] = s2.toMPI();
    return result;
  }

  function select_hash_algorithm(q) {
    var usersetting = _config2.default.prefer_hash_algorithm;
<span class="apidocCodeCommentSpan">    /*
     * 1024-bit key, 160-bit q, SHA-1, SHA-224, SHA-256, SHA-384, or SHA-512 hash
     * 2048-bit key, 224-bit q, SHA-224, SHA-256, SHA-384, or SHA-512 hash
     * 2048-bit key, 256-bit q, SHA-256, SHA-384, or SHA-512 hash
     * 3072-bit key, 256-bit q, SHA-256, SHA-384, or SHA-512 hash
     */
</span>    switch (Math.round(q.bitLength() / 8)) {
      case 20:
        // 1024 bit
        if (usersetting !== 2 &amp;&amp; usersetting &gt; 11 &amp;&amp; usersetting !== 10 &amp;&amp; usersetting &lt; 8) {
          return 2; // prefer sha1
        }
        return usersetting;
      case 28:
        // 2048 bit
        if (usersetting &gt; 11 &amp;&amp; usersetting &lt; 8) {
          return 11;
        }
        return usersetting;
      case 32:
        // 4096 bit // prefer sha224
        if (usersetting &gt; 10 &amp;&amp; usersetting &lt; 8) {
          return 8; // prefer sha256
        }
        return usersetting;
      default:
        _util2.default.print_debug("DSA select hash algorithm: returning null for an unknown length of q");
        return null;
    }
  }
  this.select_hash_algorithm = select_hash_algorithm;

  function verify(hashalgo, s1, s2, m, p, q, g, y) {
    var hashed_data = _util2.default.getLeftNBits(_util2.default.Uint8Array2str(_hash2.default.digest(hashalgo, _util2.default.str2Uint8Array
(m))), q.bitLength());
    var hash = new _jsbn2.default(_util2.default.hexstrdump(hashed_data), 16);
    if (_jsbn2.default.ZERO.compareTo(s1) &gt;= 0 || s1.compareTo(q) &gt;= 0 || _jsbn2.default.ZERO.compareTo(s2) &gt;= 0 || s2.compareTo
(q) &gt;= 0) {
      _util2.default.print_debug("invalid DSA Signature");
      return null;
    }
    var w = s2.modInverse(q);
    if (_jsbn2.default.ZERO.compareTo(w) === 0) {
      _util2.default.print_debug("invalid DSA Signature");
      return null;
    }
    var u1 = hash.multiply(w).mod(q);
    var u2 = s1.multiply(w).mod(q);
    return g.modPow(u1, p).multiply(y.modPow(u2, p)).mod(p).mod(q);
  }

  this.sign = sign;
  this.verify = verify;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var EM2 = _pkcs2.default.emsa.encode(hash_algo, data, k);
  return EM.compareTo(EM2) === 0;
case 16:
  // Elgamal (Encrypt-Only) [ELGAMAL] [HAC]
  throw new Error("signing with Elgamal is not defined in the OpenPGP standard.");
case 17:
  // DSA (Digital Signature Algorithm) [FIPS186] [HAC]
  var dsa = new _public_key2.default.<span class="apidocCodeKeywordSpan">dsa</span>();
  var s1 = msg_MPIs[0].toBigInteger();
  var s2 = msg_MPIs[1].toBigInteger();
  var p = publickey_MPIs[0].toBigInteger();
  var q = publickey_MPIs[1].toBigInteger();
  var g = publickey_MPIs[2].toBigInteger();
  var y = publickey_MPIs[3].toBigInteger();
  m = data;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.publicKey.elgamal" id="apidoc.element.openpgp.crypto.publicKey.elgamal">
        function <span class="apidocSignatureSpan">openpgp.crypto.publicKey.</span>elgamal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Elgamal() {

  function encrypt(m, g, p, y) {
    //  choose k in {2,...,p-2}
    var pMinus2 = p.subtract(_jsbn2.default.TWO);
    var k = _random2.default.getRandomBigIntegerInRange(_jsbn2.default.ONE, pMinus2);
    k = k.mod(pMinus2).add(_jsbn2.default.ONE);
    var c = [];
    c[0] = g.modPow(k, p);
    c[1] = y.modPow(k, p).multiply(m).mod(p);
    return c;
  }

  function decrypt(c1, c2, p, x) {
    _util2.default.print_debug("Elgamal Decrypt:\nc1:" + _util2.default.hexstrdump(c1.toMPI()) + "\n" + "c2:" + _util2.default.hexstrdump
(c2.toMPI()) + "\n" + "p:" + _util2.default.hexstrdump(p.toMPI()) + "\n" + "x:" + _util2.default.hexstrdump(x.toMPI()));
    return c1.modPow(x, p).modInverse(p).multiply(c2).mod(p);
    //var c = c1.pow(x).modInverse(p); // c0^-a mod p
    //return c.multiply(c2).mod(p);
  }

  // signing and signature verification using Elgamal is not required by OpenPGP.
  this.encrypt = encrypt;
  this.decrypt = decrypt;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var rsa = new _public_key2.default.rsa();
  var n = publicMPIs[0].toBigInteger();
  var e = publicMPIs[1].toBigInteger();
  m = data.toBigInteger();
  return [rsa.encrypt(m, e, n)];

case 'elgamal':
  var elgamal = new _public_key2.default.<span class="apidocCodeKeywordSpan">elgamal</span>();
  var p = publicMPIs[0].toBigInteger();
  var g = publicMPIs[1].toBigInteger();
  var y = publicMPIs[2].toBigInteger();
  m = data.toBigInteger();
  return elgamal.encrypt(m, g, p, y);

default:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.publicKey.rsa" id="apidoc.element.openpgp.crypto.publicKey.rsa">
        function <span class="apidocSignatureSpan">openpgp.crypto.publicKey.</span>rsa
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RSA() {
<span class="apidocCodeCommentSpan">  /**
   * This function uses jsbn Big Num library to decrypt RSA
   * @param m
   *            message
   * @param n
   *            RSA public modulus n as BigInteger
   * @param e
   *            RSA public exponent as BigInteger
   * @param d
   *            RSA d as BigInteger
   * @param p
   *            RSA p as BigInteger
   * @param q
   *            RSA q as BigInteger
   * @param u
   *            RSA u as BigInteger
   * @return {BigInteger} The decrypted value of the message
   */
</span>  function decrypt(m, n, e, d, p, q, u) {
    if (_config2.default.rsa_blinding) {
      m = blind(m, n, e);
    }
    var xp = m.mod(p).modPow(d.mod(p.subtract(_jsbn2.default.ONE)), p);
    var xq = m.mod(q).modPow(d.mod(q.subtract(_jsbn2.default.ONE)), q);
    _util2.default.print_debug("rsa.js decrypt\nxpn:" + _util2.default.hexstrdump(xp.toMPI()) + "\nxqn:" + _util2.default.hexstrdump
(xq.toMPI()));

    var t = xq.subtract(xp);
    if (t[0] === 0) {
      t = xp.subtract(xq);
      t = t.multiply(u).mod(q);
      t = q.subtract(t);
    } else {
      t = t.multiply(u).mod(q);
    }
    t = t.multiply(p).add(xp);
    if (_config2.default.rsa_blinding) {
      t = unblind(t, n);
    }
    return t;
  }

  /**
   * encrypt message
   * @param m message as BigInteger
   * @param e public MPI part as BigInteger
   * @param n public MPI part as BigInteger
   * @return BigInteger
   */
  function encrypt(m, e, n) {
    return m.modPowInt(e, n);
  }

  /* Sign and Verify */
  function sign(m, d, n) {
    return m.modPow(d, n);
  }

  function verify(x, e, n) {
    return x.modPowInt(e, n);
  }

  // "empty" RSA key constructor

  function KeyObject() {
    this.n = null;
    this.e = 0;
    this.ee = null;
    this.d = null;
    this.p = null;
    this.q = null;
    this.dmp1 = null;
    this.dmq1 = null;
    this.u = null;
  }

  // Generate a new random private key B bits long, using public expt E

  function generate(B, E) {
    var webCrypto = _util2.default.getWebCryptoAll();

    //
    // Native RSA keygen using Web Crypto
    //

    if (webCrypto) {
      var Euint32 = new Uint32Array([parseInt(E, 16)]); // get integer of exponent
      var Euint8 = new Uint8Array(Euint32.buffer); // get bytes of exponent
      var keyGenOpt;

      var keys;
      if (window.crypto &amp;&amp; window.crypto.webkitSubtle) {
        // outdated spec implemented by Webkit
        keyGenOpt = {
          name: 'RSA-OAEP',
          modulusLength: B, // the specified keysize in bits
          publicExponent: Euint8.subarray(0, 3) // take three bytes (max 65537)
        };
        keys = webCrypto.generateKey(keyGenOpt, true, ['encrypt', 'decrypt']);
      } else {
        // current standard spec
        keyGenOpt = {
          name: 'RSASSA-PKCS1-v1_5',
          modulusLength: B, // the specified keysize in bits
          publicExponent: Euint8.subarray(0, 3), // take three bytes (max 65537)
          hash: {
            name: 'SHA-1' // not required for actual RSA keys, but for crypto api 'sign' and 'verify'
          }
        };

        keys = webCrypto.generateKey(keyGenOpt, true, ['sign', 'verify']);
        if (typeof keys.then !== 'function') {
          // IE11 KeyOperation
          keys = _util2.default.promisifyIE11Op(keys, 'Error generating RSA key pair.');
        }
      }

      return keys.then(exportKey).then(function (key) {
        if (key instanceof ArrayBuffer) {
          // parse raw ArrayBuffer bytes to jwk/json (WebKit/Safari/IE11 quirk)
          return decodeKey(JSON.parse(String.fromCharCode.apply(null, new Uint8Array(key))));
        }
        return decodeKey(key);
      });
    }

    function exportKey(keypair) {
      // export the generated keys as JsonWebKey (JWK)
      // https://tools.ietf.org/html/draft-ietf-jose-json-web-key-33
      var key = webCrypto.exportKey('jwk', keypair.privateKey);
      if (typeof key.then !== 'function') {
        // IE11 KeyOperation
        key = _util2.default.promisifyIE11Op(key, 'Error exporting RSA key pair.');
      }
      return key;
    }

    function decode ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   */
  publicKeyEncrypt: function publicKeyEncrypt(algo, publicMPIs, data) {
    var result = function () {
      var m;
      switch (algo) {
case 'rsa_encrypt':
case 'rsa_encrypt_sign':
  var rsa = new _public_key2.default.<span class="apidocCodeKeywordSpan">rsa</span>();
  var n = publicMPIs[0].toBigInteger();
  var e = publicMPIs[1].toBigInteger();
  m = data.toBigInteger();
  return [rsa.encrypt(m, e, n)];

case 'elgamal':
  var elgamal = new _public_key2.default.elgamal();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.crypto.random" id="apidoc.module.openpgp.crypto.random">module openpgp.crypto.random</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.crypto.random.getRandomBigInteger" id="apidoc.element.openpgp.crypto.random.getRandomBigInteger">
        function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getRandomBigInteger
        <span class="apidocSignatureSpan">(bits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRandomBigInteger(bits) {
  if (bits &lt; 1) {
    throw new Error('Illegal parameter value: bits &lt; 1');
  }
  var numBytes = Math.floor((bits + 7) / 8);

  var randomBits = _util2.default.Uint8Array2str(this.getRandomBytes(numBytes));
  if (bits % 8 &gt; 0) {

    randomBits = String.fromCharCode(Math.pow(2, bits % 8) - 1 &amp; randomBits.charCodeAt(0)) + randomBits.substring(1);
  }
  var mpi = new _mpi2.default();
  mpi.fromBytes(randomBits);
  return mpi.toBigInteger();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

getRandomBigIntegerInRange: function getRandomBigIntegerInRange(min, max) {
  if (max.compareTo(min) &lt;= 0) {
    throw new Error('Illegal parameter value: max &lt;= min');
  }

  var range = max.subtract(min);
  var r = this.<span class="apidocCodeKeywordSpan">getRandomBigInteger</span>(range.bitLength());
  while (r.compareTo(range) &gt; 0) {
    r = this.getRandomBigInteger(range.bitLength());
  }
  return min.add(r);
},

randomBuffer: new RandomBuffer()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.random.getRandomBigIntegerInRange" id="apidoc.element.openpgp.crypto.random.getRandomBigIntegerInRange">
        function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getRandomBigIntegerInRange
        <span class="apidocSignatureSpan">(min, max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRandomBigIntegerInRange(min, max) {
  if (max.compareTo(min) &lt;= 0) {
    throw new Error('Illegal parameter value: max &lt;= min');
  }

  var range = max.subtract(min);
  var r = this.getRandomBigInteger(range.bitLength());
  while (r.compareTo(range) &gt; 0) {
    r = this.getRandomBigInteger(range.bitLength());
  }
  return min.add(r);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// FIPS-186-4, section 4.6:
// The values of r and s shall be checked to determine if r = 0 or s = 0.
// If either r = 0 or s = 0, a new value of k shall be generated, and the
// signature shall be recalculated. It is extremely unlikely that r = 0
// or s = 0 if signatures are generated properly.
var k, s1, s2;
while (true) {
  k = _random2.default.<span class="apidocCodeKeywordSpan">getRandomBigIntegerInRange</span>(_jsbn2.default.ONE, q.subtract(_jsbn2
.default.ONE));
  s1 = g.modPow(k, p).mod(q);
  s2 = k.modInverse(q).multiply(hash.add(x.multiply(s1))).mod(q);
  if (s1 !== 0 &amp;&amp; s2 !== 0) {
    break;
  }
}
var result = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.random.getRandomBytes" id="apidoc.element.openpgp.crypto.random.getRandomBytes">
        function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getRandomBytes
        <span class="apidocSignatureSpan">(length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRandomBytes(length) {
  var result = new Uint8Array(length);
  for (var i = 0; i &lt; length; i++) {
    result[i] = this.getSecureRandomOctet();
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * generate random byte prefix as string for the specified algorithm
 * @param {module:enums.symmetric} algo Algorithm to use (see {@link http://tools.ietf.org/html/rfc4880#section-9.2|RFC 4880 9.2
})
 * @return {Uint8Array} Random bytes with length equal to the block
 * size of the cipher
 */
getPrefixRandom: function getPrefixRandom(algo) {
  return _random2.default.<span class="apidocCodeKeywordSpan">getRandomBytes</span>(_cipher2.default[algo].blockSize);
},

/**
 * Generating a session key for the specified symmetric algorithm
 * @param {module:enums.symmetric} algo Algorithm to use (see {@link http://tools.ietf.org/html/rfc4880#section-9.2|RFC 4880 9.2
})
 * @return {Uint8Array} Random bytes as a string to be used as a key
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.random.getRandomValues" id="apidoc.element.openpgp.crypto.random.getRandomValues">
        function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getRandomValues
        <span class="apidocSignatureSpan">(buf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getRandomValues(buf) {
  if (!(buf instanceof Uint8Array)) {
    throw new Error('Invalid type: buf not an Uint8Array');
  }
  if (typeof window !== 'undefined' &amp;&amp; window.crypto &amp;&amp; window.crypto.getRandomValues) {
    window.crypto.getRandomValues(buf);
  } else if (typeof window !== 'undefined' &amp;&amp; _typeof(window.msCrypto) === 'object' &amp;&amp; typeof window.msCrypto.getRandomValues === '
function') {
    window.msCrypto.getRandomValues(buf);
  } else if (nodeCrypto) {
    var bytes = nodeCrypto.randomBytes(buf.length);
    buf.set(bytes);
  } else if (this.randomBuffer.buffer) {
    this.randomBuffer.get(buf);
  } else {
    throw new Error('No secure random number generator available.');
  }
  return buf;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    randUint = this.getSecureRandomUint();
  }
  return from + Math.abs(randUint &amp; Math.pow(2, bits) - 1);
},

getSecureRandomOctet: function getSecureRandomOctet() {
  var buf = new Uint8Array(1);
  this.<span class="apidocCodeKeywordSpan">getRandomValues</span>(buf);
  return buf[0];
},

getSecureRandomUint: function getSecureRandomUint() {
  var buf = new Uint8Array(4);
  var dv = new DataView(buf.buffer);
  this.getRandomValues(buf);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.random.getSecureRandom" id="apidoc.element.openpgp.crypto.random.getSecureRandom">
        function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getSecureRandom
        <span class="apidocSignatureSpan">(from, to)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSecureRandom(from, to) {
  var randUint = this.getSecureRandomUint();
  var bits = (to - from).toString(2).length;
  while ((randUint &amp; Math.pow(2, bits) - 1) &gt; to - from) {
    randUint = this.getSecureRandomUint();
  }
  return from + Math.abs(randUint &amp; Math.pow(2, bits) - 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.random.getSecureRandomOctet" id="apidoc.element.openpgp.crypto.random.getSecureRandomOctet">
        function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getSecureRandomOctet
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSecureRandomOctet() {
  var buf = new Uint8Array(1);
  this.getRandomValues(buf);
  return buf[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {Integer} length Length of the padding in bytes
 * @return {String}        Padding as string
 */
function getPkcs1Padding(length) {
  var result = '';
  var randomByte;
  while (result.length &lt; length) {
    randomByte = _random2.default.<span class="apidocCodeKeywordSpan">getSecureRandomOctet</span>();
    if (randomByte !== 0) {
      result += String.fromCharCode(randomByte);
    }
  }
  return result;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.random.getSecureRandomUint" id="apidoc.element.openpgp.crypto.random.getSecureRandomUint">
        function <span class="apidocSignatureSpan">openpgp.crypto.random.</span>getSecureRandomUint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSecureRandomUint() {
  var buf = new Uint8Array(4);
  var dv = new DataView(buf.buffer);
  this.getRandomValues(buf);
  return dv.getUint32(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Return a secure random number in the specified range
 * @param {Integer} from Min of the random number
 * @param {Integer} to Max of the random number (max 32bit)
 * @return {Integer} A secure random number
 */
getSecureRandom: function getSecureRandom(from, to) {
  var randUint = this.<span class="apidocCodeKeywordSpan">getSecureRandomUint</span>();
  var bits = (to - from).toString(2).length;
  while ((randUint &amp; Math.pow(2, bits) - 1) &gt; to - from) {
    randUint = this.getSecureRandomUint();
  }
  return from + Math.abs(randUint &amp; Math.pow(2, bits) - 1);
},
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.crypto.signature" id="apidoc.module.openpgp.crypto.signature">module openpgp.crypto.signature</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.crypto.signature.sign" id="apidoc.element.openpgp.crypto.signature.sign">
        function <span class="apidocSignatureSpan">openpgp.crypto.signature.</span>sign
        <span class="apidocSignatureSpan">(hash_algo, algo, keyIntegers, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sign(hash_algo, algo, keyIntegers, data) {

  data = _util2.default.Uint8Array2str(data);

  var m;

  switch (algo) {
    case 1:
    // RSA (Encrypt or Sign) [HAC]
    case 2:
    // RSA Encrypt-Only [HAC]
    case 3:
      // RSA Sign-Only [HAC]
      var rsa = new _public_key2.default.rsa();
      var d = keyIntegers[2].toBigInteger();
      var n = keyIntegers[0].toBigInteger();
      m = _pkcs2.default.emsa.encode(hash_algo, data, keyIntegers[0].byteLength());
      return _util2.default.str2Uint8Array(rsa.sign(m, d, n).toMPI());

    case 17:
      // DSA (Digital Signature Algorithm) [FIPS186] [HAC]
      var dsa = new _public_key2.default.dsa();

      var p = keyIntegers[0].toBigInteger();
      var q = keyIntegers[1].toBigInteger();
      var g = keyIntegers[2].toBigInteger();
      var x = keyIntegers[4].toBigInteger();
      m = data;
      var result = dsa.sign(hash_algo, m, g, p, q, x);

      return _util2.default.str2Uint8Array(result[0].toString() + result[1].toString());
    case 16:
      // Elgamal (Encrypt-Only) [ELGAMAL] [HAC]
      throw new Error('Signing with Elgamal is not defined in the OpenPGP standard.');
    default:
      throw new Error('Invalid signature algorithm.');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
options = {
data: 'Hello, World!',                             // input as String (or Uint8Array)
privateKeys: privKeyObj // for signing
};

openpgp.<span class="apidocCodeKeywordSpan">sign</span>(options).then(function(signed) {
cleartext = signed.data; // '-----BEGIN PGP SIGNED MESSAGE ... END PGP SIGNATURE-----'
});
```

```js
options = {
message: openpgp.cleartext.readArmored(cleartext), // parse armored message
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.crypto.signature.verify" id="apidoc.element.openpgp.crypto.signature.verify">
        function <span class="apidocSignatureSpan">openpgp.crypto.signature.</span>verify
        <span class="apidocSignatureSpan">(algo, hash_algo, msg_MPIs, publickey_MPIs, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function verify(algo, hash_algo, msg_MPIs, publickey_MPIs, data) {
  var m;

  data = _util2.default.Uint8Array2str(data);

  switch (algo) {
    case 1:
    // RSA (Encrypt or Sign) [HAC]
    case 2:
    // RSA Encrypt-Only [HAC]
    case 3:
      // RSA Sign-Only [HAC]
      var rsa = new _public_key2.default.rsa();
      var n = publickey_MPIs[0].toBigInteger();
      var k = publickey_MPIs[0].byteLength();
      var e = publickey_MPIs[1].toBigInteger();
      m = msg_MPIs[0].toBigInteger();
      var EM = rsa.verify(m, e, n);
      var EM2 = _pkcs2.default.emsa.encode(hash_algo, data, k);
      return EM.compareTo(EM2) === 0;
    case 16:
      // Elgamal (Encrypt-Only) [ELGAMAL] [HAC]
      throw new Error("signing with Elgamal is not defined in the OpenPGP standard.");
    case 17:
      // DSA (Digital Signature Algorithm) [FIPS186] [HAC]
      var dsa = new _public_key2.default.dsa();
      var s1 = msg_MPIs[0].toBigInteger();
      var s2 = msg_MPIs[1].toBigInteger();
      var p = publickey_MPIs[0].toBigInteger();
      var q = publickey_MPIs[1].toBigInteger();
      var g = publickey_MPIs[2].toBigInteger();
      var y = publickey_MPIs[3].toBigInteger();
      m = data;
      var dopublic = dsa.verify(hash_algo, s1, s2, m, p, q, g, y);
      return dopublic.compareTo(s1) === 0;
    default:
      throw new Error('Invalid signature algorithm.');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
options = {
    message: openpgp.cleartext.readArmored(cleartext), // parse armored message
    publicKeys: openpgp.key.readArmored(pubkey).keys   // for verification
};

openpgp.<span class="apidocCodeKeywordSpan">verify</span>(options).then(function(verified) {
	validity = verified.signatures[0].valid; // true
	if (validity) {
		console.log('signed by key id ' + verified.signatures[0].keyid.toHex());
	}
});
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.default" id="apidoc.module.openpgp.default">module openpgp.default</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.default.decrypt" id="apidoc.element.openpgp.default.decrypt">
        function <span class="apidocSignatureSpan">openpgp.default.</span>decrypt
        <span class="apidocSignatureSpan">(_ref6)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decrypt(_ref6) {
  var message = _ref6.message;
  var privateKey = _ref6.privateKey;
  var publicKeys = _ref6.publicKeys;
  var sessionKey = _ref6.sessionKey;
  var password = _ref6.password;
  var _ref6$format = _ref6.format;
  var format = _ref6$format === undefined ? 'utf8' : _ref6$format;
  var _ref6$signature = _ref6.signature;
  var signature = _ref6$signature === undefined ? null : _ref6$signature;

  checkMessage(message);publicKeys = toArray(publicKeys);

  if (!nativeAEAD() &amp;&amp; asyncProxy) {
    // use web worker if web crypto apis are not supported
    return asyncProxy.delegate('decrypt', { message: message, privateKey: privateKey, publicKeys: publicKeys, sessionKey: sessionKey
, password: password, format: format, signature: signature });
  }

  return message.decrypt(privateKey, sessionKey, password).then(function (message) {

    var result = parseMessage(message, format);
    if (result.data) {
      // verify
      if (!publicKeys) {
        publicKeys = [];
      }
      if (signature) {
        //detached signature
        result.signatures = message.verifyDetached(signature, publicKeys);
      } else {
        result.signatures = message.verify(publicKeys);
      }
    }
    return result;
  }).catch(onError.bind(null, 'Error decrypting message'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
options = {
    message: openpgp.message.read(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.<span class="apidocCodeKeywordSpan">decrypt</span>(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
```

#### Encrypt and decrypt *String* data with PGP keys

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.default.decryptKey" id="apidoc.element.openpgp.default.decryptKey">
        function <span class="apidocSignatureSpan">openpgp.default.</span>decryptKey
        <span class="apidocSignatureSpan">(_ref4)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decryptKey(_ref4) {
  var privateKey = _ref4.privateKey;
  var passphrase = _ref4.passphrase;

  if (asyncProxy) {
    // use web worker if available
    return asyncProxy.delegate('decryptKey', { privateKey: privateKey, passphrase: passphrase });
  }

  return execute(function () {

    if (!privateKey.decrypt(passphrase)) {
      throw new Error('Invalid passphrase');
    }
    return {
      key: privateKey
    };
  }, 'Error decrypting private key');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    expect(error.message).to.match(/not decrypted/);
    done();
  });
});

describe('decryptKey', function() {
  it('should work for correct passphrase', function(done) {
    openpgp.<span class="apidocCodeKeywordSpan">decryptKey</span>({
      privateKey: privateKey.keys[0],
      passphrase: passphrase
    }).then(function(unlocked){
      expect(unlocked.key.primaryKey.getKeyId().toHex()).to.equal(privateKey.keys[0].primaryKey.getKeyId().toHex());
      expect(unlocked.key.primaryKey.isDecrypted).to.be.true;
      done();
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.default.decryptSessionKey" id="apidoc.element.openpgp.default.decryptSessionKey">
        function <span class="apidocSignatureSpan">openpgp.default.</span>decryptSessionKey
        <span class="apidocSignatureSpan">(_ref10)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decryptSessionKey(_ref10) {
  var message = _ref10.message;
  var privateKey = _ref10.privateKey;
  var password = _ref10.password;

  checkMessage(message);

  if (asyncProxy) {
    // use web worker if available
    return asyncProxy.delegate('decryptSessionKey', { message: message, privateKey: privateKey, password: password });
  }

  return execute(function () {
    return message.decryptSessionKey(privateKey, password);
  }, 'Error decrypting session key');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {String} password     (optional) password used to decrypt
 * @return {Message}             new message with decrypted content
 */
Message.prototype.decrypt = function (privateKey, sessionKey, password) {
  var _this = this;

  return Promise.resolve().then(function () {
var keyObj = sessionKey || _this.<span class="apidocCodeKeywordSpan">decryptSessionKey</span>(privateKey, password);
if (!keyObj || !_util2.default.isUint8Array(keyObj.data) || !_util2.default.isString(keyObj.algorithm)) {
  throw new Error('Invalid session key for decryption.');
}

var symEncryptedPacketlist = _this.packets.filterByTag(_enums2.default.packet.symmetricallyEncrypted, _enums2.default.packet.symEncryptedIntegrityProtected
, _enums2.default.packet.symEncryptedAEADProtected);

if (symEncryptedPacketlist.length === 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.default.destroyWorker" id="apidoc.element.openpgp.default.destroyWorker">
        function <span class="apidocSignatureSpan">openpgp.default.</span>destroyWorker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function destroyWorker() {
  asyncProxy = undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var password1 = 'I am a password';
var password2 = 'I am another password';

describe('OpenPGP.js public api tests', function() {

  describe('initWorker, getWorker, destroyWorker - unit tests', function() {
afterEach(function() {
  openpgp.<span class="apidocCodeKeywordSpan">destroyWorker</span>(); // cleanup worker in case of failure
});

it('should work', function() {
  var workerStub = {
    postMessage: function() {}
  };
  openpgp.initWorker({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.default.encrypt" id="apidoc.element.openpgp.default.encrypt">
        function <span class="apidocSignatureSpan">openpgp.default.</span>encrypt
        <span class="apidocSignatureSpan">(_ref5)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encrypt(_ref5) {
  var data = _ref5.data;
  var publicKeys = _ref5.publicKeys;
  var privateKeys = _ref5.privateKeys;
  var passwords = _ref5.passwords;
  var filename = _ref5.filename;
  var _ref5$armor = _ref5.armor;
  var armor = _ref5$armor === undefined ? true : _ref5$armor;
  var _ref5$detached = _ref5.detached;
  var detached = _ref5$detached === undefined ? false : _ref5$detached;
  var _ref5$signature = _ref5.signature;
  var signature = _ref5$signature === undefined ? null : _ref5$signature;

  checkData(data);publicKeys = toArray(publicKeys);privateKeys = toArray(privateKeys);passwords = toArray(passwords);

  if (!nativeAEAD() &amp;&amp; asyncProxy) {
    // use web worker if web crypto apis are not supported
    return asyncProxy.delegate('encrypt', { data: data, publicKeys: publicKeys, privateKeys: privateKeys, passwords: passwords,
filename: filename, armor: armor, detached: detached, signature: signature });
  }
  var result = {};
  return Promise.resolve().then(function () {

    var message = createMessage(data, filename);
    if (!privateKeys) {
      privateKeys = [];
    }
    if (privateKeys.length || signature) {
      // sign the message only if private keys or signature is specified
      if (detached) {
        var detachedSignature = message.signDetached(privateKeys, signature);
        if (armor) {
          result.signature = detachedSignature.armor();
        } else {
          result.signature = detachedSignature;
        }
      } else {
        message = message.sign(privateKeys, signature);
      }
    }
    return message.encrypt(publicKeys, passwords);
  }).then(function (message) {
    if (armor) {
      result.data = message.armor();
    } else {
      result.message = message;
    }
    return result;
  }).catch(onError.bind(null, 'Error encrypting message'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.<span class="apidocCodeKeywordSpan">encrypt</span>(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.default.encryptSessionKey" id="apidoc.element.openpgp.default.encryptSessionKey">
        function <span class="apidocSignatureSpan">openpgp.default.</span>encryptSessionKey
        <span class="apidocSignatureSpan">(_ref9)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encryptSessionKey(_ref9) {
  var data = _ref9.data;
  var algorithm = _ref9.algorithm;
  var publicKeys = _ref9.publicKeys;
  var passwords = _ref9.passwords;

  checkbinary(data);checkString(algorithm, 'algorithm');publicKeys = toArray(publicKeys);passwords = toArray(passwords);

  if (asyncProxy) {
    // use web worker if available
    return asyncProxy.delegate('encryptSessionKey', { data: data, algorithm: algorithm, publicKeys: publicKeys, passwords: passwords
 });
  }

  return execute(function () {
    return {

      message: messageLib.encryptSessionKey(data, algorithm, publicKeys, passwords)

    };
  }, 'Error encrypting session key');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   // use web worker if available
   return asyncProxy.delegate('encryptSessionKey', { data: data, algorithm: algorithm, publicKeys: publicKeys, passwords
: passwords });
 }

 return execute(function () {
   return {

     message: messageLib.<span class="apidocCodeKeywordSpan">encryptSessionKey</span>(data, algorithm, publicKeys, passwords)

   };
 }, 'Error encrypting session key');
}

/**
* Decrypt a symmetric session key with a private key or password. Either a private key or
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.default.generateKey" id="apidoc.element.openpgp.default.generateKey">
        function <span class="apidocSignatureSpan">openpgp.default.</span>generateKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generateKey() {
  var _ref2 = arguments.length &lt;= 0 || arguments[0] === undefined ? {} : arguments[0];

  var _ref2$userIds = _ref2.userIds;
  var userIds = _ref2$userIds === undefined ? [] : _ref2$userIds;
  var passphrase = _ref2.passphrase;
  var _ref2$numBits = _ref2.numBits;
  var numBits = _ref2$numBits === undefined ? 2048 : _ref2$numBits;
  var _ref2$unlocked = _ref2.unlocked;
  var unlocked = _ref2$unlocked === undefined ? false : _ref2$unlocked;
  var _ref2$keyExpirationTi = _ref2.keyExpirationTime;
  var keyExpirationTime = _ref2$keyExpirationTi === undefined ? 0 : _ref2$keyExpirationTi;

  var options = formatUserIds({ userIds: userIds, passphrase: passphrase, numBits: numBits, unlocked: unlocked, keyExpirationTime
: keyExpirationTime });

  if (!_util2.default.getWebCryptoAll() &amp;&amp; asyncProxy) {
    // use web worker if web crypto apis are not supported
    return asyncProxy.delegate('generateKey', options);
  }

  return key.generate(options).then(function (newKey) {
    return {

      key: newKey,
      privateKeyArmored: newKey.armor(),
      publicKeyArmored: newKey.toPublic().armor()

    };
  }).catch(onError.bind(null, 'Error generating keypair'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var options = {
    userIds: [{ name:'Jon Smith', email:'jon@example.com' }], // multiple user IDs
    numBits: 4096,                                            // RSA key size
    passphrase: 'super long and hard to guess secret'         // protects the private key
};

openpgp.<span class="apidocCodeKeywordSpan">generateKey</span>(options).then(function(key) {
    var privkey = key.privateKeyArmored; // '-----BEGIN PGP PRIVATE KEY BLOCK ... '
    var pubkey = key.publicKeyArmored;   // '-----BEGIN PGP PUBLIC KEY BLOCK ... '
});
```

#### Lookup public key on HKP server
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.default.getWorker" id="apidoc.element.openpgp.default.getWorker">
        function <span class="apidocSignatureSpan">openpgp.default.</span>getWorker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getWorker() {
  return asyncProxy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  it('should work', function() {
    var workerStub = {
      postMessage: function() {}
    };
    openpgp.initWorker({
      worker: workerStub
    });
    expect(openpgp.<span class="apidocCodeKeywordSpan">getWorker</span>()).to.exist;
    openpgp.destroyWorker();
    expect(openpgp.getWorker()).to.not.exist;
  });
});

describe('generateKey - unit tests', function() {
  var keyGenStub, keyObjStub, getWebCryptoAllStub;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.default.initWorker" id="apidoc.element.openpgp.default.initWorker">
        function <span class="apidocSignatureSpan">openpgp.default.</span>initWorker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function initWorker() {
  var _ref = arguments.length &lt;= 0 || arguments[0] === undefined ? {} : arguments[0];

  var _ref$path = _ref.path;
  var path = _ref$path === undefined ? 'openpgp.worker.js' : _ref$path;
  var worker = _ref.worker;

  if (worker || typeof window !== 'undefined' &amp;&amp; window.Worker) {
    asyncProxy = new _async_proxy2.default({ path: path, worker: worker, config: _config2.default });
    return true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Here are some examples of how to use the v2.x api. For more elaborate examples and working code, please check out the [public api
 unit tests](https://github.com/openpgpjs/openpgpjs/blob/master/test/general/openpgp.js). If you're upgrading from v1.x it
might help to check out the [documentation](https://github.com/openpgpjs/openpgpjs#documentation).

#### Set up

```js
var openpgp = require('openpgp'); // use as CommonJS, AMD, ES6 module or via window.openpgp

openpgp.<span class="apidocCodeKeywordSpan">initWorker</span>({ path:'openpgp.worker.js' }) // set the relative web worker
 path

openpgp.config.aead_protect = true // activate fast AES-GCM mode (not yet OpenPGP standard)
```

#### Encrypt and decrypt *Uint8Array* data with a password

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.default.reformatKey" id="apidoc.element.openpgp.default.reformatKey">
        function <span class="apidocSignatureSpan">openpgp.default.</span>reformatKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reformatKey() {
  var _ref3 = arguments.length &lt;= 0 || arguments[0] === undefined ? {} : arguments[0];

  var privateKey = _ref3.privateKey;
  var _ref3$userIds = _ref3.userIds;
  var userIds = _ref3$userIds === undefined ? [] : _ref3$userIds;
  var _ref3$passphrase = _ref3.passphrase;
  var passphrase = _ref3$passphrase === undefined ? "" : _ref3$passphrase;
  var _ref3$unlocked = _ref3.unlocked;
  var unlocked = _ref3$unlocked === undefined ? false : _ref3$unlocked;
  var _ref3$keyExpirationTi = _ref3.keyExpirationTime;
  var keyExpirationTime = _ref3$keyExpirationTi === undefined ? 0 : _ref3$keyExpirationTi;

  var options = formatUserIds({ privateKey: privateKey, userIds: userIds, passphrase: passphrase, unlocked: unlocked, keyExpirationTime
: keyExpirationTime });

  if (asyncProxy) {
    return asyncProxy.delegate('reformatKey', options);
  }

  return key.reformat(options).then(function (newKey) {
    return {

      key: newKey,
      privateKeyArmored: newKey.armor(),
      publicKeyArmored: newKey.toPublic().armor()

    };
  }).catch(onError.bind(null, 'Error reformatting keypair'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.generateKey(opt).then(function(key) {
  key = key.key
  expect(key.users.length).to.equal(1);
  expect(key.users[0].userId.userid).to.equal(userId1);
  expect(key.primaryKey.isDecrypted).to.be.true;
  opt.privateKey = key;
  opt.userIds = userId2;
  openpgp.<span class="apidocCodeKeywordSpan">reformatKey</span>(opt).then(function(newKey) {
    newKey = newKey.key
    expect(newKey.users.length).to.equal(1);
    expect(newKey.users[0].userId.userid).to.equal(userId2);
    expect(newKey.primaryKey.isDecrypted).to.be.true;
    done();
  }).catch(done);
}).catch(done);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.default.sign" id="apidoc.element.openpgp.default.sign">
        function <span class="apidocSignatureSpan">openpgp.default.</span>sign
        <span class="apidocSignatureSpan">(_ref7)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sign(_ref7) {
  var data = _ref7.data;
  var privateKeys = _ref7.privateKeys;
  var _ref7$armor = _ref7.armor;
  var armor = _ref7$armor === undefined ? true : _ref7$armor;
  var _ref7$detached = _ref7.detached;
  var detached = _ref7$detached === undefined ? false : _ref7$detached;

  checkString(data);
  privateKeys = toArray(privateKeys);

  if (asyncProxy) {
    // use web worker if available
    return asyncProxy.delegate('sign', { data: data, privateKeys: privateKeys, armor: armor, detached: detached });
  }

  var result = {};
  return execute(function () {

    var cleartextMessage = new cleartext.CleartextMessage(data);

    if (detached) {
      var signature = cleartextMessage.signDetached(privateKeys);
      if (armor) {
        result.signature = signature.armor();
      } else {
        result.signature = signature;
      }
    } else {
      cleartextMessage.sign(privateKeys);
    }

    if (armor) {
      result.data = cleartextMessage.armor();
    } else {
      result.message = cleartextMessage;
    }
    return result;
  }, 'Error signing cleartext message');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
options = {
data: 'Hello, World!',                             // input as String (or Uint8Array)
privateKeys: privKeyObj // for signing
};

openpgp.<span class="apidocCodeKeywordSpan">sign</span>(options).then(function(signed) {
cleartext = signed.data; // '-----BEGIN PGP SIGNED MESSAGE ... END PGP SIGNATURE-----'
});
```

```js
options = {
message: openpgp.cleartext.readArmored(cleartext), // parse armored message
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.default.verify" id="apidoc.element.openpgp.default.verify">
        function <span class="apidocSignatureSpan">openpgp.default.</span>verify
        <span class="apidocSignatureSpan">(_ref8)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function verify(_ref8) {
  var message = _ref8.message;
  var publicKeys = _ref8.publicKeys;
  var _ref8$signature = _ref8.signature;
  var signature = _ref8$signature === undefined ? null : _ref8$signature;

  checkCleartextMessage(message);
  publicKeys = toArray(publicKeys);

  if (asyncProxy) {
    // use web worker if available
    return asyncProxy.delegate('verify', { message: message, publicKeys: publicKeys, signature: signature });
  }

  var result = {};
  return execute(function () {
    result.data = message.getText();

    if (signature) {
      //detached signature
      result.signatures = message.verifyDetached(signature, publicKeys);
    } else {
      result.signatures = message.verify(publicKeys);
    }
    return result;
  }, 'Error verifying cleartext signed message');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
options = {
    message: openpgp.cleartext.readArmored(cleartext), // parse armored message
    publicKeys: openpgp.key.readArmored(pubkey).keys   // for verification
};

openpgp.<span class="apidocCodeKeywordSpan">verify</span>(options).then(function(verified) {
	validity = verified.signatures[0].valid; // true
	if (validity) {
		console.log('signed by key id ' + verified.signatures[0].keyid.toHex());
	}
});
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.enums" id="apidoc.module.openpgp.enums">module openpgp.enums</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.enums.read" id="apidoc.element.openpgp.enums.read">
        function <span class="apidocSignatureSpan">openpgp.enums.</span>read
        <span class="apidocSignatureSpan">(type, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read(type, e) {
  for (var i in type) {
    if (type[i] === parseInt(e)) {
      return i;
    }
  }

  throw new Error('Invalid enum value.');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.enums.write" id="apidoc.element.openpgp.enums.write">
        function <span class="apidocSignatureSpan">openpgp.enums.</span>write
        <span class="apidocSignatureSpan">(type, e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function write(type, e) {
  if (typeof e === 'number') {
    e = this.read(type, e);
  }

  if (type[e] !== undefined) {
    return type[e];
  } else {
    throw new Error('Invalid enum value.');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.key" id="apidoc.module.openpgp.key">module openpgp.key</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.key.Key" id="apidoc.element.openpgp.key.Key">
        function <span class="apidocSignatureSpan">openpgp.key.</span>Key
        <span class="apidocSignatureSpan">(packetlist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Key(packetlist) {
  if (!(this instanceof Key)) {
    return new Key(packetlist);
  }
  // same data as in packetlist but in structured form
  this.primaryKey = null;
  this.revocationSignature = null;
  this.directSignatures = null;
  this.users = null;
  this.subKeys = null;
  this.packetlist2structure(packetlist);
  if (!this.primaryKey || !this.users) {
    throw new Error('Invalid key: need at least key and user ID packet');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    options.signature = packetlistCloneToSignature(options.signature);
  }
  return options;
}

function packetlistCloneToKey(clone) {
  var packetlist = _packetlist2.default.fromStructuredClone(clone);
  return new key.<span class="apidocCodeKeywordSpan">Key</span>(packetlist);
}

function packetlistCloneToMessage(clone) {
  var packetlist = _packetlist2.default.fromStructuredClone(clone);
  return new message.Message(packetlist);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.generate" id="apidoc.element.openpgp.key.generate">
        function <span class="apidocSignatureSpan">openpgp.key.</span>generate
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generate(options) {
  var secretKeyPacket, secretSubkeyPacket;
  return Promise.resolve().then(function () {
    options.keyType = options.keyType || _enums2.default.publicKey.rsa_encrypt_sign;
    if (options.keyType !== _enums2.default.publicKey.rsa_encrypt_sign) {
      // RSA Encrypt-Only and RSA Sign-Only are deprecated and SHOULD NOT be generated
      throw new Error('Only RSA Encrypt or Sign supported');
    }

    if (!options.passphrase) {
      // Key without passphrase is unlocked by definition
      options.unlocked = true;
    }
    if (String.prototype.isPrototypeOf(options.userIds) || typeof options.userIds === 'string') {
      options.userIds = [options.userIds];
    }

    return Promise.all([generateSecretKey(), generateSecretSubkey()]).then(function () {
      return wrapKeyObject(secretKeyPacket, secretSubkeyPacket, options);
    });
  });

  function generateSecretKey() {
    secretKeyPacket = new _packet2.default.SecretKey();
    secretKeyPacket.algorithm = _enums2.default.read(_enums2.default.publicKey, options.keyType);
    return secretKeyPacket.generate(options.numBits);
  }

  function generateSecretSubkey() {
    secretSubkeyPacket = new _packet2.default.SecretSubkey();
    secretSubkeyPacket.algorithm = _enums2.default.read(_enums2.default.publicKey, options.keyType);
    return secretSubkeyPacket.generate(options.numBits);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  generateMpi: function generateMpi(algo, bits) {
switch (algo) {
  case 'rsa_encrypt':
  case 'rsa_encrypt_sign':
  case 'rsa_sign':
    //remember "publicKey" refers to the crypto/public_key dir
    var rsa = new _public_key2.default.rsa();
    return rsa.<span class="apidocCodeKeywordSpan">generate</span>(bits, "10001").then(function (keyObject) {
      var output = [];
      output.push(keyObject.n);
      output.push(keyObject.ee);
      output.push(keyObject.d);
      output.push(keyObject.p);
      output.push(keyObject.q);
      output.push(keyObject.u);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.getPreferredSymAlgo" id="apidoc.element.openpgp.key.getPreferredSymAlgo">
        function <span class="apidocSignatureSpan">openpgp.key.</span>getPreferredSymAlgo
        <span class="apidocSignatureSpan">(keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getPreferredSymAlgo(keys) {
  var prioMap = {};
  keys.forEach(function (key) {
    var primaryUser = key.getPrimaryUser();
    if (!primaryUser || !primaryUser.selfCertificate.preferredSymmetricAlgorithms) {
      return _config2.default.encryption_cipher;
    }
    primaryUser.selfCertificate.preferredSymmetricAlgorithms.forEach(function (algo, index) {
      var entry = prioMap[algo] || (prioMap[algo] = { prio: 0, count: 0, algo: algo });
      entry.prio += 64 &gt;&gt; index;
      entry.count++;
    });
  });
  var prefAlgo = { prio: 0, algo: _config2.default.encryption_cipher };
  for (var algo in prioMap) {
    try {
      if (algo !== _enums2.default.symmetric.plaintext &amp;&amp; algo !== _enums2.default.symmetric.idea &amp;&amp; // not implemented
      _enums2.default.read(_enums2.default.symmetric, algo) &amp;&amp; // known algorithm
      prioMap[algo].count === keys.length &amp;&amp; // available for all keys
      prioMap[algo].prio &gt; prefAlgo.prio) {
        prefAlgo = prioMap[algo];
      }
    } catch (e) {}
  }
  return prefAlgo.algo;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var _this2 = this;

  var symAlgo = void 0,
  msg = void 0,
  symEncryptedPacket = void 0;
  return Promise.resolve().then(function () {
if (keys) {
  symAlgo = keyModule.<span class="apidocCodeKeywordSpan">getPreferredSymAlgo</span>(keys);
} else if (passwords) {
  symAlgo = _config2.default.encryption_cipher;
} else {
  throw new Error('No keys or passwords');
}

var sessionKey = _crypto2.default.generateSessionKey(_enums2.default.read(_enums2.default.symmetric, symAlgo));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.readArmored" id="apidoc.element.openpgp.key.readArmored">
        function <span class="apidocSignatureSpan">openpgp.key.</span>readArmored
        <span class="apidocSignatureSpan">(armoredText)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readArmored(armoredText) {
  var result = {};
  result.keys = [];
  try {
    var input = _armor2.default.decode(armoredText);
    if (!(input.type === _enums2.default.armor.public_key || input.type === _enums2.default.armor.private_key)) {
      throw new Error('Armored text not of type key');
    }
    var packetlist = new _packet2.default.List();
    packetlist.read(input.data);
    var keyIndex = packetlist.indexOfTag(_enums2.default.packet.publicKey, _enums2.default.packet.secretKey);
    if (keyIndex.length === 0) {
      throw new Error('No key packet found in armored text');
    }
    for (var i = 0; i &lt; keyIndex.length; i++) {
      var oneKeyList = packetlist.slice(keyIndex[i], keyIndex[i + 1]);
      try {
        var newKey = new Key(oneKeyList);
        result.keys.push(newKey);
      } catch (e) {
        result.err = result.err || [];
        result.err.push(e);
      }
    }
  } catch (e) {
    result.err = result.err || [];
    result.err.push(e);
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var options, encrypted;

var pubkey = '-----BEGIN PGP PUBLIC KEY BLOCK ... END PGP PUBLIC KEY BLOCK-----';
var privkey = '-----BEGIN PGP PRIVATE KEY BLOCK ... END PGP PRIVATE KEY BLOCK-----'; //encrypted private key
var passphrase = 'secret passphrase'; //what the privKey is encrypted with

var privKeyObj = openpgp.key.<span class="apidocCodeKeywordSpan">readArmored</span>(privkey).keys[0];
privKeyObj.decrypt(passphrase);

options = {
    data: 'Hello, World!',                             // input as String (or Uint8Array)
    publicKeys: openpgp.key.readArmored(pubkey).keys,  // for encryption
    privateKeys: privKeyObj // for signing (optional)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.reformat" id="apidoc.element.openpgp.key.reformat">
        function <span class="apidocSignatureSpan">openpgp.key.</span>reformat
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reformat(options) {
  var secretKeyPacket, secretSubkeyPacket;
  return Promise.resolve().then(function () {

    options.keyType = options.keyType || _enums2.default.publicKey.rsa_encrypt_sign;
    if (options.keyType !== _enums2.default.publicKey.rsa_encrypt_sign) {
      // RSA Encrypt-Only and RSA Sign-Only are deprecated and SHOULD NOT be generated
      throw new Error('Only RSA Encrypt or Sign supported');
    }

    if (!options.passphrase) {
      // Key without passphrase is unlocked by definition
      options.unlocked = true;
    }
    if (String.prototype.isPrototypeOf(options.userIds) || typeof options.userIds === 'string') {
      options.userIds = [options.userIds];
    }
    var packetlist = options.privateKey.toPacketlist();
    for (var i = 0; i &lt; packetlist.length; i++) {
      if (packetlist[i].tag === _enums2.default.packet.secretKey) {
        secretKeyPacket = packetlist[i];
      } else if (packetlist[i].tag === _enums2.default.packet.secretSubkey) {
        secretSubkeyPacket = packetlist[i];
      }
    }
    return wrapKeyObject(secretKeyPacket, secretSubkeyPacket, options);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var options = formatUserIds({ privateKey: privateKey, userIds: userIds, passphrase: passphrase, unlocked: unlocked, keyExpirationTime
: keyExpirationTime });

  if (asyncProxy) {
return asyncProxy.delegate('reformatKey', options);
  }

  return key.<span class="apidocCodeKeywordSpan">reformat</span>(options).then(function (newKey) {
return {

  key: newKey,
  privateKeyArmored: newKey.armor(),
  publicKeyArmored: newKey.toPublic().armor()

};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.key.Key" id="apidoc.module.openpgp.key.Key">module openpgp.key.Key</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.key.Key.Key" id="apidoc.element.openpgp.key.Key.Key">
        function <span class="apidocSignatureSpan">openpgp.key.</span>Key
        <span class="apidocSignatureSpan">(packetlist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Key(packetlist) {
  if (!(this instanceof Key)) {
    return new Key(packetlist);
  }
  // same data as in packetlist but in structured form
  this.primaryKey = null;
  this.revocationSignature = null;
  this.directSignatures = null;
  this.users = null;
  this.subKeys = null;
  this.packetlist2structure(packetlist);
  if (!this.primaryKey || !this.users) {
    throw new Error('Invalid key: need at least key and user ID packet');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    options.signature = packetlistCloneToSignature(options.signature);
  }
  return options;
}

function packetlistCloneToKey(clone) {
  var packetlist = _packetlist2.default.fromStructuredClone(clone);
  return new key.<span class="apidocCodeKeywordSpan">Key</span>(packetlist);
}

function packetlistCloneToMessage(clone) {
  var packetlist = _packetlist2.default.fromStructuredClone(clone);
  return new message.Message(packetlist);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.key.Key.prototype" id="apidoc.module.openpgp.key.Key.prototype">module openpgp.key.Key.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.armor" id="apidoc.element.openpgp.key.Key.prototype.armor">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>armor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">armor = function () {
  var type = this.isPublic() ? _enums2.default.armor.public_key : _enums2.default.armor.private_key;
  return _armor2.default.encode(type, this.toPacketlist().write());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  storeKeys(this.storage, this.privateKeysItem, keys);
};

function storeKeys(storage, itemname, keys) {
  var armoredKeys = [];
  if (keys.length) {
    for (var i = 0; i &lt; keys.length; i++) {
      armoredKeys.push(keys[i].<span class="apidocCodeKeywordSpan">armor</span>());
    }
    storage.setItem(itemname, JSON.stringify(armoredKeys));
  } else {
    storage.removeItem(itemname);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.decrypt" id="apidoc.element.openpgp.key.Key.prototype.decrypt">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(passphrase)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (passphrase) {
  if (this.isPrivate()) {
    var keys = this.getAllKeyPackets();
    for (var i = 0; i &lt; keys.length; i++) {
      var success = keys[i].decrypt(passphrase);
      if (!success) {
        return false;
      }
    }
  } else {
    throw new Error("Nothing to decrypt in a public key");
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
options = {
    message: openpgp.message.read(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.<span class="apidocCodeKeywordSpan">decrypt</span>(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
```

#### Encrypt and decrypt *String* data with PGP keys

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.decryptKeyPacket" id="apidoc.element.openpgp.key.Key.prototype.decryptKeyPacket">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>decryptKeyPacket
        <span class="apidocSignatureSpan">(keyIds, passphrase)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decryptKeyPacket = function (keyIds, passphrase) {
  if (this.isPrivate()) {
    var keys = this.getAllKeyPackets();
    for (var i = 0; i &lt; keys.length; i++) {
      var keyId = keys[i].getKeyId();
      for (var j = 0; j &lt; keyIds.length; j++) {
        if (keyId.equals(keyIds[j])) {
          var success = keys[i].decrypt(passphrase);
          if (!success) {
            return false;
          }
        }
      }
    }
  } else {
    throw new Error("Nothing to decrypt in a public key");
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var plaintext = 'short message\nnext line\ní•œêµ­ì–´/ì¡°ì„&nbsp;ë§';
var esMsg = openpgp.message.readArmored(msg_armor);
var pubKey = openpgp.key.readArmored(pub_key_arm2).keys[0];
var privKey = openpgp.key.readArmored(priv_key_arm2).keys[0];

var keyids = esMsg.getEncryptionKeyIds();
privKey.<span class="apidocCodeKeywordSpan">decryptKeyPacket</span>(keyids, 'hello world');

openpgp.decrypt({ privateKey: privKey, publicKeys:[pubKey], message:esMsg }).then(function(decrypted) {
  expect(decrypted.data).to.exist;
  expect(decrypted.data).to.equal(plaintext);
  expect(decrypted.signatures).to.have.length(1);
  expect(decrypted.signatures[0].valid).to.be.true;
  expect(decrypted.signatures[0].signature.packets.length).to.equal(1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.encrypt" id="apidoc.element.openpgp.key.Key.prototype.encrypt">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(passphrase)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (passphrase) {
  if (!this.isPrivate()) {
    throw new Error("Nothing to encrypt in a public key");
  }

  var keys = this.getAllKeyPackets();
  for (var i = 0; i &lt; keys.length; i++) {
    keys[i].encrypt(passphrase);
    keys[i].clearPrivateMPIs();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.<span class="apidocCodeKeywordSpan">encrypt</span>(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.getAllKeyPackets" id="apidoc.element.openpgp.key.Key.prototype.getAllKeyPackets">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getAllKeyPackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAllKeyPackets = function () {
  return [this.primaryKey].concat(this.getSubkeyPackets());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Returns key IDs of all key packets
 * @returns {Array&lt;module:type/keyid&gt;}
 */
Key.prototype.getKeyIds = function () {
  var keyIds = [];
  var keys = this.<span class="apidocCodeKeywordSpan">getAllKeyPackets</span>();
  for (var i = 0; i &lt; keys.length; i++) {
    keyIds.push(keys[i].getKeyId());
  }
  return keyIds;
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.getEncryptionKeyPacket" id="apidoc.element.openpgp.key.Key.prototype.getEncryptionKeyPacket">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getEncryptionKeyPacket
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getEncryptionKeyPacket = function () {
  // V4: by convention subkeys are prefered for encryption service
  // V3: keys MUST NOT have subkeys
  if (this.subKeys) {
    for (var i = 0; i &lt; this.subKeys.length; i++) {
      if (this.subKeys[i].isValidEncryptionKey(this.primaryKey)) {
        return this.subKeys[i].subKey;
      }
    }
  }
  // if no valid subkey for encryption, evaluate primary key
  var primaryUser = this.getPrimaryUser();
  if (primaryUser &amp;&amp; primaryUser.selfCertificate &amp;&amp; !primaryUser.selfCertificate.isExpired() &amp;&amp; isValidEncryptionKeyPacket(this.
primaryKey, primaryUser.selfCertificate)) {
    return this.primaryKey;
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {Message}                   new message with encrypted content
 */
function encryptSessionKey(sessionKey, symAlgo, publicKeys, passwords) {
var packetlist = new _packet2.default.List();

if (publicKeys) {
  publicKeys.forEach(function (key) {
    var encryptionKeyPacket = key.<span class="apidocCodeKeywordSpan">getEncryptionKeyPacket</span>();
    if (encryptionKeyPacket) {
      var pkESKeyPacket = new _packet2.default.PublicKeyEncryptedSessionKey();
      pkESKeyPacket.publicKeyId = encryptionKeyPacket.getKeyId();
      pkESKeyPacket.publicKeyAlgorithm = encryptionKeyPacket.algorithm;
      pkESKeyPacket.sessionKey = sessionKey;
      pkESKeyPacket.sessionKeyAlgorithm = symAlgo;
      pkESKeyPacket.encrypt(encryptionKeyPacket);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.getExpirationTime" id="apidoc.element.openpgp.key.Key.prototype.getExpirationTime">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getExpirationTime
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getExpirationTime = function () {
  if (this.primaryKey.version === 3) {
    return getExpirationTime(this.primaryKey);
  }
  if (this.primaryKey.version === 4) {
    var primaryUser = this.getPrimaryUser();
    if (!primaryUser) {
      return null;
    }
    return getExpirationTime(this.primaryKey, primaryUser.selfCertificate);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  expect(keyPacket).to.not.exist;
});

it('Method getExpirationTime V4 Key', function() {
  var pubKey = openpgp.key.readArmored(twoKeys).keys[1];
  expect(pubKey).to.exist;
  expect(pubKey).to.be.an.instanceof(openpgp.key.Key);
  expect(pubKey.<span class="apidocCodeKeywordSpan">getExpirationTime</span>().toISOString()).to.be.equal('2018-11-26T10:58
:29.000Z');
});

it('Method getExpirationTime V4 SubKey', function() {
  var pubKey = openpgp.key.readArmored(twoKeys).keys[1];
  expect(pubKey).to.exist;
  expect(pubKey).to.be.an.instanceof(openpgp.key.Key);
  expect(pubKey.subKeys[0].getExpirationTime().toISOString()).to.be.equal('2018-11-26T10:58:29.000Z');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.getKeyIds" id="apidoc.element.openpgp.key.Key.prototype.getKeyIds">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getKeyIds
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getKeyIds = function () {
  var keyIds = [];
  var keys = this.getAllKeyPackets();
  for (var i = 0; i &lt; keys.length; i++) {
    keyIds.push(keys[i].getKeyId());
  }
  return keyIds;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.getKeyPacket" id="apidoc.element.openpgp.key.Key.prototype.getKeyPacket">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getKeyPacket
        <span class="apidocSignatureSpan">(keyIds)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getKeyPacket = function (keyIds) {
  var keys = this.getAllKeyPackets();
  for (var i = 0; i &lt; keys.length; i++) {
    var keyId = keys[i].getKeyId();
    for (var j = 0; j &lt; keyIds.length; j++) {
      if (keyId.equals(keyIds[j])) {
        return keys[i];
      }
    }
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
} else if (privateKey) {
  var encryptionKeyIds = this.getEncryptionKeyIds();
  if (!encryptionKeyIds.length) {
    // nothing to decrypt
    return;
  }
  var privateKeyPacket = privateKey.<span class="apidocCodeKeywordSpan">getKeyPacket</span>(encryptionKeyIds);
  if (!privateKeyPacket.isDecrypted) {
    throw new Error('Private key is not decrypted.');
  }
  var pkESKeyPacketlist = this.packets.filterByTag(_enums2.default.packet.publicKeyEncryptedSessionKey);
  for (var j = 0; j &lt; pkESKeyPacketlist.length; j++) {
    if (pkESKeyPacketlist[j].publicKeyId.equals(privateKeyPacket.getKeyId())) {
      keyPacket = pkESKeyPacketlist[j];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.getPreferredHashAlgorithm" id="apidoc.element.openpgp.key.Key.prototype.getPreferredHashAlgorithm">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getPreferredHashAlgorithm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPreferredHashAlgorithm = function () {
  var primaryUser = this.getPrimaryUser();
  if (primaryUser &amp;&amp; primaryUser.selfCertificate.preferredHashAlgorithms) {
    return primaryUser.selfCertificate.preferredHashAlgorithms[0];
  }
  return _config2.default.prefer_hash_algorithm;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!signingKeyPacket.isDecrypted) {
    throw new Error('Private key is not decrypted.');
  }
  signaturePacket = new _packet2.default.Signature();
  // Most OpenPGP implementations use generic certification (0x10)
  signaturePacket.signatureType = _enums2.default.write(_enums2.default.signature, _enums2.default.signature.cert_generic);
  signaturePacket.keyFlags = [_enums2.default.keyFlags.certify_keys | _enums2.default.keyFlags.sign_data];
  signaturePacket.hashAlgorithm = privateKey.<span class="apidocCodeKeywordSpan">getPreferredHashAlgorithm</span>();
  signaturePacket.publicKeyAlgorithm = signingKeyPacket.algorithm;
  signaturePacket.signingKeyId = signingKeyPacket.getKeyId();
  signaturePacket.sign(signingKeyPacket, dataToSign);
  user.otherCertifications.push(signaturePacket);
});
user.update(this, primaryKey);
return user;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.getPrimaryUser" id="apidoc.element.openpgp.key.Key.prototype.getPrimaryUser">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getPrimaryUser
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPrimaryUser = function () {
  var primUser = [];
  for (var i = 0; i &lt; this.users.length; i++) {
    if (!this.users[i].userId || !this.users[i].selfCertifications) {
      continue;
    }
    for (var j = 0; j &lt; this.users[i].selfCertifications.length; j++) {
      primUser.push({ index: i, user: this.users[i], selfCertificate: this.users[i].selfCertifications[j] });
    }
  }
  // sort by primary user flag and signature creation time
  primUser = primUser.sort(function (a, b) {
    if (a.selfCertificate.isPrimaryUserID &gt; b.selfCertificate.isPrimaryUserID) {
      return -1;
    } else if (a.selfCertificate.isPrimaryUserID &lt; b.selfCertificate.isPrimaryUserID) {
      return 1;
    } else if (a.selfCertificate.created &gt; b.selfCertificate.created) {
      return -1;
    } else if (a.selfCertificate.created &lt; b.selfCertificate.created) {
      return 1;
    } else {
      return 0;
    }
  });
  // return first valid
  for (var k = 0; k &lt; primUser.length; k++) {
    if (primUser[k].user.isValidSelfCertificate(this.primaryKey, primUser[k].selfCertificate)) {
      return primUser[k];
    }
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Returns first key packet or key packet by given keyId that is available for signing or signature verification
 * @param  {module:type/keyid} keyId, optional
 * @return {(module:packet/secret_subkey|module:packet/secret_key|null)} key packet or null if no signing key has been found
 */
Key.prototype.getSigningKeyPacket = function (keyId) {
var primaryUser = this.<span class="apidocCodeKeywordSpan">getPrimaryUser</span>();
if (primaryUser &amp;&amp; isValidSigningKeyPacket(this.primaryKey, primaryUser.selfCertificate) &amp;&amp; (!keyId || this.
primaryKey.getKeyId().equals(keyId))) {
  return this.primaryKey;
}
if (this.subKeys) {
  for (var i = 0; i &lt; this.subKeys.length; i++) {
    if (this.subKeys[i].isValidSigningKey(this.primaryKey) &amp;&amp; (!keyId || this.subKeys[i].subKey.getKeyId().equals(keyId
))) {
      return this.subKeys[i].subKey;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.getSigningKeyPacket" id="apidoc.element.openpgp.key.Key.prototype.getSigningKeyPacket">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getSigningKeyPacket
        <span class="apidocSignatureSpan">(keyId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSigningKeyPacket = function (keyId) {
  var primaryUser = this.getPrimaryUser();
  if (primaryUser &amp;&amp; isValidSigningKeyPacket(this.primaryKey, primaryUser.selfCertificate) &amp;&amp; (!keyId || this.primaryKey.getKeyId
().equals(keyId))) {
    return this.primaryKey;
  }
  if (this.subKeys) {
    for (var i = 0; i &lt; this.subKeys.length; i++) {
      if (this.subKeys[i].isValidSigningKey(this.primaryKey) &amp;&amp; (!keyId || this.subKeys[i].subKey.getKeyId().equals(keyId))) {
        return this.subKeys[i].subKey;
      }
    }
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
for (var i = 0; i &lt; privateKeys.length; i++) {
  if (privateKeys[i].isPublic()) {
    throw new Error('Need private key for signing');
  }
  var signaturePacket = new _packet2.default.Signature();
  signaturePacket.signatureType = _enums2.default.signature.text;
  signaturePacket.hashAlgorithm = _config2.default.prefer_hash_algorithm;
  var signingKeyPacket = privateKeys[i].<span class="apidocCodeKeywordSpan">getSigningKeyPacket</span>();
  signaturePacket.publicKeyAlgorithm = signingKeyPacket.algorithm;
  if (!signingKeyPacket.isDecrypted) {
    throw new Error('Private key is not decrypted.');
  }
  signaturePacket.sign(signingKeyPacket, literalDataPacket);
  packetlist.push(signaturePacket);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.getSubkeyPackets" id="apidoc.element.openpgp.key.Key.prototype.getSubkeyPackets">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getSubkeyPackets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSubkeyPackets = function () {
  var subKeys = [];
  if (this.subKeys) {
    for (var i = 0; i &lt; this.subKeys.length; i++) {
      subKeys.push(this.subKeys[i].subKey);
    }
  }
  return subKeys;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * Returns all the private and public key and subkey packets
 * @returns {Array&lt;(module:packet/public_subkey|module:packet/secret_subkey|module:packet/secret_key|module:packet/public_key
)&gt;}
 */
Key.prototype.getAllKeyPackets = function () {
  return [this.primaryKey].concat(this.<span class="apidocCodeKeywordSpan">getSubkeyPackets</span>());
};

/**
 * Returns key IDs of all key packets
 * @returns {Array&lt;module:type/keyid&gt;}
 */
Key.prototype.getKeyIds = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.getUserIds" id="apidoc.element.openpgp.key.Key.prototype.getUserIds">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>getUserIds
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getUserIds = function () {
  var userids = [];
  for (var i = 0; i &lt; this.users.length; i++) {
    if (this.users[i].userId) {
      userids.push(_util2.default.Uint8Array2str(this.users[i].userId.write()));
    }
  }
  return userids;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {Boolean} True if the email address is defined in the specified key
 */
function emailCheck(email, key) {
email = email.toLowerCase();
// escape email before using in regular expression
var emailEsc = email.replace(/[.*+?^${}()|[\]\\]/g, "\\$&amp;");
var emailRegex = new RegExp('&lt;' + emailEsc + '&gt;');
var userIds = key.<span class="apidocCodeKeywordSpan">getUserIds</span>();
for (var i = 0; i &lt; userIds.length; i++) {
  var userId = userIds[i].toLowerCase();
  if (email === userId || emailRegex.test(userId)) {
    return true;
  }
}
return false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.isPrivate" id="apidoc.element.openpgp.key.Key.prototype.isPrivate">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>isPrivate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPrivate = function () {
  return this.primaryKey.tag === _enums2.default.packet.secretKey;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * Encrypts all secret key and subkey packets
 * @param  {String} passphrase
 */
Key.prototype.encrypt = function (passphrase) {
if (!this.<span class="apidocCodeKeywordSpan">isPrivate</span>()) {
  throw new Error("Nothing to encrypt in a public key");
}

var keys = this.getAllKeyPackets();
for (var i = 0; i &lt; keys.length; i++) {
  keys[i].encrypt(passphrase);
  keys[i].clearPrivateMPIs();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.isPublic" id="apidoc.element.openpgp.key.Key.prototype.isPublic">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>isPublic
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPublic = function () {
  return this.primaryKey.tag === _enums2.default.packet.publicKey;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {module:signature~Signature}      new detached signature of message content
 */
CleartextMessage.prototype.signDetached = function (privateKeys) {
var packetlist = new _packet2.default.List();
var literalDataPacket = new _packet2.default.Literal();
literalDataPacket.setText(this.text);
for (var i = 0; i &lt; privateKeys.length; i++) {
  if (privateKeys[i].<span class="apidocCodeKeywordSpan">isPublic</span>()) {
    throw new Error('Need private key for signing');
  }
  var signaturePacket = new _packet2.default.Signature();
  signaturePacket.signatureType = _enums2.default.signature.text;
  signaturePacket.hashAlgorithm = _config2.default.prefer_hash_algorithm;
  var signingKeyPacket = privateKeys[i].getSigningKeyPacket();
  signaturePacket.publicKeyAlgorithm = signingKeyPacket.algorithm;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.packetlist2structure" id="apidoc.element.openpgp.key.Key.prototype.packetlist2structure">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>packetlist2structure
        <span class="apidocSignatureSpan">(packetlist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">packetlist2structure = function (packetlist) {
  var user, primaryKeyId, subKey;
  for (var i = 0; i &lt; packetlist.length; i++) {
    switch (packetlist[i].tag) {
      case _enums2.default.packet.publicKey:
      case _enums2.default.packet.secretKey:
        this.primaryKey = packetlist[i];
        primaryKeyId = this.primaryKey.getKeyId();
        break;
      case _enums2.default.packet.userid:
      case _enums2.default.packet.userAttribute:
        user = new User(packetlist[i]);
        if (!this.users) {
          this.users = [];
        }
        this.users.push(user);
        break;
      case _enums2.default.packet.publicSubkey:
      case _enums2.default.packet.secretSubkey:
        user = null;
        if (!this.subKeys) {
          this.subKeys = [];
        }
        subKey = new SubKey(packetlist[i]);
        this.subKeys.push(subKey);
        break;
      case _enums2.default.packet.signature:
        switch (packetlist[i].signatureType) {
          case _enums2.default.signature.cert_generic:
          case _enums2.default.signature.cert_persona:
          case _enums2.default.signature.cert_casual:
          case _enums2.default.signature.cert_positive:
            if (!user) {
              _util2.default.print_debug('Dropping certification signatures without preceding user packet');
              continue;
            }
            if (packetlist[i].issuerKeyId.equals(primaryKeyId)) {
              if (!user.selfCertifications) {
                user.selfCertifications = [];
              }
              user.selfCertifications.push(packetlist[i]);
            } else {
              if (!user.otherCertifications) {
                user.otherCertifications = [];
              }
              user.otherCertifications.push(packetlist[i]);
            }
            break;
          case _enums2.default.signature.cert_revocation:
            if (user) {
              if (!user.revocationCertifications) {
                user.revocationCertifications = [];
              }
              user.revocationCertifications.push(packetlist[i]);
            } else {
              if (!this.directSignatures) {
                this.directSignatures = [];
              }
              this.directSignatures.push(packetlist[i]);
            }
            break;
          case _enums2.default.signature.key:
            if (!this.directSignatures) {
              this.directSignatures = [];
            }
            this.directSignatures.push(packetlist[i]);
            break;
          case _enums2.default.signature.subkey_binding:
            if (!subKey) {
              _util2.default.print_debug('Dropping subkey binding signature without preceding subkey packet');
              continue;
            }
            subKey.bindingSignature = packetlist[i];
            break;
          case _enums2.default.signature.key_revocation:
            this.revocationSignature = packetlist[i];
            break;
          case _enums2.default.signature.subkey_revocation:
            if (!subKey) {
              _util2.default.print_debug('Dropping subkey revocation signature without preceding subkey packet');
              continue;
            }
            subKey.revocationSignature = packetlist[i];
            break;
        }
        break;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 }
 // same data as in packetlist but in structured form
 this.primaryKey = null;
 this.revocationSignature = null;
 this.directSignatures = null;
 this.users = null;
 this.subKeys = null;
 this.<span class="apidocCodeKeywordSpan">packetlist2structure</span>(packetlist);
 if (!this.primaryKey || !this.users) {
   throw new Error('Invalid key: need at least key and user ID packet');
 }
}

/**
* Transforms packetlist to structured key data
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.revoke" id="apidoc.element.openpgp.key.Key.prototype.revoke">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>revoke
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">revoke = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.signAllUsers" id="apidoc.element.openpgp.key.Key.prototype.signAllUsers">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>signAllUsers
        <span class="apidocSignatureSpan">(privateKeys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">signAllUsers = function (privateKeys) {
  var _this = this;

  var users = this.users.map(function (user) {
    return user.sign(_this.primaryKey, privateKeys);
  });
  var key = new Key(this.toPacketlist());
  key.users = users;
  return key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  done();
});

it('Sign and verify key - all users', function(done) {
  var key = openpgp.key.readArmored(multi_uid_key).keys[0];
  var privateKey = openpgp.key.readArmored(priv_key_rsa).keys[0];
  privateKey.decrypt('hello world');
  key = key.<span class="apidocCodeKeywordSpan">signAllUsers</span>([privateKey]);
  var signatures = key.verifyAllUsers([privateKey]);
  expect(signatures.length).to.equal(4);
  expect(signatures[0].userid).to.equal(key.users[0].userId.userid);
  expect(signatures[0].keyid.toHex()).to.equal(key.getSigningKeyPacket().getKeyId().toHex());
  expect(signatures[0].valid).to.be.null;
  expect(signatures[1].userid).to.equal(key.users[0].userId.userid);
  expect(signatures[1].keyid.toHex()).to.equal(privateKey.getSigningKeyPacket().getKeyId().toHex());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.signPrimaryUser" id="apidoc.element.openpgp.key.Key.prototype.signPrimaryUser">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>signPrimaryUser
        <span class="apidocSignatureSpan">(privateKeys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">signPrimaryUser = function (privateKeys) {
  var _ref = this.getPrimaryUser() || {};

  var index = _ref.index;
  var user = _ref.user;

  if (!user) {
    throw new Error('Could not find primary user');
  }
  user = user.sign(this.primaryKey, privateKeys);
  var key = new Key(this.toPacketlist());
  key.users[index] = user;
  return key;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }).catch(done);
});

it('Sign and verify key - primary user', function(done) {
  var key = openpgp.key.readArmored(pub_sig_test).keys[0];
  var privateKey = openpgp.key.readArmored(priv_key_rsa).keys[0];
  privateKey.decrypt('hello world');
  key = key.<span class="apidocCodeKeywordSpan">signPrimaryUser</span>([privateKey]);
  var signatures = key.verifyPrimaryUser([privateKey]);
  expect(signatures.length).to.equal(2);
  expect(signatures[0].keyid.toHex()).to.equal(key.getSigningKeyPacket().getKeyId().toHex());
  expect(signatures[0].valid).to.be.null;
  expect(signatures[1].keyid.toHex()).to.equal(privateKey.getSigningKeyPacket().getKeyId().toHex());
  expect(signatures[1].valid).to.be.true;
  done();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.toPacketlist" id="apidoc.element.openpgp.key.Key.prototype.toPacketlist">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>toPacketlist
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPacketlist = function () {
  var packetlist = new _packet2.default.List();
  packetlist.push(this.primaryKey);
  packetlist.push(this.revocationSignature);
  packetlist.concat(this.directSignatures);
  var i;
  for (i = 0; i &lt; this.users.length; i++) {
    packetlist.concat(this.users[i].toPacketlist());
  }
  if (this.subKeys) {
    for (i = 0; i &lt; this.subKeys.length; i++) {
      packetlist.concat(this.subKeys[i].toPacketlist());
    }
  }
  return packetlist;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Key.prototype.toPacketlist = function () {
var packetlist = new _packet2.default.List();
packetlist.push(this.primaryKey);
packetlist.push(this.revocationSignature);
packetlist.concat(this.directSignatures);
var i;
for (i = 0; i &lt; this.users.length; i++) {
  packetlist.concat(this.users[i].<span class="apidocCodeKeywordSpan">toPacketlist</span>());
}
if (this.subKeys) {
  for (i = 0; i &lt; this.subKeys.length; i++) {
    packetlist.concat(this.subKeys[i].toPacketlist());
  }
}
return packetlist;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.toPublic" id="apidoc.element.openpgp.key.Key.prototype.toPublic">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>toPublic
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPublic = function () {
  var packetlist = new _packet2.default.List();
  var keyPackets = this.toPacketlist();
  var bytes;
  for (var i = 0; i &lt; keyPackets.length; i++) {
    switch (keyPackets[i].tag) {
      case _enums2.default.packet.secretKey:
        bytes = keyPackets[i].writePublicKey();
        var pubKeyPacket = new _packet2.default.PublicKey();
        pubKeyPacket.read(bytes);
        packetlist.push(pubKeyPacket);
        break;
      case _enums2.default.packet.secretSubkey:
        bytes = keyPackets[i].writePublicKey();
        var pubSubkeyPacket = new _packet2.default.PublicSubkey();
        pubSubkeyPacket.read(bytes);
        packetlist.push(pubSubkeyPacket);
        break;
      default:
        packetlist.push(keyPackets[i]);
    }
  }
  return new Key(packetlist);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 }

 return key.generate(options).then(function (newKey) {
   return {

     key: newKey,
     privateKeyArmored: newKey.armor(),
     publicKeyArmored: newKey.<span class="apidocCodeKeywordSpan">toPublic</span>().armor()

   };
 }).catch(onError.bind(null, 'Error generating keypair'));
}

/**
* Reformats signature packets for a key and rewraps key object.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.update" id="apidoc.element.openpgp.key.Key.prototype.update">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>update
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (key) {
  var that = this;
  if (key.verifyPrimaryKey() === _enums2.default.keyStatus.invalid) {
    return;
  }
  if (this.primaryKey.getFingerprint() !== key.primaryKey.getFingerprint()) {
    throw new Error('Key update method: fingerprints of keys not equal');
  }
  if (this.isPublic() &amp;&amp; key.isPrivate()) {
    // check for equal subkey packets
    var equal = (this.subKeys &amp;&amp; this.subKeys.length) === (key.subKeys &amp;&amp; key.subKeys.length) &amp;&amp; (!this.subKeys || this.subKeys.
every(function (destSubKey) {
      return key.subKeys.some(function (srcSubKey) {
        return destSubKey.subKey.getFingerprint() === srcSubKey.subKey.getFingerprint();
      });
    }));
    if (!equal) {
      throw new Error('Cannot update public key with private key if subkey mismatch');
    }
    this.primaryKey = key.primaryKey;
  }
  // revocation signature
  if (!this.revocationSignature &amp;&amp; key.revocationSignature &amp;&amp; !key.revocationSignature.isExpired() &amp;&amp; (key.revocationSignature.verified
 || key.revocationSignature.verify(key.primaryKey, { key: key.primaryKey }))) {
    this.revocationSignature = key.revocationSignature;
  }
  // direct signatures
  mergeSignatures(key, this, 'directSignatures');
  // users
  key.users.forEach(function (srcUser) {
    var found = false;
    for (var i = 0; i &lt; that.users.length; i++) {
      if (srcUser.userId &amp;&amp; srcUser.userId.userid === that.users[i].userId.userid || srcUser.userAttribute &amp;&amp; srcUser.userAttribute
.equals(that.users[i].userAttribute)) {
        that.users[i].update(srcUser, that.primaryKey);
        found = true;
        break;
      }
    }
    if (!found) {
      that.users.push(srcUser);
    }
  });
  // subkeys
  if (key.subKeys) {
    key.subKeys.forEach(function (srcSubKey) {
      var found = false;
      for (var i = 0; i &lt; that.subKeys.length; i++) {
        if (srcSubKey.subKey.getFingerprint() === that.subKeys[i].subKey.getFingerprint()) {
          that.subKeys[i].update(srcSubKey, that.primaryKey);
          found = true;
          break;
        }
      }
      if (!found) {
        that.subKeys.push(srcSubKey);
      }
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function nodeEncrypt(pt, key, iv) {
pt = new Buffer(pt);
key = new Buffer(key);
iv = new Buffer(iv);
var en = new nodeCrypto.createCipheriv('aes-' + key.length * 8 + '-gcm', key, iv);
var ct = Buffer.concat([en.<span class="apidocCodeKeywordSpan">update</span>(pt), en.final(), en.getAuthTag()]); // append auth
tag to ciphertext
return Promise.resolve(new Uint8Array(ct));
}

function nodeDecrypt(ct, key, iv) {
ct = new Buffer(ct);
key = new Buffer(key);
iv = new Buffer(iv);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.verifyAllUsers" id="apidoc.element.openpgp.key.Key.prototype.verifyAllUsers">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>verifyAllUsers
        <span class="apidocSignatureSpan">(keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verifyAllUsers = function (keys) {
  var _this2 = this;

  return this.users.reduce(function (signatures, user) {
    return signatures.concat(user.verifyAllSignatures(_this2.primaryKey, keys).map(function (signature) {
      return {
        userid: user.userId.userid,
        keyid: signature.keyid,
        valid: signature.valid
      };
    }));
  }, []);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

it('Sign and verify key - all users', function(done) {
  var key = openpgp.key.readArmored(multi_uid_key).keys[0];
  var privateKey = openpgp.key.readArmored(priv_key_rsa).keys[0];
  privateKey.decrypt('hello world');
  key = key.signAllUsers([privateKey]);
  var signatures = key.<span class="apidocCodeKeywordSpan">verifyAllUsers</span>([privateKey]);
  expect(signatures.length).to.equal(4);
  expect(signatures[0].userid).to.equal(key.users[0].userId.userid);
  expect(signatures[0].keyid.toHex()).to.equal(key.getSigningKeyPacket().getKeyId().toHex());
  expect(signatures[0].valid).to.be.null;
  expect(signatures[1].userid).to.equal(key.users[0].userId.userid);
  expect(signatures[1].keyid.toHex()).to.equal(privateKey.getSigningKeyPacket().getKeyId().toHex());
  expect(signatures[1].valid).to.be.true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.verifyPrimaryKey" id="apidoc.element.openpgp.key.Key.prototype.verifyPrimaryKey">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>verifyPrimaryKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verifyPrimaryKey = function () {
  // check revocation signature
  if (this.revocationSignature &amp;&amp; !this.revocationSignature.isExpired() &amp;&amp; (this.revocationSignature.verified || this.revocationSignature
.verify(this.primaryKey, { key: this.primaryKey }))) {
    return _enums2.default.keyStatus.revoked;
  }
  // check V3 expiration time
  if (this.primaryKey.version === 3 &amp;&amp; this.primaryKey.expirationTimeV3 !== 0 &amp;&amp; Date.now() &gt; this.primaryKey.created.getTime() +
this.primaryKey.expirationTimeV3 * 24 * 3600 * 1000) {
    return _enums2.default.keyStatus.expired;
  }
  // check for at least one self signature. Self signature of user ID not mandatory
  // See {@link http://tools.ietf.org/html/rfc4880#section-11.1}
  var selfSigned = false;
  for (var i = 0; i &lt; this.users.length; i++) {
    if (this.users[i].userId &amp;&amp; this.users[i].selfCertifications) {
      selfSigned = true;
    }
  }
  if (!selfSigned) {
    return _enums2.default.keyStatus.no_self_cert;
  }
  // check for valid self signature
  var primaryUser = this.getPrimaryUser();
  if (!primaryUser) {
    return _enums2.default.keyStatus.invalid;
  }
  // check V4 expiration time
  if (this.primaryKey.version === 4 &amp;&amp; primaryUser.selfCertificate.keyNeverExpires === false &amp;&amp; Date.now() &gt; this.primaryKey.created
.getTime() + primaryUser.selfCertificate.keyExpirationTime * 1000) {
    return _enums2.default.keyStatus.expired;
  }
  return _enums2.default.keyStatus.valid;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * duplicates are ignored.
 * If the specified key is a private key and the destination key is public,
 * the destination key is tranformed to a private key.
 * @param  {module:key~Key} key source key to merge
 */
Key.prototype.update = function (key) {
var that = this;
if (key.<span class="apidocCodeKeywordSpan">verifyPrimaryKey</span>() === _enums2.default.keyStatus.invalid) {
  return;
}
if (this.primaryKey.getFingerprint() !== key.primaryKey.getFingerprint()) {
  throw new Error('Key update method: fingerprints of keys not equal');
}
if (this.isPublic() &amp;&amp; key.isPrivate()) {
  // check for equal subkey packets
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.key.Key.prototype.verifyPrimaryUser" id="apidoc.element.openpgp.key.Key.prototype.verifyPrimaryUser">
        function <span class="apidocSignatureSpan">openpgp.key.Key.prototype.</span>verifyPrimaryUser
        <span class="apidocSignatureSpan">(keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verifyPrimaryUser = function (keys) {
  var _ref2 = this.getPrimaryUser() || {};

  var user = _ref2.user;

  if (!user) {
    throw new Error('Could not find primary user');
  }
  return user.verifyAllSignatures(this.primaryKey, keys);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

it('Sign and verify key - primary user', function(done) {
  var key = openpgp.key.readArmored(pub_sig_test).keys[0];
  var privateKey = openpgp.key.readArmored(priv_key_rsa).keys[0];
  privateKey.decrypt('hello world');
  key = key.signPrimaryUser([privateKey]);
  var signatures = key.<span class="apidocCodeKeywordSpan">verifyPrimaryUser</span>([privateKey]);
  expect(signatures.length).to.equal(2);
  expect(signatures[0].keyid.toHex()).to.equal(key.getSigningKeyPacket().getKeyId().toHex());
  expect(signatures[0].valid).to.be.null;
  expect(signatures[1].keyid.toHex()).to.equal(privateKey.getSigningKeyPacket().getKeyId().toHex());
  expect(signatures[1].valid).to.be.true;
  done();
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.message" id="apidoc.module.openpgp.message">module openpgp.message</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.message.Message" id="apidoc.element.openpgp.message.Message">
        function <span class="apidocSignatureSpan">openpgp.message.</span>Message
        <span class="apidocSignatureSpan">(packetlist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Message(packetlist) {
  if (!(this instanceof Message)) {
    return new Message(packetlist);
  }
  this.packets = packetlist || new _packet2.default.List();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function packetlistCloneToKey(clone) {
  var packetlist = _packetlist2.default.fromStructuredClone(clone);
  return new key.Key(packetlist);
}

function packetlistCloneToMessage(clone) {
  var packetlist = _packetlist2.default.fromStructuredClone(clone);
  return new message.<span class="apidocCodeKeywordSpan">Message</span>(packetlist);
}

function packetlistCloneToCleartextMessage(clone) {
  var packetlist = _packetlist2.default.fromStructuredClone(clone.signature);
  return new cleartext.CleartextMessage(clone.text, new signature.Signature(packetlist));
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.encryptSessionKey" id="apidoc.element.openpgp.message.encryptSessionKey">
        function <span class="apidocSignatureSpan">openpgp.message.</span>encryptSessionKey
        <span class="apidocSignatureSpan">(sessionKey, symAlgo, publicKeys, passwords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encryptSessionKey(sessionKey, symAlgo, publicKeys, passwords) {
  var packetlist = new _packet2.default.List();

  if (publicKeys) {
    publicKeys.forEach(function (key) {
      var encryptionKeyPacket = key.getEncryptionKeyPacket();
      if (encryptionKeyPacket) {
        var pkESKeyPacket = new _packet2.default.PublicKeyEncryptedSessionKey();
        pkESKeyPacket.publicKeyId = encryptionKeyPacket.getKeyId();
        pkESKeyPacket.publicKeyAlgorithm = encryptionKeyPacket.algorithm;
        pkESKeyPacket.sessionKey = sessionKey;
        pkESKeyPacket.sessionKeyAlgorithm = symAlgo;
        pkESKeyPacket.encrypt(encryptionKeyPacket);
        delete pkESKeyPacket.sessionKey; // delete plaintext session key after encryption
        packetlist.push(pkESKeyPacket);
      } else {
        throw new Error('Could not find valid key packet for encryption in key ' + key.primaryKey.getKeyId().toHex());
      }
    });
  }

  if (passwords) {
    passwords.forEach(function (password) {
      var symEncryptedSessionKeyPacket = new _packet2.default.SymEncryptedSessionKey();
      symEncryptedSessionKeyPacket.sessionKey = sessionKey;
      symEncryptedSessionKeyPacket.sessionKeyAlgorithm = symAlgo;
      symEncryptedSessionKeyPacket.encrypt(password);
      delete symEncryptedSessionKeyPacket.sessionKey; // delete plaintext session key after encryption
      packetlist.push(symEncryptedSessionKeyPacket);
    });
  }

  return new Message(packetlist);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   // use web worker if available
   return asyncProxy.delegate('encryptSessionKey', { data: data, algorithm: algorithm, publicKeys: publicKeys, passwords
: passwords });
 }

 return execute(function () {
   return {

     message: messageLib.<span class="apidocCodeKeywordSpan">encryptSessionKey</span>(data, algorithm, publicKeys, passwords)

   };
 }, 'Error encrypting session key');
}

/**
* Decrypt a symmetric session key with a private key or password. Either a private key or
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.fromBinary" id="apidoc.element.openpgp.message.fromBinary">
        function <span class="apidocSignatureSpan">openpgp.message.</span>fromBinary
        <span class="apidocSignatureSpan">(bytes, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromBinary(bytes, filename) {
  if (!_util2.default.isUint8Array(bytes)) {
    throw new Error('Data must be in the form of a Uint8Array');
  }

  var literalDataPacket = new _packet2.default.Literal();
  if (filename) {
    literalDataPacket.setFilename(filename);
  }
  literalDataPacket.setBytes(bytes, _enums2.default.read(_enums2.default.literal, _enums2.default.literal.binary));
  if (filename !== undefined) {
    literalDataPacket.setFilename(filename);
  }
  var literalDataPacketlist = new _packet2.default.List();
  literalDataPacketlist.push(literalDataPacket);
  return new Message(literalDataPacketlist);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {String|Uint8Array} data   the payload for the message
 * @param  {String} filename          the literal data packet's filename
 * @return {Message}                  a message object
 */
function createMessage(data, filename) {
  var msg = void 0;
  if (_util2.default.isUint8Array(data)) {
    msg = messageLib.<span class="apidocCodeKeywordSpan">fromBinary</span>(data, filename);
  } else if (_util2.default.isString(data)) {
    msg = messageLib.fromText(data, filename);
  } else {
    throw new Error('Data must be of type String or Uint8Array');
  }
  return msg;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.fromText" id="apidoc.element.openpgp.message.fromText">
        function <span class="apidocSignatureSpan">openpgp.message.</span>fromText
        <span class="apidocSignatureSpan">(text, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromText(text, filename) {
  var literalDataPacket = new _packet2.default.Literal();
  // text will be converted to UTF8
  literalDataPacket.setText(text);
  if (filename !== undefined) {
    literalDataPacket.setFilename(filename);
  }
  var literalDataPacketlist = new _packet2.default.List();
  literalDataPacketlist.push(literalDataPacket);
  return new Message(literalDataPacketlist);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {Message}                  a message object
 */
function createMessage(data, filename) {
  var msg = void 0;
  if (_util2.default.isUint8Array(data)) {
    msg = messageLib.fromBinary(data, filename);
  } else if (_util2.default.isString(data)) {
    msg = messageLib.<span class="apidocCodeKeywordSpan">fromText</span>(data, filename);
  } else {
    throw new Error('Data must be of type String or Uint8Array');
  }
  return msg;
}

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.read" id="apidoc.element.openpgp.message.read">
        function <span class="apidocSignatureSpan">openpgp.message.</span>read
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read(input) {
  var packetlist = new _packet2.default.List();
  packetlist.read(input);
  return new Message(packetlist);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.readArmored" id="apidoc.element.openpgp.message.readArmored">
        function <span class="apidocSignatureSpan">openpgp.message.</span>readArmored
        <span class="apidocSignatureSpan">(armoredText)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readArmored(armoredText) {
  //TODO how do we want to handle bad text? Exception throwing
  //TODO don't accept non-message armored texts
  var input = _armor2.default.decode(armoredText).data;
  return read(input);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var options, encrypted;

var pubkey = '-----BEGIN PGP PUBLIC KEY BLOCK ... END PGP PUBLIC KEY BLOCK-----';
var privkey = '-----BEGIN PGP PRIVATE KEY BLOCK ... END PGP PRIVATE KEY BLOCK-----'; //encrypted private key
var passphrase = 'secret passphrase'; //what the privKey is encrypted with

var privKeyObj = openpgp.key.<span class="apidocCodeKeywordSpan">readArmored</span>(privkey).keys[0];
privKeyObj.decrypt(passphrase);

options = {
    data: 'Hello, World!',                             // input as String (or Uint8Array)
    publicKeys: openpgp.key.readArmored(pubkey).keys,  // for encryption
    privateKeys: privKeyObj // for signing (optional)
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.readSignedContent" id="apidoc.element.openpgp.message.readSignedContent">
        function <span class="apidocSignatureSpan">openpgp.message.</span>readSignedContent
        <span class="apidocSignatureSpan">(content, detachedSignature)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readSignedContent(content, detachedSignature) {
  var literalDataPacket = new _packet2.default.Literal();
  literalDataPacket.setBytes(_util2.default.str2Uint8Array(content), _enums2.default.read(_enums2.default.literal, _enums2.default
.literal.binary));
  var packetlist = new _packet2.default.List();
  packetlist.push(literalDataPacket);
  var input = _armor2.default.decode(detachedSignature).data;
  packetlist.read(input);
  return new Message(packetlist);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    '--------------070307080002050009010403--',
    ''
  ].join('\r\n');

  var publicKeyArmored = '-----BEGIN PGP PUBLIC KEY BLOCK-----\r\nVersion: OpenPGP.js v.1.20131116\r\nComment: Whiteout Mail
 - http://whiteout.io\r\n\r\nxsBNBFKODs4BB/9iOF4THsjQMY+WEpT7ShgKxj4bHzRRaQkqczS4nZvP0U3g\r\nqeqCnbpagyeKXA+bhWFQW4GmXtgAoeD5PXs6AZYrw3tWNxLKu2Oe6Tp9K/XI\r\nxTMQ2wl4qZKDXHvuPsJ7cmgaWqpPyXtxA4zHHS3WrkI/6VzHAcI/y6x4szSB\r\nKgSuhI3hjh3s7TybUC1U6AfoQGx/S7e3WwlCOrK8GTClirN/2mCPRC5wuIft\r\nnkoMfA6jK8d2OPrJ63shy5cgwHOjQg/xuk46dNS7tkvGmbaa+X0PgqSKB+Hf\r\nYPPNS/ylg911DH9qa8BqYU2QpNh9jUKXSF+HbaOM+plWkCSAL7czV+R3ABEB\r\nAAHNLVdoaXRlb3V0IFVzZXIgPHNhZmV3aXRobWUudGVzdHVzZXJAZ21haWwu\r\nY29tPsLAXAQQAQgAEAUCUo4O2gkQ1/uT/N+/wjwAAN2cB/9gFRmAfvEQ2qz+\r\nWubmT2EsSSnjPMxzG4uyykFoa+TaZCWo2Xa2tQghmU103kEkQb1OEjRjpgwJ\r\nYX9Kghnl8DByM686L5AXnRyHP78qRJCLXSXl0AGicboUDp5sovaa4rswQceH\r\nvcdWgZ/mgHTRoiQeJddy9k+H6MPFiyFaVcFwegVsmpc+dCcC8yT+qh8ZIbyG\r\nRJU60PmKKN7LUusP+8DbSv39zCGJCBlVVKyA4MzdF5uM+sqTdXbKzOrT5DGd\r\nCZaox4s+w16Sq1rHzZKFWfQPfKLDB9pyA0ufCVRA3AF6BUi7G3ZqhZiHNhMP\r\nNvE45V/hS1PbZcfPVoUjE2qc1Ix1\r\n=7Wpe\r\n-----END PGP PUBLIC KEY BLOCK-----';
  var publicKeys = openpgp.key.readArmored(publicKeyArmored).keys;

  var msg = openpgp.message.<span class="apidocCodeKeywordSpan">readSignedContent</span>(content, detachedSig);
  var result = msg.verify(publicKeys);
  expect(result[0].valid).to.be.true;
});

it('Detached signature signing and verification', function () {
  var msg = openpgp.message.fromText('hello');
  var pubKey2 = openpgp.key.readArmored(pub_key_arm2).keys[0];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.message.Message" id="apidoc.module.openpgp.message.Message">module openpgp.message.Message</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.message.Message.Message" id="apidoc.element.openpgp.message.Message.Message">
        function <span class="apidocSignatureSpan">openpgp.message.</span>Message
        <span class="apidocSignatureSpan">(packetlist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Message(packetlist) {
  if (!(this instanceof Message)) {
    return new Message(packetlist);
  }
  this.packets = packetlist || new _packet2.default.List();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function packetlistCloneToKey(clone) {
  var packetlist = _packetlist2.default.fromStructuredClone(clone);
  return new key.Key(packetlist);
}

function packetlistCloneToMessage(clone) {
  var packetlist = _packetlist2.default.fromStructuredClone(clone);
  return new message.<span class="apidocCodeKeywordSpan">Message</span>(packetlist);
}

function packetlistCloneToCleartextMessage(clone) {
  var packetlist = _packetlist2.default.fromStructuredClone(clone.signature);
  return new cleartext.CleartextMessage(clone.text, new signature.Signature(packetlist));
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.message.Message.prototype" id="apidoc.module.openpgp.message.Message.prototype">module openpgp.message.Message.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.armor" id="apidoc.element.openpgp.message.Message.prototype.armor">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>armor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">armor = function () {
  return _armor2.default.encode(_enums2.default.armor.message, this.packets.write());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  storeKeys(this.storage, this.privateKeysItem, keys);
};

function storeKeys(storage, itemname, keys) {
  var armoredKeys = [];
  if (keys.length) {
    for (var i = 0; i &lt; keys.length; i++) {
      armoredKeys.push(keys[i].<span class="apidocCodeKeywordSpan">armor</span>());
    }
    storage.setItem(itemname, JSON.stringify(armoredKeys));
  } else {
    storage.removeItem(itemname);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.decrypt" id="apidoc.element.openpgp.message.Message.prototype.decrypt">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(privateKey, sessionKey, password)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (privateKey, sessionKey, password) {
  var _this = this;

  return Promise.resolve().then(function () {
    var keyObj = sessionKey || _this.decryptSessionKey(privateKey, password);
    if (!keyObj || !_util2.default.isUint8Array(keyObj.data) || !_util2.default.isString(keyObj.algorithm)) {
      throw new Error('Invalid session key for decryption.');
    }

    var symEncryptedPacketlist = _this.packets.filterByTag(_enums2.default.packet.symmetricallyEncrypted, _enums2.default.packet
.symEncryptedIntegrityProtected, _enums2.default.packet.symEncryptedAEADProtected);

    if (symEncryptedPacketlist.length === 0) {
      return;
    }

    var symEncryptedPacket = symEncryptedPacketlist[0];
    return symEncryptedPacket.decrypt(keyObj.algorithm, keyObj.data).then(function () {
      var resultMsg = new Message(symEncryptedPacket.packets);
      symEncryptedPacket.packets = new _packet2.default.List(); // remove packets after decryption
      return resultMsg;
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
options = {
    message: openpgp.message.read(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.<span class="apidocCodeKeywordSpan">decrypt</span>(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
```

#### Encrypt and decrypt *String* data with PGP keys

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.decryptSessionKey" id="apidoc.element.openpgp.message.Message.prototype.decryptSessionKey">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>decryptSessionKey
        <span class="apidocSignatureSpan">(privateKey, password)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decryptSessionKey = function (privateKey, password) {
  var keyPacket;

  if (password) {
    var symEncryptedSessionKeyPacketlist = this.packets.filterByTag(_enums2.default.packet.symEncryptedSessionKey);
    var symLength = symEncryptedSessionKeyPacketlist.length;
    for (var i = 0; i &lt; symLength; i++) {
      keyPacket = symEncryptedSessionKeyPacketlist[i];
      try {
        keyPacket.decrypt(password);
        break;
      } catch (err) {
        if (i === symLength - 1) {
          throw err;
        }
      }
    }
    if (!keyPacket) {
      throw new Error('No symmetrically encrypted session key packet found.');
    }
  } else if (privateKey) {
    var encryptionKeyIds = this.getEncryptionKeyIds();
    if (!encryptionKeyIds.length) {
      // nothing to decrypt
      return;
    }
    var privateKeyPacket = privateKey.getKeyPacket(encryptionKeyIds);
    if (!privateKeyPacket.isDecrypted) {
      throw new Error('Private key is not decrypted.');
    }
    var pkESKeyPacketlist = this.packets.filterByTag(_enums2.default.packet.publicKeyEncryptedSessionKey);
    for (var j = 0; j &lt; pkESKeyPacketlist.length; j++) {
      if (pkESKeyPacketlist[j].publicKeyId.equals(privateKeyPacket.getKeyId())) {
        keyPacket = pkESKeyPacketlist[j];
        keyPacket.decrypt(privateKeyPacket);
        break;
      }
    }
  } else {
    throw new Error('No key or password specified.');
  }

  if (keyPacket) {
    return {
      data: keyPacket.sessionKey,
      algorithm: keyPacket.sessionKeyAlgorithm
    };
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {String} password     (optional) password used to decrypt
 * @return {Message}             new message with decrypted content
 */
Message.prototype.decrypt = function (privateKey, sessionKey, password) {
  var _this = this;

  return Promise.resolve().then(function () {
var keyObj = sessionKey || _this.<span class="apidocCodeKeywordSpan">decryptSessionKey</span>(privateKey, password);
if (!keyObj || !_util2.default.isUint8Array(keyObj.data) || !_util2.default.isString(keyObj.algorithm)) {
  throw new Error('Invalid session key for decryption.');
}

var symEncryptedPacketlist = _this.packets.filterByTag(_enums2.default.packet.symmetricallyEncrypted, _enums2.default.packet.symEncryptedIntegrityProtected
, _enums2.default.packet.symEncryptedAEADProtected);

if (symEncryptedPacketlist.length === 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.encrypt" id="apidoc.element.openpgp.message.Message.prototype.encrypt">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(keys, passwords)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (keys, passwords) {
  var _this2 = this;

  var symAlgo = void 0,
      msg = void 0,
      symEncryptedPacket = void 0;
  return Promise.resolve().then(function () {
    if (keys) {
      symAlgo = keyModule.getPreferredSymAlgo(keys);
    } else if (passwords) {
      symAlgo = _config2.default.encryption_cipher;
    } else {
      throw new Error('No keys or passwords');
    }

    var sessionKey = _crypto2.default.generateSessionKey(_enums2.default.read(_enums2.default.symmetric, symAlgo));
    msg = encryptSessionKey(sessionKey, _enums2.default.read(_enums2.default.symmetric, symAlgo), keys, passwords);

    if (_config2.default.aead_protect) {
      symEncryptedPacket = new _packet2.default.SymEncryptedAEADProtected();
    } else if (_config2.default.integrity_protect) {
      symEncryptedPacket = new _packet2.default.SymEncryptedIntegrityProtected();
    } else {
      symEncryptedPacket = new _packet2.default.SymmetricallyEncrypted();
    }
    symEncryptedPacket.packets = _this2.packets;

    return symEncryptedPacket.encrypt(_enums2.default.read(_enums2.default.symmetric, symAlgo), sessionKey);
  }).then(function () {
    msg.packets.push(symEncryptedPacket);
    symEncryptedPacket.packets = new _packet2.default.List(); // remove packets after encryption
    return msg;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.<span class="apidocCodeKeywordSpan">encrypt</span>(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.getEncryptionKeyIds" id="apidoc.element.openpgp.message.Message.prototype.getEncryptionKeyIds">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>getEncryptionKeyIds
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getEncryptionKeyIds = function () {
  var keyIds = [];
  var pkESKeyPacketlist = this.packets.filterByTag(_enums2.default.packet.publicKeyEncryptedSessionKey);
  pkESKeyPacketlist.forEach(function (packet) {
    keyIds.push(packet.publicKeyId);
  });
  return keyIds;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      }
    }
  }
  if (!keyPacket) {
    throw new Error('No symmetrically encrypted session key packet found.');
  }
} else if (privateKey) {
  var encryptionKeyIds = this.<span class="apidocCodeKeywordSpan">getEncryptionKeyIds</span>();
  if (!encryptionKeyIds.length) {
    // nothing to decrypt
    return;
  }
  var privateKeyPacket = privateKey.getKeyPacket(encryptionKeyIds);
  if (!privateKeyPacket.isDecrypted) {
    throw new Error('Private key is not decrypted.');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.getFilename" id="apidoc.element.openpgp.message.Message.prototype.getFilename">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>getFilename
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFilename = function () {
  var literal = this.packets.findPacket(_enums2.default.packet.literal);
  return literal &amp;&amp; literal.getFilename() || null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Get filename from literal data packet
 * @return {(String|null)} filename of literal data packet as string
 */
Message.prototype.getFilename = function () {
  var literal = this.packets.findPacket(_enums2.default.packet.literal);
  return literal &amp;&amp; literal.<span class="apidocCodeKeywordSpan">getFilename</span>() || null;
};

/**
 * Get literal data as text
 * @return {(String|null)} literal body of the message interpreted as text
 */
Message.prototype.getText = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.getLiteralData" id="apidoc.element.openpgp.message.Message.prototype.getLiteralData">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>getLiteralData
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLiteralData = function () {
  var literal = this.packets.findPacket(_enums2.default.packet.literal);
  return literal &amp;&amp; literal.data || null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {Message} message   the message object to be parse
 * @param  {String} format     the output format e.g. 'utf8' or 'binary'
 * @return {Object}            the parse data in the respective format
 */
function parseMessage(message, format) {
if (format === 'binary') {
  return {
    data: message.<span class="apidocCodeKeywordSpan">getLiteralData</span>(),
    filename: message.getFilename()
  };
} else if (format === 'utf8') {
  return {
    data: message.getText(),
    filename: message.getFilename()
  };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.getSigningKeyIds" id="apidoc.element.openpgp.message.Message.prototype.getSigningKeyIds">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>getSigningKeyIds
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSigningKeyIds = function () {
  var keyIds = [];
  var msg = this.unwrapCompressed();
  // search for one pass signatures
  var onePassSigList = msg.packets.filterByTag(_enums2.default.packet.onePassSignature);
  onePassSigList.forEach(function (packet) {
    keyIds.push(packet.signingKeyId);
  });
  // if nothing found look for signature packets
  if (!keyIds.length) {
    var signatureList = msg.packets.filterByTag(_enums2.default.packet.signature);
    signatureList.forEach(function (packet) {
      keyIds.push(packet.issuerKeyId);
    });
  }
  return keyIds;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ].join('\n');

var plaintext = 'short message\nnext line\ní•œêµ­ì–´/ì¡°ì„&nbsp;ë§';
var sMsg = openpgp.message.readArmored(msg_armor);
var pubKey2 = openpgp.key.readArmored(pub_key_arm2).keys[0];
var pubKey3 = openpgp.key.readArmored(pub_key_arm3).keys[0];

var keyids = sMsg.<span class="apidocCodeKeywordSpan">getSigningKeyIds</span>();

expect(pubKey2.getKeyPacket(keyids)).to.exist;
expect(pubKey3.getKeyPacket(keyids)).to.exist;

expect(sMsg.getText()).to.equal(plaintext);

var verifiedSig = sMsg.verify([pubKey2, pubKey3]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.getText" id="apidoc.element.openpgp.message.Message.prototype.getText">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>getText
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getText = function () {
  var literal = this.packets.findPacket(_enums2.default.packet.literal);
  if (literal) {
    return literal.getText();
  } else {
    return null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Get literal data as text
* @return {(String|null)} literal body of the message interpreted as text
*/
Message.prototype.getText = function () {
 var literal = this.packets.findPacket(_enums2.default.packet.literal);
 if (literal) {
   return literal.<span class="apidocCodeKeywordSpan">getText</span>();
 } else {
   return null;
 }
};

/**
* Encrypt the message either with public keys, passwords, or both at once.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.sign" id="apidoc.element.openpgp.message.Message.prototype.sign">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>sign
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sign = function () {
  var privateKeys = arguments.length &lt;= 0 || arguments[0] === undefined ? [] : arguments[0];
  var signature = arguments.length &lt;= 1 || arguments[1] === undefined ? null : arguments[1];


  var packetlist = new _packet2.default.List();

  var literalDataPacket = this.packets.findPacket(_enums2.default.packet.literal);
  if (!literalDataPacket) {
    throw new Error('No literal data packet to sign.');
  }

  var literalFormat = _enums2.default.write(_enums2.default.literal, literalDataPacket.format);
  var signatureType = literalFormat === _enums2.default.literal.binary ? _enums2.default.signature.binary : _enums2.default.signature
.text;
  var i, signingKeyPacket, existingSigPacketlist, onePassSig;

  if (signature) {
    existingSigPacketlist = signature.packets.filterByTag(_enums2.default.packet.signature);
    if (existingSigPacketlist.length) {
      for (i = existingSigPacketlist.length - 1; i &gt;= 0; i--) {
        var sigPacket = existingSigPacketlist[i];
        onePassSig = new _packet2.default.OnePassSignature();
        onePassSig.type = signatureType;
        onePassSig.hashAlgorithm = _config2.default.prefer_hash_algorithm;
        onePassSig.publicKeyAlgorithm = sigPacket.publicKeyAlgorithm;
        onePassSig.signingKeyId = sigPacket.issuerKeyId;
        if (!privateKeys.length &amp;&amp; i === 0) {
          onePassSig.flags = 1;
        }
        packetlist.push(onePassSig);
      }
    }
  }
  for (i = 0; i &lt; privateKeys.length; i++) {
    if (privateKeys[i].isPublic()) {
      throw new Error('Need private key for signing');
    }
    onePassSig = new _packet2.default.OnePassSignature();
    onePassSig.type = signatureType;
    //TODO get preferred hashg algo from key signature
    onePassSig.hashAlgorithm = _config2.default.prefer_hash_algorithm;
    signingKeyPacket = privateKeys[i].getSigningKeyPacket();
    if (!signingKeyPacket) {
      throw new Error('Could not find valid key packet for signing in key ' + privateKeys[i].primaryKey.getKeyId().toHex());
    }
    onePassSig.publicKeyAlgorithm = signingKeyPacket.algorithm;
    onePassSig.signingKeyId = signingKeyPacket.getKeyId();
    if (i === privateKeys.length - 1) {
      onePassSig.flags = 1;
    }
    packetlist.push(onePassSig);
  }

  packetlist.push(literalDataPacket);

  for (i = privateKeys.length - 1; i &gt;= 0; i--) {
    var signaturePacket = new _packet2.default.Signature();
    signaturePacket.signatureType = signatureType;
    signaturePacket.hashAlgorithm = _config2.default.prefer_hash_algorithm;
    signaturePacket.publicKeyAlgorithm = signingKeyPacket.algorithm;
    if (!signingKeyPacket.isDecrypted) {
      throw new Error('Private key is not decrypted.');
    }
    signaturePacket.sign(signingKeyPacket, literalDataPacket);
    packetlist.push(signaturePacket);
  }

  if (signature) {
    packetlist.concat(existingSigPacketlist);
  }

  return new Message(packetlist);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
options = {
data: 'Hello, World!',                             // input as String (or Uint8Array)
privateKeys: privKeyObj // for signing
};

openpgp.<span class="apidocCodeKeywordSpan">sign</span>(options).then(function(signed) {
cleartext = signed.data; // '-----BEGIN PGP SIGNED MESSAGE ... END PGP SIGNATURE-----'
});
```

```js
options = {
message: openpgp.cleartext.readArmored(cleartext), // parse armored message
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.signDetached" id="apidoc.element.openpgp.message.Message.prototype.signDetached">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>signDetached
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">signDetached = function () {
  var privateKeys = arguments.length &lt;= 0 || arguments[0] === undefined ? [] : arguments[0];
  var signature = arguments.length &lt;= 1 || arguments[1] === undefined ? null : arguments[1];


  var packetlist = new _packet2.default.List();

  var literalDataPacket = this.packets.findPacket(_enums2.default.packet.literal);
  if (!literalDataPacket) {
    throw new Error('No literal data packet to sign.');
  }

  var literalFormat = _enums2.default.write(_enums2.default.literal, literalDataPacket.format);
  var signatureType = literalFormat === _enums2.default.literal.binary ? _enums2.default.signature.binary : _enums2.default.signature
.text;

  for (var i = 0; i &lt; privateKeys.length; i++) {
    var signingKeyPacket = privateKeys[i].getSigningKeyPacket();
    var signaturePacket = new _packet2.default.Signature();
    signaturePacket.signatureType = signatureType;
    signaturePacket.hashAlgorithm = _config2.default.prefer_hash_algorithm;
    signaturePacket.publicKeyAlgorithm = signingKeyPacket.algorithm;
    if (!signingKeyPacket.isDecrypted) {
      throw new Error('Private key is not decrypted.');
    }
    signaturePacket.sign(signingKeyPacket, literalDataPacket);
    packetlist.push(signaturePacket);
  }
  if (signature) {
    var existingSigPacketlist = signature.packets.filterByTag(_enums2.default.packet.signature);
    packetlist.concat(existingSigPacketlist);
  }

  return new sigModule.Signature(packetlist);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
* Sign the cleartext message
* @param  {Array&lt;module:key~Key&gt;} privateKeys private keys with decrypted secret key data for signing
*/
CleartextMessage.prototype.sign = function (privateKeys) {
 this.signature = this.<span class="apidocCodeKeywordSpan">signDetached</span>(privateKeys);
};

/**
* Sign the cleartext message
* @param  {Array&lt;module:key~Key&gt;} privateKeys private keys with decrypted secret key data for signing
* @return {module:signature~Signature}      new detached signature of message content
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.unwrapCompressed" id="apidoc.element.openpgp.message.Message.prototype.unwrapCompressed">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>unwrapCompressed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unwrapCompressed = function () {
  var compressed = this.packets.filterByTag(_enums2.default.packet.compressed);
  if (compressed.length) {
    return new Message(compressed[0].packets);
  } else {
    return this;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Returns the key IDs of the keys that signed the message
 * @return {Array&lt;module:type/keyid&gt;} array of keyid objects
 */
Message.prototype.getSigningKeyIds = function () {
var keyIds = [];
var msg = this.<span class="apidocCodeKeywordSpan">unwrapCompressed</span>();
// search for one pass signatures
var onePassSigList = msg.packets.filterByTag(_enums2.default.packet.onePassSignature);
onePassSigList.forEach(function (packet) {
  keyIds.push(packet.signingKeyId);
});
// if nothing found look for signature packets
if (!keyIds.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.verify" id="apidoc.element.openpgp.message.Message.prototype.verify">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>verify
        <span class="apidocSignatureSpan">(keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verify = function (keys) {
  var msg = this.unwrapCompressed();
  var literalDataList = msg.packets.filterByTag(_enums2.default.packet.literal);
  if (literalDataList.length !== 1) {
    throw new Error('Can only verify message with one literal data packet.');
  }
  var signatureList = msg.packets.filterByTag(_enums2.default.packet.signature);
  return createVerificationObjects(signatureList, literalDataList, keys);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
options = {
    message: openpgp.cleartext.readArmored(cleartext), // parse armored message
    publicKeys: openpgp.key.readArmored(pubkey).keys   // for verification
};

openpgp.<span class="apidocCodeKeywordSpan">verify</span>(options).then(function(verified) {
	validity = verified.signatures[0].valid; // true
	if (validity) {
		console.log('signed by key id ' + verified.signatures[0].keyid.toHex());
	}
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.message.Message.prototype.verifyDetached" id="apidoc.element.openpgp.message.Message.prototype.verifyDetached">
        function <span class="apidocSignatureSpan">openpgp.message.Message.prototype.</span>verifyDetached
        <span class="apidocSignatureSpan">(signature, keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verifyDetached = function (signature, keys) {
  var msg = this.unwrapCompressed();
  var literalDataList = msg.packets.filterByTag(_enums2.default.packet.literal);
  if (literalDataList.length !== 1) {
    throw new Error('Can only verify message with one literal data packet.');
  }
  var signatureList = signature.packets;
  return createVerificationObjects(signatureList, literalDataList, keys);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Verify signatures of cleartext signed message
* @param {Array&lt;module:key~Key&gt;} keys array of keys to verify signatures
* @return {Array&lt;{keyid: module:type/keyid, valid: Boolean}&gt;} list of signer's keyid and validity of signature
*/
CleartextMessage.prototype.verify = function (keys) {
 return this.<span class="apidocCodeKeywordSpan">verifyDetached</span>(this.signature, keys);
};

/**
* Verify signatures of cleartext signed message
* @param {Array&lt;module:key~Key&gt;} keys array of keys to verify signatures
* @return {Array&lt;{keyid: module:type/keyid, valid: Boolean}&gt;} list of signer's keyid and validity of signature
*/
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet" id="apidoc.module.openpgp.packet">module openpgp.packet</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.Compressed" id="apidoc.element.openpgp.packet.Compressed">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>Compressed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Compressed() {
<span class="apidocCodeCommentSpan">  /**
   * Packet type
   * @type {module:enums.packet}
   */
</span>  this.tag = _enums2.default.packet.compressed;
  /**
   * List of packets
   * @type {module:packet/packetlist}
   */
  this.packets = null;
  /**
   * Compression algorithm
   * @type {compression}
   */
  this.algorithm = 'zip';

  /**
   * Compressed packet data
   * @type {String}
   */
  this.compressed = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.List" id="apidoc.element.openpgp.packet.List">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>List
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Packetlist() {
<span class="apidocCodeCommentSpan">  /** The number of packets contained within the list.
   * @readonly
   * @type {Integer} */
</span>  this.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new CleartextMessage(text, signature);
  }
  // normalize EOL to canonical form &lt;CR&gt;&lt;LF&gt;
  this.text = text.replace(/\r/g, '').replace(/[\t ]+\n/g, "\n").replace(/\n/g, "\r\n");
  if (signature &amp;&amp; !(signature instanceof sigModule.Signature)) {
    throw new Error('Invalid signature input');
  }
  this.signature = signature || new sigModule.Signature(new _packet2.default.<span class="apidocCodeKeywordSpan">List</span>());
}

/**
 * Returns the key IDs of the keys that signed the cleartext message
 * @return {Array&lt;module:type/keyid&gt;} array of keyid objects
 */
CleartextMessage.prototype.getSigningKeyIds = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Literal" id="apidoc.element.openpgp.packet.Literal">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>Literal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Literal() {
  this.tag = _enums2.default.packet.literal;
  this.format = 'utf8'; // default format for literal data packets
  this.date = new Date();
  this.data = new Uint8Array(0); // literal data representation
  this.filename = 'msg.txt';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Sign the cleartext message
 * @param  {Array&lt;module:key~Key&gt;} privateKeys private keys with decrypted secret key data for signing
 * @return {module:signature~Signature}      new detached signature of message content
 */
CleartextMessage.prototype.signDetached = function (privateKeys) {
var packetlist = new _packet2.default.List();
var literalDataPacket = new _packet2.default.<span class="apidocCodeKeywordSpan">Literal</span>();
literalDataPacket.setText(this.text);
for (var i = 0; i &lt; privateKeys.length; i++) {
  if (privateKeys[i].isPublic()) {
    throw new Error('Need private key for signing');
  }
  var signaturePacket = new _packet2.default.Signature();
  signaturePacket.signatureType = _enums2.default.signature.text;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Marker" id="apidoc.element.openpgp.packet.Marker">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>Marker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Marker() {
  this.tag = _enums2.default.packet.marker;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.OnePassSignature" id="apidoc.element.openpgp.packet.OnePassSignature">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>OnePassSignature
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OnePassSignature() {
  this.tag = _enums2.default.packet.onePassSignature; // The packet type
  this.version = null; // A one-octet version number.  The current version is 3.
  this.type = null; // A one-octet signature type.  Signature types are described in {@link http://tools.ietf.org/html/rfc4880#section
-5.2.1|RFC4880 Section 5.2.1}.
  this.hashAlgorithm = null; // A one-octet number describing the hash algorithm used. (See {@link http://tools.ietf.org/html/rfc4880
#section-9.4|RFC4880 9.4})
  this.publicKeyAlgorithm = null; // A one-octet number describing the public-key algorithm used. (See {@link http://tools.ietf.
org/html/rfc4880#section-9.1|RFC4880 9.1})
  this.signingKeyId = null; // An eight-octet number holding the Key ID of the signing key.
  this.flags = null; //  A one-octet number holding a flag showing whether the signature is nested.  A zero value indicates that
 the next packet is another One-Pass Signature packet that describes another signature to be applied to the same message data.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var i, signingKeyPacket, existingSigPacketlist, onePassSig;

if (signature) {
  existingSigPacketlist = signature.packets.filterByTag(_enums2.default.packet.signature);
  if (existingSigPacketlist.length) {
    for (i = existingSigPacketlist.length - 1; i &gt;= 0; i--) {
      var sigPacket = existingSigPacketlist[i];
      onePassSig = new _packet2.default.<span class="apidocCodeKeywordSpan">OnePassSignature</span>();
      onePassSig.type = signatureType;
      onePassSig.hashAlgorithm = _config2.default.prefer_hash_algorithm;
      onePassSig.publicKeyAlgorithm = sigPacket.publicKeyAlgorithm;
      onePassSig.signingKeyId = sigPacket.issuerKeyId;
      if (!privateKeys.length &amp;&amp; i === 0) {
        onePassSig.flags = 1;
      }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKey" id="apidoc.element.openpgp.packet.PublicKey">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>PublicKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PublicKey() {
  this.tag = _enums2.default.packet.publicKey;
  this.version = 4;
<span class="apidocCodeCommentSpan">  /** Key creation date.
   * @type {Date} */
</span>  this.created = new Date();
  /** A list of multiprecision integers
   * @type {module:type/mpi} */
  this.mpi = [];
  /** Public key algorithm
   * @type {module:enums.publicKey} */
  this.algorithm = 'rsa_sign';
  // time in days (V3 only)
  this.expirationTimeV3 = 0;
  /**
   * Fingerprint in lowercase hex
   * @type {String}
   */
  this.fingerprint = null;
  /**
   * Keyid
   * @type {module:type/keyid}
   */
  this.keyid = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var packetlist = new _packet2.default.List();
var keyPackets = this.toPacketlist();
var bytes;
for (var i = 0; i &lt; keyPackets.length; i++) {
  switch (keyPackets[i].tag) {
    case _enums2.default.packet.secretKey:
      bytes = keyPackets[i].writePublicKey();
      var pubKeyPacket = new _packet2.default.<span class="apidocCodeKeywordSpan">PublicKey</span>();
      pubKeyPacket.read(bytes);
      packetlist.push(pubKeyPacket);
      break;
    case _enums2.default.packet.secretSubkey:
      bytes = keyPackets[i].writePublicKey();
      var pubSubkeyPacket = new _packet2.default.PublicSubkey();
      pubSubkeyPacket.read(bytes);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey" id="apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>PublicKeyEncryptedSessionKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PublicKeyEncryptedSessionKey() {
  this.tag = _enums2.default.packet.publicKeyEncryptedSessionKey;
  this.version = 3;

  this.publicKeyId = new _keyid2.default();
  this.publicKeyAlgorithm = 'rsa_encrypt';

  this.sessionKey = null;
  this.sessionKeyAlgorithm = 'aes256';

<span class="apidocCodeCommentSpan">  /** @type {Array&lt;module:type/mpi&gt;} */
</span>  this.encrypted = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function encryptSessionKey(sessionKey, symAlgo, publicKeys, passwords) {
var packetlist = new _packet2.default.List();

if (publicKeys) {
  publicKeys.forEach(function (key) {
    var encryptionKeyPacket = key.getEncryptionKeyPacket();
    if (encryptionKeyPacket) {
      var pkESKeyPacket = new _packet2.default.<span class="apidocCodeKeywordSpan">PublicKeyEncryptedSessionKey</span>();
      pkESKeyPacket.publicKeyId = encryptionKeyPacket.getKeyId();
      pkESKeyPacket.publicKeyAlgorithm = encryptionKeyPacket.algorithm;
      pkESKeyPacket.sessionKey = sessionKey;
      pkESKeyPacket.sessionKeyAlgorithm = symAlgo;
      pkESKeyPacket.encrypt(encryptionKeyPacket);
      delete pkESKeyPacket.sessionKey; // delete plaintext session key after encryption
      packetlist.push(pkESKeyPacket);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicSubkey" id="apidoc.element.openpgp.packet.PublicSubkey">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>PublicSubkey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PublicSubkey() {
  _public_key2.default.call(this);
  this.tag = _enums2.default.packet.publicSubkey;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      bytes = keyPackets[i].writePublicKey();
      var pubKeyPacket = new _packet2.default.PublicKey();
      pubKeyPacket.read(bytes);
      packetlist.push(pubKeyPacket);
      break;
    case _enums2.default.packet.secretSubkey:
      bytes = keyPackets[i].writePublicKey();
      var pubSubkeyPacket = new _packet2.default.<span class="apidocCodeKeywordSpan">PublicSubkey</span>();
      pubSubkeyPacket.read(bytes);
      packetlist.push(pubSubkeyPacket);
      break;
    default:
      packetlist.push(keyPackets[i]);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretKey" id="apidoc.element.openpgp.packet.SecretKey">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>SecretKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SecretKey() {
  _public_key2.default.call(this);
  this.tag = _enums2.default.packet.secretKey;
  // encrypted secret-key data
  this.encrypted = null;
  // indicator if secret-key data is available in decrypted form
  this.isDecrypted = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return Promise.all([generateSecretKey(), generateSecretSubkey()]).then(function () {
    return wrapKeyObject(secretKeyPacket, secretSubkeyPacket, options);
  });
});

function generateSecretKey() {
  secretKeyPacket = new _packet2.default.<span class="apidocCodeKeywordSpan">SecretKey</span>();
  secretKeyPacket.algorithm = _enums2.default.read(_enums2.default.publicKey, options.keyType);
  return secretKeyPacket.generate(options.numBits);
}

function generateSecretSubkey() {
  secretSubkeyPacket = new _packet2.default.SecretSubkey();
  secretSubkeyPacket.algorithm = _enums2.default.read(_enums2.default.publicKey, options.keyType);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretSubkey" id="apidoc.element.openpgp.packet.SecretSubkey">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>SecretSubkey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SecretSubkey() {
  _secret_key2.default.call(this);
  this.tag = _enums2.default.packet.secretSubkey;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 function generateSecretKey() {
   secretKeyPacket = new _packet2.default.SecretKey();
   secretKeyPacket.algorithm = _enums2.default.read(_enums2.default.publicKey, options.keyType);
   return secretKeyPacket.generate(options.numBits);
 }

 function generateSecretSubkey() {
   secretSubkeyPacket = new _packet2.default.<span class="apidocCodeKeywordSpan">SecretSubkey</span>();
   secretSubkeyPacket.algorithm = _enums2.default.read(_enums2.default.publicKey, options.keyType);
   return secretSubkeyPacket.generate(options.numBits);
 }
}

/**
* Reformats and signs an OpenPGP with a given User ID. Currently only supports RSA keys.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Signature" id="apidoc.element.openpgp.packet.Signature">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>Signature
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Signature() {
  this.tag = _enums2.default.packet.signature;
  this.version = 4;
  this.signatureType = null;
  this.hashAlgorithm = null;
  this.publicKeyAlgorithm = null;

  this.signatureData = null;
  this.unhashedSubpackets = null;
  this.signedHashValue = null;

  this.created = new Date();
  this.signatureExpirationTime = null;
  this.signatureNeverExpires = true;
  this.exportable = null;
  this.trustLevel = null;
  this.trustAmount = null;
  this.regularExpression = null;
  this.revocable = null;
  this.keyExpirationTime = null;
  this.keyNeverExpires = null;
  this.preferredSymmetricAlgorithms = null;
  this.revocationKeyClass = null;
  this.revocationKeyAlgorithm = null;
  this.revocationKeyFingerprint = null;
  this.issuerKeyId = new _keyid2.default();
  this.notation = null;
  this.preferredHashAlgorithms = null;
  this.preferredCompressionAlgorithms = null;
  this.keyServerPreferences = null;
  this.preferredKeyServer = null;
  this.isPrimaryUserID = null;
  this.policyURI = null;
  this.keyFlags = null;
  this.signersUserId = null;
  this.reasonForRevocationFlag = null;
  this.reasonForRevocationString = null;
  this.features = null;
  this.signatureTargetPublicKeyAlgorithm = null;
  this.signatureTargetHashAlgorithm = null;
  this.signatureTargetHash = null;
  this.embeddedSignature = null;

  this.verified = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new CleartextMessage(text, signature);
  }
  // normalize EOL to canonical form &lt;CR&gt;&lt;LF&gt;
  this.text = text.replace(/\r/g, '').replace(/[\t ]+\n/g, "\n").replace(/\n/g, "\r\n");
  if (signature &amp;&amp; !(signature instanceof sigModule.Signature)) {
    throw new Error('Invalid signature input');
  }
  this.signature = signature || new sigModule.<span class="apidocCodeKeywordSpan">Signature</span>(new _packet2.default.List());
}

/**
 * Returns the key IDs of the keys that signed the cleartext message
 * @return {Array&lt;module:type/keyid&gt;} array of keyid objects
 */
CleartextMessage.prototype.getSigningKeyIds = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected" id="apidoc.element.openpgp.packet.SymEncryptedAEADProtected">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>SymEncryptedAEADProtected
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymEncryptedAEADProtected() {
  this.tag = _enums2.default.packet.symEncryptedAEADProtected;
  this.version = VERSION;
  this.iv = null;
  this.encrypted = null;
  this.packets = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  throw new Error('No keys or passwords');
}

var sessionKey = _crypto2.default.generateSessionKey(_enums2.default.read(_enums2.default.symmetric, symAlgo));
msg = encryptSessionKey(sessionKey, _enums2.default.read(_enums2.default.symmetric, symAlgo), keys, passwords);

if (_config2.default.aead_protect) {
  symEncryptedPacket = new _packet2.default.<span class="apidocCodeKeywordSpan">SymEncryptedAEADProtected</span>();
} else if (_config2.default.integrity_protect) {
  symEncryptedPacket = new _packet2.default.SymEncryptedIntegrityProtected();
} else {
  symEncryptedPacket = new _packet2.default.SymmetricallyEncrypted();
}
symEncryptedPacket.packets = _this2.packets;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected" id="apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>SymEncryptedIntegrityProtected
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymEncryptedIntegrityProtected() {
  this.tag = _enums2.default.packet.symEncryptedIntegrityProtected;
  this.version = VERSION;
<span class="apidocCodeCommentSpan">  /** The encrypted payload. */
</span>  this.encrypted = null; // string
  /**
   * If after decrypting the packet this is set to true,
   * a modification has been detected and thus the contents
   * should be discarded.
   * @type {Boolean}
   */
  this.modification = false;
  this.packets = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var sessionKey = _crypto2.default.generateSessionKey(_enums2.default.read(_enums2.default.symmetric, symAlgo));
  msg = encryptSessionKey(sessionKey, _enums2.default.read(_enums2.default.symmetric, symAlgo), keys, passwords);

  if (_config2.default.aead_protect) {
    symEncryptedPacket = new _packet2.default.SymEncryptedAEADProtected();
  } else if (_config2.default.integrity_protect) {
    symEncryptedPacket = new _packet2.default.<span class="apidocCodeKeywordSpan">SymEncryptedIntegrityProtected</span>();
  } else {
    symEncryptedPacket = new _packet2.default.SymmetricallyEncrypted();
  }
  symEncryptedPacket.packets = _this2.packets;

  return symEncryptedPacket.encrypt(_enums2.default.read(_enums2.default.symmetric, symAlgo), sessionKey);
}).then(function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey" id="apidoc.element.openpgp.packet.SymEncryptedSessionKey">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>SymEncryptedSessionKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymEncryptedSessionKey() {
  this.tag = _enums2.default.packet.symEncryptedSessionKey;
  this.version = 4;
  this.sessionKey = null;
  this.sessionKeyEncryptionAlgorithm = null;
  this.sessionKeyAlgorithm = 'aes256';
  this.encrypted = null;
  this.s2k = new _s2k2.default();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      throw new Error('Could not find valid key packet for encryption in key ' + key.primaryKey.getKeyId().toHex());
    }
  });
}

if (passwords) {
  passwords.forEach(function (password) {
    var symEncryptedSessionKeyPacket = new _packet2.default.<span class="apidocCodeKeywordSpan">SymEncryptedSessionKey</span>();
    symEncryptedSessionKeyPacket.sessionKey = sessionKey;
    symEncryptedSessionKeyPacket.sessionKeyAlgorithm = symAlgo;
    symEncryptedSessionKeyPacket.encrypt(password);
    delete symEncryptedSessionKeyPacket.sessionKey; // delete plaintext session key after encryption
    packetlist.push(symEncryptedSessionKeyPacket);
  });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted" id="apidoc.element.openpgp.packet.SymmetricallyEncrypted">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>SymmetricallyEncrypted
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymmetricallyEncrypted() {
  this.tag = _enums2.default.packet.symmetricallyEncrypted;
  this.encrypted = null;
<span class="apidocCodeCommentSpan">  /** Decrypted packets contained within.
   * @type {module:packet/packetlist} */
</span>  this.packets = null;
  this.ignore_mdc_error = _config2.default.ignore_mdc_error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  msg = encryptSessionKey(sessionKey, _enums2.default.read(_enums2.default.symmetric, symAlgo), keys, passwords);

  if (_config2.default.aead_protect) {
    symEncryptedPacket = new _packet2.default.SymEncryptedAEADProtected();
  } else if (_config2.default.integrity_protect) {
    symEncryptedPacket = new _packet2.default.SymEncryptedIntegrityProtected();
  } else {
    symEncryptedPacket = new _packet2.default.<span class="apidocCodeKeywordSpan">SymmetricallyEncrypted</span>();
  }
  symEncryptedPacket.packets = _this2.packets;

  return symEncryptedPacket.encrypt(_enums2.default.read(_enums2.default.symmetric, symAlgo), sessionKey);
}).then(function () {
  msg.packets.push(symEncryptedPacket);
  symEncryptedPacket.packets = new _packet2.default.List(); // remove packets after encryption
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Trust" id="apidoc.element.openpgp.packet.Trust">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>Trust
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Trust() {
  this.tag = _enums2.default.packet.trust;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.UserAttribute" id="apidoc.element.openpgp.packet.UserAttribute">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>UserAttribute
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UserAttribute() {
  this.tag = _enums2.default.packet.userAttribute;
  this.attributes = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Userid" id="apidoc.element.openpgp.packet.Userid">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>Userid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Userid() {
  this.tag = _enums2.default.packet.userid;
<span class="apidocCodeCommentSpan">  /** A string containing the user id. Usually in the form
   * John Doe &lt;john@example.com&gt;
   * @type {String}
   */
</span>  this.userid = '';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var packetlist = new _packet2.default.List();

  packetlist.push(secretKeyPacket);

  options.userIds.forEach(function (userId, index) {

var userIdPacket = new _packet2.default.<span class="apidocCodeKeywordSpan">Userid</span>();
userIdPacket.read(_util2.default.str2Uint8Array(userId));

var dataToSign = {};
dataToSign.userid = userIdPacket;
dataToSign.key = secretKeyPacket;
var signaturePacket = new _packet2.default.Signature();
signaturePacket.signatureType = _enums2.default.signature.cert_generic;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.fromStructuredClone" id="apidoc.element.openpgp.packet.fromStructuredClone">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>fromStructuredClone
        <span class="apidocSignatureSpan">(packetClone)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromStructuredClone(packetClone) {
  var tagName = _enums2.default.read(_enums2.default.packet, packetClone.tag);
  var packet = newPacketFromTag(tagName);
  for (var attr in packetClone) {
    if (packetClone.hasOwnProperty(attr)) {
      packet[attr] = packetClone[attr];
    }
  }
  if (packet.postCloneTypeFix) {
    packet.postCloneTypeFix();
  }
  return packet;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (options.signature) {
    options.signature = packetlistCloneToSignature(options.signature);
  }
  return options;
}

function packetlistCloneToKey(clone) {
  var packetlist = _packetlist2.default.<span class="apidocCodeKeywordSpan">fromStructuredClone</span>(clone);
  return new key.Key(packetlist);
}

function packetlistCloneToMessage(clone) {
  var packetlist = _packetlist2.default.fromStructuredClone(clone);
  return new message.Message(packetlist);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.newPacketFromTag" id="apidoc.element.openpgp.packet.newPacketFromTag">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>newPacketFromTag
        <span class="apidocSignatureSpan">(tag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function newPacketFromTag(tag) {
  return new packets[packetClassFromTagName(tag)]();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  while (i &lt; bytes.length) {
var parsed = _packet2.default.read(bytes, i, bytes.length - i);
i = parsed.offset;

var pushed = false;
try {
  var tag = _enums2.default.read(_enums2.default.packet, parsed.tag);
  var packet = packets.<span class="apidocCodeKeywordSpan">newPacketFromTag</span>(tag);
  this.push(packet);
  pushed = true;
  packet.read(parsed.packet);
} catch (e) {
  if (!_config2.default.tolerant || parsed.tag == _enums2.default.packet.symmetricallyEncrypted || parsed.tag == _enums2.default
.packet.literal || parsed.tag == _enums2.default.packet.compressed) {
    throw e;
  }
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.Compressed" id="apidoc.module.openpgp.packet.Compressed">module openpgp.packet.Compressed</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.Compressed.Compressed" id="apidoc.element.openpgp.packet.Compressed.Compressed">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>Compressed
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Compressed() {
<span class="apidocCodeCommentSpan">  /**
   * Packet type
   * @type {module:enums.packet}
   */
</span>  this.tag = _enums2.default.packet.compressed;
  /**
   * List of packets
   * @type {module:packet/packetlist}
   */
  this.packets = null;
  /**
   * Compression algorithm
   * @type {compression}
   */
  this.algorithm = 'zip';

  /**
   * Compressed packet data
   * @type {String}
   */
  this.compressed = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.Compressed.prototype" id="apidoc.module.openpgp.packet.Compressed.prototype">module openpgp.packet.Compressed.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.Compressed.prototype.compress" id="apidoc.element.openpgp.packet.Compressed.prototype.compress">
        function <span class="apidocSignatureSpan">openpgp.packet.Compressed.prototype.</span>compress
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compress = function () {
  var uncompressed, deflate;
  uncompressed = this.packets.write();

  switch (this.algorithm) {

    case 'uncompressed':
      // - Uncompressed
      this.compressed = uncompressed;
      break;

    case 'zip':
      // - ZIP [RFC1951]
      deflate = new _rawdeflateMin2.default.Zlib.RawDeflate(uncompressed);
      this.compressed = deflate.compress();
      break;

    case 'zlib':
      // - ZLIB [RFC1950]
      deflate = new _zlibMin2.default.Zlib.Deflate(uncompressed);
      this.compressed = deflate.compress();
      break;

    case 'bzip2':
      //  - BZip2 [BZ2]
      // TODO: need to implement this
      throw new Error("Compression algorithm BZip2 [BZ2] is not implemented.");

    default:
      throw new Error("Compression algorithm unknown :" + this.type);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Return the compressed packet.
* @return {String} binary compressed packet
*/
Compressed.prototype.write = function () {
 if (this.compressed === null) {
   this.<span class="apidocCodeKeywordSpan">compress</span>();
 }

 return _util2.default.concatUint8Array(new Uint8Array([_enums2.default.write(_enums2.default.compression, this.algorithm)]), this
.compressed);
};

/**
* Decompression method for decompressing the compressed data
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Compressed.prototype.decompress" id="apidoc.element.openpgp.packet.Compressed.prototype.decompress">
        function <span class="apidocSignatureSpan">openpgp.packet.Compressed.prototype.</span>decompress
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decompress = function () {
  var decompressed, inflate;

  switch (this.algorithm) {
    case 'uncompressed':
      decompressed = this.compressed;
      break;

    case 'zip':
      inflate = new _rawinflateMin2.default.Zlib.RawInflate(this.compressed);
      decompressed = inflate.decompress();
      break;

    case 'zlib':
      inflate = new _zlibMin2.default.Zlib.Inflate(this.compressed);
      decompressed = inflate.decompress();
      break;

    case 'bzip2':
      // TODO: need to implement this
      throw new Error('Compression algorithm BZip2 [BZ2] is not implemented.');

    default:
      throw new Error("Compression algorithm unknown :" + this.algorithm);
  }

  this.packets.read(decompressed);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Compressed.prototype.read = function (bytes) {
  // One octet that gives the algorithm used to compress the packet.
  this.algorithm = _enums2.default.read(_enums2.default.compression, bytes[0]);

  // Compressed data, which makes up the remainder of the packet.
  this.compressed = bytes.subarray(1, bytes.length);

  this.<span class="apidocCodeKeywordSpan">decompress</span>();
};

/**
 * Return the compressed packet.
 * @return {String} binary compressed packet
 */
Compressed.prototype.write = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Compressed.prototype.read" id="apidoc.element.openpgp.packet.Compressed.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.Compressed.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  // One octet that gives the algorithm used to compress the packet.
  this.algorithm = _enums2.default.read(_enums2.default.compression, bytes[0]);

  // Compressed data, which makes up the remainder of the packet.
  this.compressed = bytes.subarray(1, bytes.length);

  this.decompress();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Compressed.prototype.write" id="apidoc.element.openpgp.packet.Compressed.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.Compressed.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  if (this.compressed === null) {
    this.compress();
  }

  return _util2.default.concatUint8Array(new Uint8Array([_enums2.default.write(_enums2.default.compression, this.algorithm)]), this
.compressed);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.List" id="apidoc.module.openpgp.packet.List">module openpgp.packet.List</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.List.List" id="apidoc.element.openpgp.packet.List.List">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>List
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Packetlist() {
<span class="apidocCodeCommentSpan">  /** The number of packets contained within the list.
   * @readonly
   * @type {Integer} */
</span>  this.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new CleartextMessage(text, signature);
  }
  // normalize EOL to canonical form &lt;CR&gt;&lt;LF&gt;
  this.text = text.replace(/\r/g, '').replace(/[\t ]+\n/g, "\n").replace(/\n/g, "\r\n");
  if (signature &amp;&amp; !(signature instanceof sigModule.Signature)) {
    throw new Error('Invalid signature input');
  }
  this.signature = signature || new sigModule.Signature(new _packet2.default.<span class="apidocCodeKeywordSpan">List</span>());
}

/**
 * Returns the key IDs of the keys that signed the cleartext message
 * @return {Array&lt;module:type/keyid&gt;} array of keyid objects
 */
CleartextMessage.prototype.getSigningKeyIds = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.List.fromStructuredClone" id="apidoc.element.openpgp.packet.List.fromStructuredClone">
        function <span class="apidocSignatureSpan">openpgp.packet.List.</span>fromStructuredClone
        <span class="apidocSignatureSpan">(packetlistClone)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromStructuredClone = function (packetlistClone) {
  var packetlist = new Packetlist();
  for (var i = 0; i &lt; packetlistClone.length; i++) {
    packetlist.push(packets.fromStructuredClone(packetlistClone[i]));
    if (packetlist[i].packets.length !== 0) {
      packetlist[i].packets = this.fromStructuredClone(packetlist[i].packets);
    } else {
      packetlist[i].packets = new Packetlist();
    }
  }
  return packetlist;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (options.signature) {
    options.signature = packetlistCloneToSignature(options.signature);
  }
  return options;
}

function packetlistCloneToKey(clone) {
  var packetlist = _packetlist2.default.<span class="apidocCodeKeywordSpan">fromStructuredClone</span>(clone);
  return new key.Key(packetlist);
}

function packetlistCloneToMessage(clone) {
  var packetlist = _packetlist2.default.fromStructuredClone(clone);
  return new message.Message(packetlist);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.List.prototype" id="apidoc.module.openpgp.packet.List.prototype">module openpgp.packet.List.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.List.prototype.concat" id="apidoc.element.openpgp.packet.List.prototype.concat">
        function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>concat
        <span class="apidocSignatureSpan">(packetlist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concat = function (packetlist) {
  if (packetlist) {
    for (var i = 0; i &lt; packetlist.length; i++) {
      this.push(packetlist[i]);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.<span class="apidocCodeKeywordSpan">concat</span>(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.List.prototype.filter" id="apidoc.element.openpgp.packet.List.prototype.filter">
        function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>filter
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (callback) {

  var filtered = new Packetlist();

  for (var i = 0; i &lt; this.length; i++) {
    if (callback(this[i], i, this)) {
      filtered.push(this[i]);
    }
  }

  return filtered;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {Array&lt;module:key~Key&gt;} keys array of keys to verify certificate signatures
 * @return {Array&lt;({keyid: module:type/keyid, valid: Boolean})&gt;} list of signer's keyid and validity of signature
 */
User.prototype.verifyAllSignatures = function (primaryKey, keys) {
var dataToVerify = { userid: this.userId || this.userAttribute, key: primaryKey };
var certificates = this.selfCertifications.concat(this.otherCertifications || []);
return certificates.map(function (signaturePacket) {
  var keyPackets = keys.<span class="apidocCodeKeywordSpan">filter</span>(function (key) {
    return key.getSigningKeyPacket(signaturePacket.issuerKeyId);
  });
  var valid = null;
  if (keyPackets.length &gt; 0) {
    valid = keyPackets.some(function (keyPacket) {
      return signaturePacket.verify(keyPacket.primaryKey, dataToVerify);
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.List.prototype.filterByTag" id="apidoc.element.openpgp.packet.List.prototype.filterByTag">
        function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>filterByTag
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterByTag = function () {
  var args = Array.prototype.slice.call(arguments);
  var filtered = new Packetlist();
  var that = this;

  function handle(packetType) {
    return that[i].tag === packetType;
  }
  for (var i = 0; i &lt; this.length; i++) {
    if (args.some(handle)) {
      filtered.push(this[i]);
    }
  }

  return filtered;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Returns the key IDs of the keys to which the session key is encrypted
 * @return {Array&lt;module:type/keyid&gt;} array of keyid objects
 */
Message.prototype.getEncryptionKeyIds = function () {
  var keyIds = [];
  var pkESKeyPacketlist = this.packets.<span class="apidocCodeKeywordSpan">filterByTag</span>(_enums2.default.packet.publicKeyEncryptedSessionKey
);
  pkESKeyPacketlist.forEach(function (packet) {
    keyIds.push(packet.publicKeyId);
  });
  return keyIds;
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.List.prototype.findPacket" id="apidoc.element.openpgp.packet.List.prototype.findPacket">
        function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>findPacket
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findPacket = function (type) {
  var packetlist = this.filterByTag(type);
  if (packetlist.length) {
    return packetlist[0];
  } else {
    var found = null;
    for (var i = 0; i &lt; this.length; i++) {
      if (this[i].packets.length) {
        found = this[i].packets.findPacket(type);
        if (found) {
          return found;
        }
      }
    }
  }
  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
* Get literal data that is the body of the message
* @return {(Uint8Array|null)} literal body of the message as Uint8Array
*/
Message.prototype.getLiteralData = function () {
 var literal = this.packets.<span class="apidocCodeKeywordSpan">findPacket</span>(_enums2.default.packet.literal);
 return literal &amp;&amp; literal.data || null;
};

/**
* Get filename from literal data packet
* @return {(String|null)} filename of literal data packet as string
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.List.prototype.forEach" id="apidoc.element.openpgp.packet.List.prototype.forEach">
        function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>forEach
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEach = function (callback) {
  for (var i = 0; i &lt; this.length; i++) {
    callback(this[i]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Returns the key IDs of the keys that signed the cleartext message
* @return {Array&lt;module:type/keyid&gt;} array of keyid objects
*/
CleartextMessage.prototype.getSigningKeyIds = function () {
 var keyIds = [];
 var signatureList = this.signature.packets;
 signatureList.<span class="apidocCodeKeywordSpan">forEach</span>(function (packet) {
   keyIds.push(packet.issuerKeyId);
 });
 return keyIds;
};

/**
* Sign the cleartext message
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.List.prototype.indexOfTag" id="apidoc.element.openpgp.packet.List.prototype.indexOfTag">
        function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>indexOfTag
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexOfTag = function () {
  var args = Array.prototype.slice.call(arguments);
  var tagIndex = [];
  var that = this;

  function handle(packetType) {
    return that[i].tag === packetType;
  }
  for (var i = 0; i &lt; this.length; i++) {
    if (args.some(handle)) {
      tagIndex.push(i);
    }
  }
  return tagIndex;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  try {
var input = _armor2.default.decode(armoredText);
if (!(input.type === _enums2.default.armor.public_key || input.type === _enums2.default.armor.private_key)) {
  throw new Error('Armored text not of type key');
}
var packetlist = new _packet2.default.List();
packetlist.read(input.data);
var keyIndex = packetlist.<span class="apidocCodeKeywordSpan">indexOfTag</span>(_enums2.default.packet.publicKey, _enums2.default
.packet.secretKey);
if (keyIndex.length === 0) {
  throw new Error('No key packet found in armored text');
}
for (var i = 0; i &lt; keyIndex.length; i++) {
  var oneKeyList = packetlist.slice(keyIndex[i], keyIndex[i + 1]);
  try {
    var newKey = new Key(oneKeyList);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.List.prototype.pop" id="apidoc.element.openpgp.packet.List.prototype.pop">
        function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>pop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pop = function () {
  if (this.length === 0) {
    return;
  }

  var packet = this[this.length - 1];
  delete this[this.length - 1];
  this.length--;

  return packet;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
a-31,2];case 42&gt;=a:return[273,a-35,3];case 50&gt;=a:return[274,a-43,3];case 58&gt;=a:return[275,a-51,3];case 66&gt;=a
:return[276,a-59,3];case 82&gt;=a:return[277,a-67,4];case 98&gt;=a:return[278,a-83,4];case 114&gt;=a:return[279,a-99,4];case
 130&gt;=a:return[280,a-115,4];case 162&gt;=a:return[281,a-131,5];case 194&gt;=a:return[282,a-163,5];case 226&gt;=a:return
[283,a-195,5];case 257&gt;=a:return[284,a-227,5];case 258===a:return[285,a-258,0];default:throw"invalid length: "+a;}}
var d=[],c,f;for(c=3;258&gt;=c;c++)f=e(c),d[c]=f[2]&lt;&lt;24|
f[1]&lt;&lt;16|f[0];return d}(),Ga=C?new Uint32Array(Fa):Fa;
function na(e,d){function c(a,c){var b=a.g,d=[],f=0,e;e=Ga[a.length];d[f++]=e&amp;65535;d[f++]=e&gt;&gt;16&amp;255;d[f++]=
e&gt;&gt;24;var g;switch(u){case 1===b:g=[0,b-1,0];break;case 2===b:g=[1,b-2,0];break;case 3===b:g=[2,b-3,0];break;case 4===
b:g=[3,b-4,0];break;case 6&gt;=b:g=[4,b-5,1];break;case 8&gt;=b:g=[5,b-7,1];break;case 12&gt;=b:g=[6,b-9,2];break;case 16&amp;#
x3e;=b:g=[7,b-13,2];break;case 24&gt;=b:g=[8,b-17,3];break;case 32&gt;=b:g=[9,b-25,3];break;case 48&gt;=b:g=[10,b-33,4];break
;case 64&gt;=b:g=[11,b-49,4];break;case 96&gt;=b:g=[12,b-
65,5];break;case 128&gt;=b:g=[13,b-97,5];break;case 192&gt;=b:g=[14,b-129,6];break;case 256&gt;=b:g=[15,b-193,6];break;case
 384&gt;=b:g=[16,b-257,7];break;case 512&gt;=b:g=[17,b-385,7];break;case 768&gt;=b:g=[18,b-513,8];break;case 1024&gt;=b:
g=[19,b-769,8];break;case 1536&gt;=b:g=[20,b-1025,9];break;case 2048&gt;=b:g=[21,b-1537,9];break;case 3072&gt;=b:g=[22,b-2049
,10];break;case 4096&gt;=b:g=[23,b-3073,10];break;case 6144&gt;=b:g=[24,b-4097,11];break;case 8192&gt;=b:g=[25,b-6145,11];
break;case 12288&gt;=b:g=[26,b-8193,12];break;case 16384&gt;=
b:g=[27,b-12289,12];break;case 24576&gt;=b:g=[28,b-16385,13];break;case 32768&gt;=b:g=[29,b-24577,13];break;default:throw"
;invalid distance";}e=g;d[f++]=e[0];d[f++]=e[1];d[f++]=e[2];var k,m;k=0;for(m=d.length;k&lt;m;++k)l[h++]=d[k];t[d[0]]++;w
[d[3]]++;q=a.length+c-1;x=null}var f,a,b,k,m,g={},p,v,x,l=C?new Uint16Array(2*d.length):[],h=0,q=0,t=new (C?Uint32Array:Array)(286
),w=new (C?Uint32Array:Array)(30),da=e.f,z;if(!C){for(b=0;285&gt;=b;)t[b++]=0;for(b=0;29&gt;=b;)w[b++]=0}t[256]=1;f=0;for(a=
d.length;f&lt;a;++f){b=
m=0;for(k=3;b&lt;k&amp;&amp;f+b!==a;++b)m=m&lt;&lt;8|d[f+b];g[m]===n&amp;&amp;(g[m]=[]);p=g[m];if(!(0&lt;q--)){for(;
0&lt;p.length&amp;&amp;32768&lt;f-p[0];)p.shift();if(f+3&gt;=a){x&amp;&amp;c(x,-1);b=0;for(k=a-f;b&lt;k;++b)z=d[f+b],
l[h++]=z,++t[z];break}0&lt;p.length?(v=Ha(d,f,p),x?x.length&lt;v.length?(z=d[f-1],l[h++]=z,++t[z],c(v,0)):c(x,-1):v.length&amp;#
x3c;da?x=v:c(v,0)):x?c(x,-1):(z=d[f],l[h++]=z,++t[z])}p.push(f)}l[h++]=256;t[256]++;e.j=t;e.i=w;return C?l.subarray(0,h):l}
function Ha(e,d,c){var f,a,b=0,k,m,g,p,v=e.length;m=0;p=c.length;a:for(;m&lt;p;m++){f=c[p-m-1];k=3;if(3&lt;b){for(g=b;3&lt;
;g;g--)if(e[f+g-1]!==e[d+g-1])continue a;k=b}for(;258&gt;k&amp;&amp;d+k&lt;v&amp;&amp;e[f+k]===e[d+k];)++k;k&gt;b&amp;
;&amp;(a=f,b=k);if(258===k)break}return new qa(b,d-a)}
function oa(e,d){var c=e.length,f=new ja(572),a=new (C?Uint8Array:Array)(c),b,k,m,g,p;if(!C)for(g=0;g&lt;c;g++)a[g]=0;for(g=0;
g&lt;c;++g)0&lt;e[g]&amp;&amp;f.push(g,e[g]);b=Array(f.length/2);k=new (C?Uint32Array:Array)(f.length/2);if(1===b.length)return
 a[f.<span class="apidocCodeKeywordSpan">pop</span>().index]=1,a;g=0;for(p=f.length/2;g&lt;p;++g)b[g]=f.pop(),k[g]=b[g].value;
m=Ja(k,k.length,d);g=0;for(p=b.length;g&lt;p;++g)a[b[g].index]=m[g];return a}
function Ja(e,d,c){function f(a){var b=g[a][p[a]];b===d?(f(a+1),f(a+1)):--k[b];++p[a]}var a=new (C?Uint16Array:Array)(c),b=new (
C?Uint8Array:Array)(c),k=new (C?Uint8Array:Array)(d),m=Array(c),g=Array(c),p=Array(c),v=(1&lt;&lt;c)-d,x=1&lt;&lt;c-1,l,
h,q,t,w;a[c-1]=d;for(h=0;h&lt;c;++h)v&lt;x?b[h]=0:(b[h]=1,v-=x),v&lt;&lt;=1,a[c-2-h]=(a[c-1-h]/2|0)+d;a[0]=b[0];m[0]=Array
(a[0]);g[0]=Array(a[0]);for(h=1;h&lt;c;++h)a[h]&gt;2*a[h-1]+b[h]&amp;&amp;(a[h]=2*a[h-1]+b[h]),m[h]=Array(a[h]),g[h]=Array
(a[h]);for(l=0;l&lt;d;++l)k[l]=c;for(q=0;q&lt;a[c-1];++q)m[c-
1][q]=e[q],g[c-1][q]=q;for(l=0;l&lt;c;++l)p[l]=0;1===b[c-1]&amp;&amp;(--k[0],++p[c-1]);for(h=c-2;0&lt;=h;--h){t=l=0;w=p[h+
1];for(q=0;q&lt;a[h];q++)t=m[h+1][w]+m[h+1][w+1],t&gt;e[l]?(m[h][q]=t,g[h][q]=d,w+=2):(m[h][q]=e[l],g[h][q]=l,++l);p[h]=0;1===
b[h]&amp;&amp;f(h)}return k}
function pa(e){var d=new (C?Uint16Array:Array)(e.length),c=[],f=[],a=0,b,k,m,g;b=0;for(k=e.length;b&lt;k;b++)c[e[b]]=(c[e[b]]|
0)+1;b=1;for(k=16;b&lt;=k;b++)f[b]=a,a+=c[b]|0,a&lt;&lt;=1;b=0;for(k=e.length;b&lt;k;b++){a=f[e[b]];f[e[b]]+=1;m=d[b]=0;
for(g=e[b];m&lt;g;m++)d[b]=d[b]&lt;&lt;1|a&amp;1,a&gt;&gt;&gt;=1}return d};ba("Zlib.RawDeflate",ka);ba(&amp;#
x22;Zlib.RawDeflate.prototype.compress",ka.prototype.h);var Ka={NONE:0,FIXED:1,DYNAMIC:ma},V,La,$,Ma;if(Object.keys)V=Object
.keys(Ka);else for(La in V=[],$=0,Ka)V[$++]=La;$=0;for(Ma=V.length;$&lt;Ma;++$)La=V[$],ba("Zlib.RawDeflate.CompressionType
."+La,Ka[La]);}).call(this);

},{}],7:[function(_dereq_,module,exports){
/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */(function() {'use strict';var
 l=this;function p(b,e){var a=b.split("."),c=l;!(a[0]in c)&amp;&amp;c.execScript&amp;&amp;c.execScript("var &amp;#
x22;+a[0]);for(var d;a.length&amp;&amp;(d=a.shift());)!a.length&amp;&amp;void 0!==e?c[d]=e:c=c[d]?c[d]:c[d]={}};var q="
undefined"!==typeof Uint8Array&amp;&amp;"undefined"!==typeof Uint16Array&amp;&amp;"undefined"!==typeof
 Uint32Array&amp;&amp;"undefined"!==typeof DataView;function t(b){var e=b.length,a=0,c=Number.POSITIVE_INFINITY,d,f,
g,h,k,m,r,n,s,J;for(n=0;n&lt;e;++n)b[n]&gt;a&amp;&amp;(a=b[n]),b[n]&lt;c&amp;&amp;(c=b[n]);d=1&lt;&lt;a;f=new (q?Uint32Array
:Array)(d);g=1;h=0;for(k=2;g&lt;=a;){for(n=0;n&lt;e;++n)if(b[n]===g){m=0;r=h;for(s=0;s&lt;g;++s)m=m&lt;&lt;1|r&amp;1,
r&gt;&gt;=1;J=g&lt;&lt;16|n;for(s=m;s&lt;d;s+=k)f[s]=J;++h}++g;h&lt;&lt;=1;k&lt;&lt;=1}return[f,a,c]};function
 u(b,e){this.g=[];this.h=32768;this.c=this.f=this.d=this.k=0;this.input=q?new Uint8Array(b):b;this.l=!1;this.i=v;this.q=!1;if(e||!(
e={}))e.index&amp;&amp;(this.d=e.index),e.bufferSize&amp;&amp;(this.h=e.bufferSize),e.bufferType&amp;&amp;(this.i=e.bufferType
),e.resize&amp;&amp;(this.q=e.resize);switch(this.i){case w:this.a=32768;this.b=new (q?Uint8Array:Array)(32768+this.h+258);break
;case v:this.a=0;this.b=new (q?Uint8Array:Array)(this.h);this.e=this.v;this.m=this.s;this.j=this.t;break;default:throw Error("
;invalid inflate mode");
}}var w=0,v=1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.List.prototype.push" id="apidoc.element.openpgp.packet.List.prototype.push">
        function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>push
        <span class="apidocSignatureSpan">(packet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (packet) {
  if (!packet) {
    return;
  }

  packet.packets = packet.packets || new Packetlist();

  this[this.length] = packet;
  this.length++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length &gt; 1) {
        for (var i = 1; i &lt; arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.<span class="apidocCodeKeywordSpan">push</span>(new Item(fun, args));
    if (queue.length === 1 &amp;&amp; !draining) {
        cachedSetTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.List.prototype.read" id="apidoc.element.openpgp.packet.List.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  var i = 0;

  while (i &lt; bytes.length) {
    var parsed = _packet2.default.read(bytes, i, bytes.length - i);
    i = parsed.offset;

    var pushed = false;
    try {
      var tag = _enums2.default.read(_enums2.default.packet, parsed.tag);
      var packet = packets.newPacketFromTag(tag);
      this.push(packet);
      pushed = true;
      packet.read(parsed.packet);
    } catch (e) {
      if (!_config2.default.tolerant || parsed.tag == _enums2.default.packet.symmetricallyEncrypted || parsed.tag == _enums2.default
.packet.literal || parsed.tag == _enums2.default.packet.compressed) {
        throw e;
      }
      if (pushed) {
        this.pop(); // drop unsupported packet
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.List.prototype.slice" id="apidoc.element.openpgp.packet.List.prototype.slice">
        function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>slice
        <span class="apidocSignatureSpan">(begin, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">slice = function (begin, end) {
  if (!end) {
    end = this.length;
  }
  var part = new Packetlist();
  for (var i = begin; i &lt; end; i++) {
    part.push(this[i]);
  }
  return part;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        throw new Error("Malformed UTF8 character at byte offset " + i);
    }
}

var str = '',
    bs = 16384;
for ( var i = 0; i &lt; j; i += bs ) {
    str += String.fromCharCode.apply( String, chars.<span class="apidocCodeKeywordSpan">slice</span>( i, i+bs &lt;= j ? i+bs :
j ) );
}

return str;
}

function bytes_to_hex ( arr ) {
var str = '';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.List.prototype.write" id="apidoc.element.openpgp.packet.List.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.List.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  var arr = [];

  for (var i = 0; i &lt; this.length; i++) {
    var packetbytes = this[i].write();
    arr.push(_packet2.default.writeHeader(this[i].tag, packetbytes.length));
    arr.push(packetbytes);
  }

  return _util2.default.concatUint8Array(arr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.Literal" id="apidoc.module.openpgp.packet.Literal">module openpgp.packet.Literal</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.Literal.Literal" id="apidoc.element.openpgp.packet.Literal.Literal">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>Literal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Literal() {
  this.tag = _enums2.default.packet.literal;
  this.format = 'utf8'; // default format for literal data packets
  this.date = new Date();
  this.data = new Uint8Array(0); // literal data representation
  this.filename = 'msg.txt';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Sign the cleartext message
 * @param  {Array&lt;module:key~Key&gt;} privateKeys private keys with decrypted secret key data for signing
 * @return {module:signature~Signature}      new detached signature of message content
 */
CleartextMessage.prototype.signDetached = function (privateKeys) {
var packetlist = new _packet2.default.List();
var literalDataPacket = new _packet2.default.<span class="apidocCodeKeywordSpan">Literal</span>();
literalDataPacket.setText(this.text);
for (var i = 0; i &lt; privateKeys.length; i++) {
  if (privateKeys[i].isPublic()) {
    throw new Error('Need private key for signing');
  }
  var signaturePacket = new _packet2.default.Signature();
  signaturePacket.signatureType = _enums2.default.signature.text;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.Literal.prototype" id="apidoc.module.openpgp.packet.Literal.prototype">module openpgp.packet.Literal.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.Literal.prototype.getBytes" id="apidoc.element.openpgp.packet.Literal.prototype.getBytes">
        function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>getBytes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBytes = function () {
  return this.data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
Literal.prototype.write = function () {
  var filename = _util2.default.str2Uint8Array(_util2.default.encode_utf8(this.filename));
  var filename_length = new Uint8Array([filename.length]);

  var format = new Uint8Array([_enums2.default.write(_enums2.default.literal, this.format)]);
  var date = _util2.default.writeDate(this.date);
  var data = this.<span class="apidocCodeKeywordSpan">getBytes</span>();

  return _util2.default.concatUint8Array([format, filename_length, filename, date, data]);
};

},{"../enums.js":35,"../util.js":70}],49:[function(_dereq_,module,exports){
// GPG4Browsers - An OpenPGP implementation in javascript
// Copyright (C) 2011 Recurity Labs GmbH
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Literal.prototype.getFilename" id="apidoc.element.openpgp.packet.Literal.prototype.getFilename">
        function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>getFilename
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFilename = function () {
  return this.filename;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Get filename from literal data packet
 * @return {(String|null)} filename of literal data packet as string
 */
Message.prototype.getFilename = function () {
  var literal = this.packets.findPacket(_enums2.default.packet.literal);
  return literal &amp;&amp; literal.<span class="apidocCodeKeywordSpan">getFilename</span>() || null;
};

/**
 * Get literal data as text
 * @return {(String|null)} literal body of the message interpreted as text
 */
Message.prototype.getText = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Literal.prototype.getText" id="apidoc.element.openpgp.packet.Literal.prototype.getText">
        function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>getText
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getText = function () {
  // decode UTF8
  var text = _util2.default.decode_utf8(_util2.default.Uint8Array2str(this.data));
  // normalize EOL to \n
  return text.replace(/\r\n/g, '\n');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Get literal data as text
* @return {(String|null)} literal body of the message interpreted as text
*/
Message.prototype.getText = function () {
 var literal = this.packets.findPacket(_enums2.default.packet.literal);
 if (literal) {
   return literal.<span class="apidocCodeKeywordSpan">getText</span>();
 } else {
   return null;
 }
};

/**
* Encrypt the message either with public keys, passwords, or both at once.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Literal.prototype.read" id="apidoc.element.openpgp.packet.Literal.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  // - A one-octet field that describes how the data is formatted.
  var format = _enums2.default.read(_enums2.default.literal, bytes[0]);

  var filename_len = bytes[1];
  this.filename = _util2.default.decode_utf8(_util2.default.Uint8Array2str(bytes.subarray(2, 2 + filename_len)));

  this.date = _util2.default.readDate(bytes.subarray(2 + filename_len, 2 + filename_len + 4));

  var data = bytes.subarray(6 + filename_len, bytes.length);

  this.setBytes(data, format);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Literal.prototype.setBytes" id="apidoc.element.openpgp.packet.Literal.prototype.setBytes">
        function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>setBytes
        <span class="apidocSignatureSpan">(bytes, format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setBytes = function (bytes, format) {
  this.format = format;
  this.data = bytes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Create a message object from signed content and a detached armored signature.
 * @param {String} content An 8 bit ascii string containing e.g. a MIME subtree with text nodes or attachments
 * @param {String} detachedSignature The detached ascii armored PGP signature
 */
function readSignedContent(content, detachedSignature) {
  var literalDataPacket = new _packet2.default.Literal();
  literalDataPacket.<span class="apidocCodeKeywordSpan">setBytes</span>(_util2.default.str2Uint8Array(content), _enums2.default.
read(_enums2.default.literal, _enums2.default.literal.binary));
  var packetlist = new _packet2.default.List();
  packetlist.push(literalDataPacket);
  var input = _armor2.default.decode(detachedSignature).data;
  packetlist.read(input);
  return new Message(packetlist);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Literal.prototype.setFilename" id="apidoc.element.openpgp.packet.Literal.prototype.setFilename">
        function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>setFilename
        <span class="apidocSignatureSpan">(filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setFilename = function (filename) {
  this.filename = filename;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @static
 */
function fromText(text, filename) {
  var literalDataPacket = new _packet2.default.Literal();
  // text will be converted to UTF8
  literalDataPacket.setText(text);
  if (filename !== undefined) {
    literalDataPacket.<span class="apidocCodeKeywordSpan">setFilename</span>(filename);
  }
  var literalDataPacketlist = new _packet2.default.List();
  literalDataPacketlist.push(literalDataPacket);
  return new Message(literalDataPacketlist);
}

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Literal.prototype.setText" id="apidoc.element.openpgp.packet.Literal.prototype.setText">
        function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>setText
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setText = function (text) {
  // normalize EOL to \r\n
  text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').replace(/\n/g, '\r\n');
  // encode UTF8
  this.data = this.format === 'utf8' ? _util2.default.str2Uint8Array(_util2.default.encode_utf8(text)) : _util2.default.str2Uint8Array
(text);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Sign the cleartext message
 * @param  {Array&lt;module:key~Key&gt;} privateKeys private keys with decrypted secret key data for signing
 * @return {module:signature~Signature}      new detached signature of message content
 */
CleartextMessage.prototype.signDetached = function (privateKeys) {
var packetlist = new _packet2.default.List();
var literalDataPacket = new _packet2.default.Literal();
literalDataPacket.<span class="apidocCodeKeywordSpan">setText</span>(this.text);
for (var i = 0; i &lt; privateKeys.length; i++) {
  if (privateKeys[i].isPublic()) {
    throw new Error('Need private key for signing');
  }
  var signaturePacket = new _packet2.default.Signature();
  signaturePacket.signatureType = _enums2.default.signature.text;
  signaturePacket.hashAlgorithm = _config2.default.prefer_hash_algorithm;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Literal.prototype.write" id="apidoc.element.openpgp.packet.Literal.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.Literal.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  var filename = _util2.default.str2Uint8Array(_util2.default.encode_utf8(this.filename));
  var filename_length = new Uint8Array([filename.length]);

  var format = new Uint8Array([_enums2.default.write(_enums2.default.literal, this.format)]);
  var date = _util2.default.writeDate(this.date);
  var data = this.getBytes();

  return _util2.default.concatUint8Array([format, filename_length, filename, date, data]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.Marker" id="apidoc.module.openpgp.packet.Marker">module openpgp.packet.Marker</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.Marker.Marker" id="apidoc.element.openpgp.packet.Marker.Marker">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>Marker
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Marker() {
  this.tag = _enums2.default.packet.marker;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.Marker.prototype" id="apidoc.module.openpgp.packet.Marker.prototype">module openpgp.packet.Marker.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.Marker.prototype.read" id="apidoc.element.openpgp.packet.Marker.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.Marker.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  if (bytes[0] === 0x50 &amp;&amp; // P
  bytes[1] === 0x47 &amp;&amp; // G
  bytes[2] === 0x50) {
    // P
    return true;
  }
  // marker packet does not contain "PGP"
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.OnePassSignature" id="apidoc.module.openpgp.packet.OnePassSignature">module openpgp.packet.OnePassSignature</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.OnePassSignature.OnePassSignature" id="apidoc.element.openpgp.packet.OnePassSignature.OnePassSignature">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>OnePassSignature
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OnePassSignature() {
  this.tag = _enums2.default.packet.onePassSignature; // The packet type
  this.version = null; // A one-octet version number.  The current version is 3.
  this.type = null; // A one-octet signature type.  Signature types are described in {@link http://tools.ietf.org/html/rfc4880#section
-5.2.1|RFC4880 Section 5.2.1}.
  this.hashAlgorithm = null; // A one-octet number describing the hash algorithm used. (See {@link http://tools.ietf.org/html/rfc4880
#section-9.4|RFC4880 9.4})
  this.publicKeyAlgorithm = null; // A one-octet number describing the public-key algorithm used. (See {@link http://tools.ietf.
org/html/rfc4880#section-9.1|RFC4880 9.1})
  this.signingKeyId = null; // An eight-octet number holding the Key ID of the signing key.
  this.flags = null; //  A one-octet number holding a flag showing whether the signature is nested.  A zero value indicates that
 the next packet is another One-Pass Signature packet that describes another signature to be applied to the same message data.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var i, signingKeyPacket, existingSigPacketlist, onePassSig;

if (signature) {
  existingSigPacketlist = signature.packets.filterByTag(_enums2.default.packet.signature);
  if (existingSigPacketlist.length) {
    for (i = existingSigPacketlist.length - 1; i &gt;= 0; i--) {
      var sigPacket = existingSigPacketlist[i];
      onePassSig = new _packet2.default.<span class="apidocCodeKeywordSpan">OnePassSignature</span>();
      onePassSig.type = signatureType;
      onePassSig.hashAlgorithm = _config2.default.prefer_hash_algorithm;
      onePassSig.publicKeyAlgorithm = sigPacket.publicKeyAlgorithm;
      onePassSig.signingKeyId = sigPacket.issuerKeyId;
      if (!privateKeys.length &amp;&amp; i === 0) {
        onePassSig.flags = 1;
      }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.OnePassSignature.prototype" id="apidoc.module.openpgp.packet.OnePassSignature.prototype">module openpgp.packet.OnePassSignature.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.OnePassSignature.prototype.postCloneTypeFix" id="apidoc.element.openpgp.packet.OnePassSignature.prototype.postCloneTypeFix">
        function <span class="apidocSignatureSpan">openpgp.packet.OnePassSignature.prototype.</span>postCloneTypeFix
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">postCloneTypeFix = function () {
  this.signingKeyId = _keyid2.default.fromClone(this.signingKeyId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 var packet = newPacketFromTag(tagName);
 for (var attr in packetClone) {
   if (packetClone.hasOwnProperty(attr)) {
     packet[attr] = packetClone[attr];
   }
 }
 if (packet.postCloneTypeFix) {
   packet.<span class="apidocCodeKeywordSpan">postCloneTypeFix</span>();
 }
 return packet;
}

/**
* Convert tag name to class name
* @param {String} tag property name from {@link module:enums.packet}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.OnePassSignature.prototype.read" id="apidoc.element.openpgp.packet.OnePassSignature.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.OnePassSignature.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  var mypos = 0;
  // A one-octet version number.  The current version is 3.
  this.version = bytes[mypos++];

  // A one-octet signature type.  Signature types are described in
  //   Section 5.2.1.
  this.type = _enums2.default.read(_enums2.default.signature, bytes[mypos++]);

  // A one-octet number describing the hash algorithm used.
  this.hashAlgorithm = _enums2.default.read(_enums2.default.hash, bytes[mypos++]);

  // A one-octet number describing the public-key algorithm used.
  this.publicKeyAlgorithm = _enums2.default.read(_enums2.default.publicKey, bytes[mypos++]);

  // An eight-octet number holding the Key ID of the signing key.
  this.signingKeyId = new _keyid2.default();
  this.signingKeyId.read(bytes.subarray(mypos, mypos + 8));
  mypos += 8;

  // A one-octet number holding a flag showing whether the signature
  //   is nested.  A zero value indicates that the next packet is
  //   another One-Pass Signature packet that describes another
  //   signature to be applied to the same message data.
  this.flags = bytes[mypos++];
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.OnePassSignature.prototype.write" id="apidoc.element.openpgp.packet.OnePassSignature.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.OnePassSignature.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {

  var start = new Uint8Array([3, _enums2.default.write(_enums2.default.signature, this.type), _enums2.default.write(_enums2.default
.hash, this.hashAlgorithm), _enums2.default.write(_enums2.default.publicKey, this.publicKeyAlgorithm)]);

  var end = new Uint8Array([this.flags]);

  return _util2.default.concatUint8Array([start, this.signingKeyId.write(), end]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.PublicKey" id="apidoc.module.openpgp.packet.PublicKey">module openpgp.packet.PublicKey</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKey.PublicKey" id="apidoc.element.openpgp.packet.PublicKey.PublicKey">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>PublicKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PublicKey() {
  this.tag = _enums2.default.packet.publicKey;
  this.version = 4;
<span class="apidocCodeCommentSpan">  /** Key creation date.
   * @type {Date} */
</span>  this.created = new Date();
  /** A list of multiprecision integers
   * @type {module:type/mpi} */
  this.mpi = [];
  /** Public key algorithm
   * @type {module:enums.publicKey} */
  this.algorithm = 'rsa_sign';
  // time in days (V3 only)
  this.expirationTimeV3 = 0;
  /**
   * Fingerprint in lowercase hex
   * @type {String}
   */
  this.fingerprint = null;
  /**
   * Keyid
   * @type {module:type/keyid}
   */
  this.keyid = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var packetlist = new _packet2.default.List();
var keyPackets = this.toPacketlist();
var bytes;
for (var i = 0; i &lt; keyPackets.length; i++) {
  switch (keyPackets[i].tag) {
    case _enums2.default.packet.secretKey:
      bytes = keyPackets[i].writePublicKey();
      var pubKeyPacket = new _packet2.default.<span class="apidocCodeKeywordSpan">PublicKey</span>();
      pubKeyPacket.read(bytes);
      packetlist.push(pubKeyPacket);
      break;
    case _enums2.default.packet.secretSubkey:
      bytes = keyPackets[i].writePublicKey();
      var pubSubkeyPacket = new _packet2.default.PublicSubkey();
      pubSubkeyPacket.read(bytes);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.PublicKey.prototype" id="apidoc.module.openpgp.packet.PublicKey.prototype">module openpgp.packet.PublicKey.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKey.prototype.getBitSize" id="apidoc.element.openpgp.packet.PublicKey.prototype.getBitSize">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>getBitSize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBitSize = function () {
  return this.mpi[0].byteLength() * 8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKey.prototype.getFingerprint" id="apidoc.element.openpgp.packet.PublicKey.prototype.getFingerprint">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>getFingerprint
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFingerprint = function () {
  if (this.fingerprint) {
    return this.fingerprint;
  }
  var toHash = '';
  if (this.version === 4) {
    toHash = this.writeOld();
    this.fingerprint = _util2.default.Uint8Array2str(_crypto2.default.hash.sha1(toHash));
  } else if (this.version === 3) {
    var mpicount = _crypto2.default.getPublicMpiCount(this.algorithm);
    for (var i = 0; i &lt; mpicount; i++) {
      toHash += this.mpi[i].toBytes();
    }
    this.fingerprint = _util2.default.Uint8Array2str(_crypto2.default.hash.md5(_util2.default.str2Uint8Array(toHash)));
  }
  this.fingerprint = _util2.default.hexstrdump(this.fingerprint);
  return this.fingerprint;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param  {module:key~Key} key source key to merge
 */
Key.prototype.update = function (key) {
var that = this;
if (key.verifyPrimaryKey() === _enums2.default.keyStatus.invalid) {
  return;
}
if (this.primaryKey.<span class="apidocCodeKeywordSpan">getFingerprint</span>() !== key.primaryKey.getFingerprint()) {
  throw new Error('Key update method: fingerprints of keys not equal');
}
if (this.isPublic() &amp;&amp; key.isPrivate()) {
  // check for equal subkey packets
  var equal = (this.subKeys &amp;&amp; this.subKeys.length) === (key.subKeys &amp;&amp; key.subKeys.length) &amp;&amp; (!this
.subKeys || this.subKeys.every(function (destSubKey) {
    return key.subKeys.some(function (srcSubKey) {
      return destSubKey.subKey.getFingerprint() === srcSubKey.subKey.getFingerprint();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKey.prototype.getKeyId" id="apidoc.element.openpgp.packet.PublicKey.prototype.getKeyId">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>getKeyId
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getKeyId = function () {
  if (this.keyid) {
    return this.keyid;
  }
  this.keyid = new _keyid2.default();
  if (this.version === 4) {
    this.keyid.read(_util2.default.str2Uint8Array(_util2.default.hex2bin(this.getFingerprint()).substr(12, 8)));
  } else if (this.version === 3) {
    var arr = this.mpi[0].write();
    this.keyid.read(arr.subarray(arr.length - 8, arr.length));
  }
  return this.keyid;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Key.prototype.packetlist2structure = function (packetlist) {
var user, primaryKeyId, subKey;
for (var i = 0; i &lt; packetlist.length; i++) {
  switch (packetlist[i].tag) {
    case _enums2.default.packet.publicKey:
    case _enums2.default.packet.secretKey:
      this.primaryKey = packetlist[i];
      primaryKeyId = this.primaryKey.<span class="apidocCodeKeywordSpan">getKeyId</span>();
      break;
    case _enums2.default.packet.userid:
    case _enums2.default.packet.userAttribute:
      user = new User(packetlist[i]);
      if (!this.users) {
        this.users = [];
      }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKey.prototype.postCloneTypeFix" id="apidoc.element.openpgp.packet.PublicKey.prototype.postCloneTypeFix">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>postCloneTypeFix
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">postCloneTypeFix = function () {
  for (var i = 0; i &lt; this.mpi.length; i++) {
    this.mpi[i] = _mpi2.default.fromClone(this.mpi[i]);
  }
  if (this.keyid) {
    this.keyid = _keyid2.default.fromClone(this.keyid);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 var packet = newPacketFromTag(tagName);
 for (var attr in packetClone) {
   if (packetClone.hasOwnProperty(attr)) {
     packet[attr] = packetClone[attr];
   }
 }
 if (packet.postCloneTypeFix) {
   packet.<span class="apidocCodeKeywordSpan">postCloneTypeFix</span>();
 }
 return packet;
}

/**
* Convert tag name to class name
* @param {String} tag property name from {@link module:enums.packet}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKey.prototype.read" id="apidoc.element.openpgp.packet.PublicKey.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  var pos = 0;
  // A one-octet version number (3 or 4).
  this.version = bytes[pos++];

  if (this.version === 3 || this.version === 4) {
    // - A four-octet number denoting the time that the key was created.
    this.created = _util2.default.readDate(bytes.subarray(pos, pos + 4));
    pos += 4;

    if (this.version === 3) {
      // - A two-octet number denoting the time in days that this key is
      //   valid.  If this number is zero, then it does not expire.
      this.expirationTimeV3 = _util2.default.readNumber(bytes.subarray(pos, pos + 2));
      pos += 2;
    }

    // - A one-octet number denoting the public-key algorithm of this key.
    this.algorithm = _enums2.default.read(_enums2.default.publicKey, bytes[pos++]);

    var mpicount = _crypto2.default.getPublicMpiCount(this.algorithm);
    this.mpi = [];

    var bmpi = bytes.subarray(pos, bytes.length);
    var p = 0;

    for (var i = 0; i &lt; mpicount &amp;&amp; p &lt; bmpi.length; i++) {

      this.mpi[i] = new _mpi2.default();

      p += this.mpi[i].read(bmpi.subarray(p, bmpi.length));

      if (p &gt; bmpi.length) {
        throw new Error('Error reading MPI @:' + p);
      }
    }

    return p + 6;
  } else {
    throw new Error('Version ' + this.version + ' of the key packet is unsupported.');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKey.prototype.readPublicKey" id="apidoc.element.openpgp.packet.PublicKey.prototype.readPublicKey">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>readPublicKey
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readPublicKey = function (bytes) {
  var pos = 0;
  // A one-octet version number (3 or 4).
  this.version = bytes[pos++];

  if (this.version === 3 || this.version === 4) {
    // - A four-octet number denoting the time that the key was created.
    this.created = _util2.default.readDate(bytes.subarray(pos, pos + 4));
    pos += 4;

    if (this.version === 3) {
      // - A two-octet number denoting the time in days that this key is
      //   valid.  If this number is zero, then it does not expire.
      this.expirationTimeV3 = _util2.default.readNumber(bytes.subarray(pos, pos + 2));
      pos += 2;
    }

    // - A one-octet number denoting the public-key algorithm of this key.
    this.algorithm = _enums2.default.read(_enums2.default.publicKey, bytes[pos++]);

    var mpicount = _crypto2.default.getPublicMpiCount(this.algorithm);
    this.mpi = [];

    var bmpi = bytes.subarray(pos, bytes.length);
    var p = 0;

    for (var i = 0; i &lt; mpicount &amp;&amp; p &lt; bmpi.length; i++) {

      this.mpi[i] = new _mpi2.default();

      p += this.mpi[i].read(bmpi.subarray(p, bmpi.length));

      if (p &gt; bmpi.length) {
        throw new Error('Error reading MPI @:' + p);
      }
    }

    return p + 6;
  } else {
    throw new Error('Version ' + this.version + ' of the key packet is unsupported.');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Internal parser for private keys as specified in {@link http://tools.ietf.org/html/rfc4880#section-5.5.3|RFC 4880 section 5.5
.3}
 * @param {String} bytes Input string to read the packet from
 */
SecretKey.prototype.read = function (bytes) {
// - A Public-Key or Public-Subkey packet, as described above.
var len = this.<span class="apidocCodeKeywordSpan">readPublicKey</span>(bytes);

bytes = bytes.subarray(len, bytes.length);

// - One octet indicating string-to-key usage conventions.  Zero
//   indicates that the secret-key data is not encrypted.  255 or 254
//   indicates that a string-to-key specifier is being given.  Any
//   other value is a symmetric-key encryption algorithm identifier.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKey.prototype.write" id="apidoc.element.openpgp.packet.PublicKey.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {

  var arr = [];
  // Version
  arr.push(new Uint8Array([this.version]));
  arr.push(_util2.default.writeDate(this.created));
  if (this.version === 3) {
    arr.push(_util2.default.writeNumber(this.expirationTimeV3, 2));
  }
  arr.push(new Uint8Array([_enums2.default.write(_enums2.default.publicKey, this.algorithm)]));

  var mpicount = _crypto2.default.getPublicMpiCount(this.algorithm);

  for (var i = 0; i &lt; mpicount; i++) {
    arr.push(this.mpi[i].write());
  }

  return _util2.default.concatUint8Array(arr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKey.prototype.writeOld" id="apidoc.element.openpgp.packet.PublicKey.prototype.writeOld">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>writeOld
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeOld = function () {
  var bytes = this.writePublicKey();

  return _util2.default.concatUint8Array([new Uint8Array([0x99]), _util2.default.writeNumber(bytes.length, 2), bytes]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
PublicKey.prototype.getFingerprint = function () {
if (this.fingerprint) {
  return this.fingerprint;
}
var toHash = '';
if (this.version === 4) {
  toHash = this.<span class="apidocCodeKeywordSpan">writeOld</span>();
  this.fingerprint = _util2.default.Uint8Array2str(_crypto2.default.hash.sha1(toHash));
} else if (this.version === 3) {
  var mpicount = _crypto2.default.getPublicMpiCount(this.algorithm);
  for (var i = 0; i &lt; mpicount; i++) {
    toHash += this.mpi[i].toBytes();
  }
  this.fingerprint = _util2.default.Uint8Array2str(_crypto2.default.hash.md5(_util2.default.str2Uint8Array(toHash)));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKey.prototype.writePublicKey" id="apidoc.element.openpgp.packet.PublicKey.prototype.writePublicKey">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKey.prototype.</span>writePublicKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writePublicKey = function () {

  var arr = [];
  // Version
  arr.push(new Uint8Array([this.version]));
  arr.push(_util2.default.writeDate(this.created));
  if (this.version === 3) {
    arr.push(_util2.default.writeNumber(this.expirationTimeV3, 2));
  }
  arr.push(new Uint8Array([_enums2.default.write(_enums2.default.publicKey, this.algorithm)]));

  var mpicount = _crypto2.default.getPublicMpiCount(this.algorithm);

  for (var i = 0; i &lt; mpicount; i++) {
    arr.push(this.mpi[i].write());
  }

  return _util2.default.concatUint8Array(arr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Key.prototype.toPublic = function () {
var packetlist = new _packet2.default.List();
var keyPackets = this.toPacketlist();
var bytes;
for (var i = 0; i &lt; keyPackets.length; i++) {
  switch (keyPackets[i].tag) {
    case _enums2.default.packet.secretKey:
      bytes = keyPackets[i].<span class="apidocCodeKeywordSpan">writePublicKey</span>();
      var pubKeyPacket = new _packet2.default.PublicKey();
      pubKeyPacket.read(bytes);
      packetlist.push(pubKeyPacket);
      break;
    case _enums2.default.packet.secretSubkey:
      bytes = keyPackets[i].writePublicKey();
      var pubSubkeyPacket = new _packet2.default.PublicSubkey();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.PublicKeyEncryptedSessionKey" id="apidoc.module.openpgp.packet.PublicKeyEncryptedSessionKey">module openpgp.packet.PublicKeyEncryptedSessionKey</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.PublicKeyEncryptedSessionKey" id="apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.PublicKeyEncryptedSessionKey">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>PublicKeyEncryptedSessionKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PublicKeyEncryptedSessionKey() {
  this.tag = _enums2.default.packet.publicKeyEncryptedSessionKey;
  this.version = 3;

  this.publicKeyId = new _keyid2.default();
  this.publicKeyAlgorithm = 'rsa_encrypt';

  this.sessionKey = null;
  this.sessionKeyAlgorithm = 'aes256';

<span class="apidocCodeCommentSpan">  /** @type {Array&lt;module:type/mpi&gt;} */
</span>  this.encrypted = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function encryptSessionKey(sessionKey, symAlgo, publicKeys, passwords) {
var packetlist = new _packet2.default.List();

if (publicKeys) {
  publicKeys.forEach(function (key) {
    var encryptionKeyPacket = key.getEncryptionKeyPacket();
    if (encryptionKeyPacket) {
      var pkESKeyPacket = new _packet2.default.<span class="apidocCodeKeywordSpan">PublicKeyEncryptedSessionKey</span>();
      pkESKeyPacket.publicKeyId = encryptionKeyPacket.getKeyId();
      pkESKeyPacket.publicKeyAlgorithm = encryptionKeyPacket.algorithm;
      pkESKeyPacket.sessionKey = sessionKey;
      pkESKeyPacket.sessionKeyAlgorithm = symAlgo;
      pkESKeyPacket.encrypt(encryptionKeyPacket);
      delete pkESKeyPacket.sessionKey; // delete plaintext session key after encryption
      packetlist.push(pkESKeyPacket);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.PublicKeyEncryptedSessionKey.prototype" id="apidoc.module.openpgp.packet.PublicKeyEncryptedSessionKey.prototype">module openpgp.packet.PublicKeyEncryptedSessionKey.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.decrypt" id="apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.decrypt">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKeyEncryptedSessionKey.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (key) {
  var result = _crypto2.default.publicKeyDecrypt(this.publicKeyAlgorithm, key.mpi, this.encrypted).toBytes();

  var checksum = _util2.default.readNumber(_util2.default.str2Uint8Array(result.substr(result.length - 2)));

  var decoded = _crypto2.default.pkcs1.eme.decode(result);

  key = _util2.default.str2Uint8Array(decoded.substring(1, decoded.length - 2));

  if (checksum !== _util2.default.calc_checksum(key)) {
    throw new Error('Checksum mismatch');
  } else {
    this.sessionKey = key;
    this.sessionKeyAlgorithm = _enums2.default.read(_enums2.default.symmetric, decoded.charCodeAt(0));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
options = {
    message: openpgp.message.read(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.<span class="apidocCodeKeywordSpan">decrypt</span>(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
```

#### Encrypt and decrypt *String* data with PGP keys

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.encrypt" id="apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.encrypt">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKeyEncryptedSessionKey.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (key) {
  var data = String.fromCharCode(_enums2.default.write(_enums2.default.symmetric, this.sessionKeyAlgorithm));

  data += _util2.default.Uint8Array2str(this.sessionKey);
  var checksum = _util2.default.calc_checksum(this.sessionKey);
  data += _util2.default.Uint8Array2str(_util2.default.writeNumber(checksum, 2));

  var mpi = new _mpi2.default();
  mpi.fromBytes(_crypto2.default.pkcs1.eme.encode(data, key.mpi[0].byteLength()));

  this.encrypted = _crypto2.default.publicKeyEncrypt(this.publicKeyAlgorithm, key.mpi, mpi);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.<span class="apidocCodeKeywordSpan">encrypt</span>(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.postCloneTypeFix" id="apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.postCloneTypeFix">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKeyEncryptedSessionKey.prototype.</span>postCloneTypeFix
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">postCloneTypeFix = function () {
  this.publicKeyId = _keyid2.default.fromClone(this.publicKeyId);
  for (var i = 0; i &lt; this.encrypted.length; i++) {
    this.encrypted[i] = _mpi2.default.fromClone(this.encrypted[i]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 var packet = newPacketFromTag(tagName);
 for (var attr in packetClone) {
   if (packetClone.hasOwnProperty(attr)) {
     packet[attr] = packetClone[attr];
   }
 }
 if (packet.postCloneTypeFix) {
   packet.<span class="apidocCodeKeywordSpan">postCloneTypeFix</span>();
 }
 return packet;
}

/**
* Convert tag name to class name
* @param {String} tag property name from {@link module:enums.packet}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.read" id="apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKeyEncryptedSessionKey.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {

  this.version = bytes[0];
  this.publicKeyId.read(bytes.subarray(1, bytes.length));
  this.publicKeyAlgorithm = _enums2.default.read(_enums2.default.publicKey, bytes[9]);

  var i = 10;

  var integerCount = function (algo) {
    switch (algo) {
      case 'rsa_encrypt':
      case 'rsa_encrypt_sign':
        return 1;

      case 'elgamal':
        return 2;

      default:
        throw new Error("Invalid algorithm.");
    }
  }(this.publicKeyAlgorithm);

  this.encrypted = [];

  for (var j = 0; j &lt; integerCount; j++) {
    var mpi = new _mpi2.default();
    i += mpi.read(bytes.subarray(i, bytes.length));
    this.encrypted.push(mpi);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.write" id="apidoc.element.openpgp.packet.PublicKeyEncryptedSessionKey.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicKeyEncryptedSessionKey.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {

  var arr = [new Uint8Array([this.version]), this.publicKeyId.write(), new Uint8Array([_enums2.default.write(_enums2.default.publicKey
, this.publicKeyAlgorithm)])];

  for (var i = 0; i &lt; this.encrypted.length; i++) {
    arr.push(this.encrypted[i].write());
  }

  return _util2.default.concatUint8Array(arr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.PublicSubkey" id="apidoc.module.openpgp.packet.PublicSubkey">module openpgp.packet.PublicSubkey</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicSubkey.PublicSubkey" id="apidoc.element.openpgp.packet.PublicSubkey.PublicSubkey">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>PublicSubkey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PublicSubkey() {
  _public_key2.default.call(this);
  this.tag = _enums2.default.packet.publicSubkey;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      bytes = keyPackets[i].writePublicKey();
      var pubKeyPacket = new _packet2.default.PublicKey();
      pubKeyPacket.read(bytes);
      packetlist.push(pubKeyPacket);
      break;
    case _enums2.default.packet.secretSubkey:
      bytes = keyPackets[i].writePublicKey();
      var pubSubkeyPacket = new _packet2.default.<span class="apidocCodeKeywordSpan">PublicSubkey</span>();
      pubSubkeyPacket.read(bytes);
      packetlist.push(pubSubkeyPacket);
      break;
    default:
      packetlist.push(keyPackets[i]);
  }
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.PublicSubkey.prototype" id="apidoc.module.openpgp.packet.PublicSubkey.prototype">module openpgp.packet.PublicSubkey.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.PublicSubkey.prototype.constructor" id="apidoc.element.openpgp.packet.PublicSubkey.prototype.constructor">
        function <span class="apidocSignatureSpan">openpgp.packet.PublicSubkey.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PublicSubkey() {
  _public_key2.default.call(this);
  this.tag = _enums2.default.packet.publicSubkey;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
    } else {
lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
    }
    function lib$es6$promise$then$$then(onFulfillment, onRejection) {
var parent = this;

var child = new this.<span class="apidocCodeKeywordSpan">constructor</span>(lib$es6$promise$$internal$$noop);

if (child[lib$es6$promise$$internal$$PROMISE_ID] === undefined) {
  lib$es6$promise$$internal$$makePromise(child);
}

var state = parent._state;
...</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.SecretKey" id="apidoc.module.openpgp.packet.SecretKey">module openpgp.packet.SecretKey</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretKey.SecretKey" id="apidoc.element.openpgp.packet.SecretKey.SecretKey">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>SecretKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SecretKey() {
  _public_key2.default.call(this);
  this.tag = _enums2.default.packet.secretKey;
  // encrypted secret-key data
  this.encrypted = null;
  // indicator if secret-key data is available in decrypted form
  this.isDecrypted = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return Promise.all([generateSecretKey(), generateSecretSubkey()]).then(function () {
    return wrapKeyObject(secretKeyPacket, secretSubkeyPacket, options);
  });
});

function generateSecretKey() {
  secretKeyPacket = new _packet2.default.<span class="apidocCodeKeywordSpan">SecretKey</span>();
  secretKeyPacket.algorithm = _enums2.default.read(_enums2.default.publicKey, options.keyType);
  return secretKeyPacket.generate(options.numBits);
}

function generateSecretSubkey() {
  secretSubkeyPacket = new _packet2.default.SecretSubkey();
  secretSubkeyPacket.algorithm = _enums2.default.read(_enums2.default.publicKey, options.keyType);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.SecretKey.prototype" id="apidoc.module.openpgp.packet.SecretKey.prototype">module openpgp.packet.SecretKey.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretKey.prototype.clearPrivateMPIs" id="apidoc.element.openpgp.packet.SecretKey.prototype.clearPrivateMPIs">
        function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>clearPrivateMPIs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearPrivateMPIs = function () {
  if (!this.encrypted) {
    throw new Error('If secret key is not encrypted, clearing private MPIs is irreversible.');
  }
  this.mpi = this.mpi.slice(0, _crypto2.default.getPublicMpiCount(this.algorithm));
  this.isDecrypted = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 if (!this.isPrivate()) {
   throw new Error("Nothing to encrypt in a public key");
 }

 var keys = this.getAllKeyPackets();
 for (var i = 0; i &lt; keys.length; i++) {
   keys[i].encrypt(passphrase);
   keys[i].<span class="apidocCodeKeywordSpan">clearPrivateMPIs</span>();
 }
};

/**
* Decrypts all secret key and subkey packets
* @param  {String} passphrase
* @return {Boolean} true if all key and subkey packets decrypted successfully
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretKey.prototype.constructor" id="apidoc.element.openpgp.packet.SecretKey.prototype.constructor">
        function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SecretKey() {
  _public_key2.default.call(this);
  this.tag = _enums2.default.packet.secretKey;
  // encrypted secret-key data
  this.encrypted = null;
  // indicator if secret-key data is available in decrypted form
  this.isDecrypted = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
    } else {
lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
    }
    function lib$es6$promise$then$$then(onFulfillment, onRejection) {
var parent = this;

var child = new this.<span class="apidocCodeKeywordSpan">constructor</span>(lib$es6$promise$$internal$$noop);

if (child[lib$es6$promise$$internal$$PROMISE_ID] === undefined) {
  lib$es6$promise$$internal$$makePromise(child);
}

var state = parent._state;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretKey.prototype.decrypt" id="apidoc.element.openpgp.packet.SecretKey.prototype.decrypt">
        function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(passphrase)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (passphrase) {
  if (this.isDecrypted) {
    return true;
  }

  var i = 0,
      symmetric,
      key;

  var s2k_usage = this.encrypted[i++];

  // - [Optional] If string-to-key usage octet was 255 or 254, a one-
  //   octet symmetric encryption algorithm.
  if (s2k_usage === 255 || s2k_usage === 254) {
    symmetric = this.encrypted[i++];
    symmetric = _enums2.default.read(_enums2.default.symmetric, symmetric);

    // - [Optional] If string-to-key usage octet was 255 or 254, a
    //   string-to-key specifier.  The length of the string-to-key
    //   specifier is implied by its type, as described above.
    var s2k = new _s2k2.default();
    i += s2k.read(this.encrypted.subarray(i, this.encrypted.length));

    key = produceEncryptionKey(s2k, passphrase, symmetric);
  } else {
    symmetric = s2k_usage;
    symmetric = _enums2.default.read(_enums2.default.symmetric, symmetric);
    key = _crypto2.default.hash.md5(passphrase);
  }

  // - [Optional] If secret data is encrypted (string-to-key usage octet
  //   not zero), an Initial Vector (IV) of the same length as the
  //   cipher's block size.
  var iv = this.encrypted.subarray(i, i + _crypto2.default.cipher[symmetric].blockSize);

  i += iv.length;

  var cleartext,
      ciphertext = this.encrypted.subarray(i, this.encrypted.length);

  cleartext = _crypto2.default.cfb.normalDecrypt(symmetric, key, ciphertext, iv);

  var hash = s2k_usage === 254 ? 'sha1' : 'mod';

  var parsedMPI = parse_cleartext_mpi(hash, cleartext, this.algorithm);
  if (parsedMPI instanceof Error) {
    return false;
  }
  this.mpi = this.mpi.concat(parsedMPI);
  this.isDecrypted = true;
  this.encrypted = null;
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
options = {
    message: openpgp.message.read(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.<span class="apidocCodeKeywordSpan">decrypt</span>(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
```

#### Encrypt and decrypt *String* data with PGP keys

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretKey.prototype.encrypt" id="apidoc.element.openpgp.packet.SecretKey.prototype.encrypt">
        function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(passphrase)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (passphrase) {
  if (this.isDecrypted &amp;&amp; !passphrase) {
    this.encrypted = null;
    return;
  } else if (!passphrase) {
    throw new Error('The key must be decrypted before removing passphrase protection.');
  }

  var s2k = new _s2k2.default(),
      symmetric = 'aes256',
      cleartext = write_cleartext_mpi('sha1', this.algorithm, this.mpi),
      key = produceEncryptionKey(s2k, passphrase, symmetric),
      blockLen = _crypto2.default.cipher[symmetric].blockSize,
      iv = _crypto2.default.random.getRandomBytes(blockLen);

  var arr = [new Uint8Array([254, _enums2.default.write(_enums2.default.symmetric, symmetric)])];
  arr.push(s2k.write());
  arr.push(iv);
  arr.push(_crypto2.default.cfb.normalEncrypt(symmetric, key, cleartext, iv));

  this.encrypted = _util2.default.concatUint8Array(arr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.<span class="apidocCodeKeywordSpan">encrypt</span>(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretKey.prototype.generate" id="apidoc.element.openpgp.packet.SecretKey.prototype.generate">
        function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>generate
        <span class="apidocSignatureSpan">(bits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generate = function (bits) {
  var self = this;

  return _crypto2.default.generateMpi(self.algorithm, bits).then(function (mpi) {
    self.mpi = mpi;
    self.isDecrypted = true;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  generateMpi: function generateMpi(algo, bits) {
switch (algo) {
  case 'rsa_encrypt':
  case 'rsa_encrypt_sign':
  case 'rsa_sign':
    //remember "publicKey" refers to the crypto/public_key dir
    var rsa = new _public_key2.default.rsa();
    return rsa.<span class="apidocCodeKeywordSpan">generate</span>(bits, "10001").then(function (keyObject) {
      var output = [];
      output.push(keyObject.n);
      output.push(keyObject.ee);
      output.push(keyObject.d);
      output.push(keyObject.p);
      output.push(keyObject.q);
      output.push(keyObject.u);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretKey.prototype.read" id="apidoc.element.openpgp.packet.SecretKey.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  // - A Public-Key or Public-Subkey packet, as described above.
  var len = this.readPublicKey(bytes);

  bytes = bytes.subarray(len, bytes.length);

  // - One octet indicating string-to-key usage conventions.  Zero
  //   indicates that the secret-key data is not encrypted.  255 or 254
  //   indicates that a string-to-key specifier is being given.  Any
  //   other value is a symmetric-key encryption algorithm identifier.
  var isEncrypted = bytes[0];

  if (isEncrypted) {
    this.encrypted = bytes;
  } else {
    // - Plain or encrypted multiprecision integers comprising the secret
    //   key data.  These algorithm-specific fields are as described
    //   below.
    var parsedMPI = parse_cleartext_mpi('mod', bytes.subarray(1, bytes.length), this.algorithm);
    if (parsedMPI instanceof Error) {
      throw parsedMPI;
    }
    this.mpi = this.mpi.concat(parsedMPI);
    this.isDecrypted = true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretKey.prototype.write" id="apidoc.element.openpgp.packet.SecretKey.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.SecretKey.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  var arr = [this.writePublicKey()];

  if (!this.encrypted) {
    arr.push(new Uint8Array([0]));
    arr.push(write_cleartext_mpi('mod', this.algorithm, this.mpi));
  } else {
    arr.push(this.encrypted);
  }

  return _util2.default.concatUint8Array(arr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.SecretSubkey" id="apidoc.module.openpgp.packet.SecretSubkey">module openpgp.packet.SecretSubkey</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretSubkey.SecretSubkey" id="apidoc.element.openpgp.packet.SecretSubkey.SecretSubkey">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>SecretSubkey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SecretSubkey() {
  _secret_key2.default.call(this);
  this.tag = _enums2.default.packet.secretSubkey;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 function generateSecretKey() {
   secretKeyPacket = new _packet2.default.SecretKey();
   secretKeyPacket.algorithm = _enums2.default.read(_enums2.default.publicKey, options.keyType);
   return secretKeyPacket.generate(options.numBits);
 }

 function generateSecretSubkey() {
   secretSubkeyPacket = new _packet2.default.<span class="apidocCodeKeywordSpan">SecretSubkey</span>();
   secretSubkeyPacket.algorithm = _enums2.default.read(_enums2.default.publicKey, options.keyType);
   return secretSubkeyPacket.generate(options.numBits);
 }
}

/**
* Reformats and signs an OpenPGP with a given User ID. Currently only supports RSA keys.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.SecretSubkey.prototype" id="apidoc.module.openpgp.packet.SecretSubkey.prototype">module openpgp.packet.SecretSubkey.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.openpgp.packet.SecretSubkey.prototype.constructor" id="apidoc.element.openpgp.packet.SecretSubkey.prototype.constructor">
        function <span class="apidocSignatureSpan">openpgp.packet.SecretSubkey.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SecretSubkey() {
  _secret_key2.default.call(this);
  this.tag = _enums2.default.packet.secretSubkey;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
    } else {
lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
    }
    function lib$es6$promise$then$$then(onFulfillment, onRejection) {
var parent = this;

var child = new this.<span class="apidocCodeKeywordSpan">constructor</span>(lib$es6$promise$$internal$$noop);

if (child[lib$es6$promise$$internal$$PROMISE_ID] === undefined) {
  lib$es6$promise$$internal$$makePromise(child);
}

var state = parent._state;
...</pre></li>
    </ul>




















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.Signature" id="apidoc.module.openpgp.packet.Signature">module openpgp.packet.Signature</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.Signature.Signature" id="apidoc.element.openpgp.packet.Signature.Signature">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>Signature
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Signature() {
  this.tag = _enums2.default.packet.signature;
  this.version = 4;
  this.signatureType = null;
  this.hashAlgorithm = null;
  this.publicKeyAlgorithm = null;

  this.signatureData = null;
  this.unhashedSubpackets = null;
  this.signedHashValue = null;

  this.created = new Date();
  this.signatureExpirationTime = null;
  this.signatureNeverExpires = true;
  this.exportable = null;
  this.trustLevel = null;
  this.trustAmount = null;
  this.regularExpression = null;
  this.revocable = null;
  this.keyExpirationTime = null;
  this.keyNeverExpires = null;
  this.preferredSymmetricAlgorithms = null;
  this.revocationKeyClass = null;
  this.revocationKeyAlgorithm = null;
  this.revocationKeyFingerprint = null;
  this.issuerKeyId = new _keyid2.default();
  this.notation = null;
  this.preferredHashAlgorithms = null;
  this.preferredCompressionAlgorithms = null;
  this.keyServerPreferences = null;
  this.preferredKeyServer = null;
  this.isPrimaryUserID = null;
  this.policyURI = null;
  this.keyFlags = null;
  this.signersUserId = null;
  this.reasonForRevocationFlag = null;
  this.reasonForRevocationString = null;
  this.features = null;
  this.signatureTargetPublicKeyAlgorithm = null;
  this.signatureTargetHashAlgorithm = null;
  this.signatureTargetHash = null;
  this.embeddedSignature = null;

  this.verified = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new CleartextMessage(text, signature);
  }
  // normalize EOL to canonical form &lt;CR&gt;&lt;LF&gt;
  this.text = text.replace(/\r/g, '').replace(/[\t ]+\n/g, "\n").replace(/\n/g, "\r\n");
  if (signature &amp;&amp; !(signature instanceof sigModule.Signature)) {
    throw new Error('Invalid signature input');
  }
  this.signature = signature || new sigModule.<span class="apidocCodeKeywordSpan">Signature</span>(new _packet2.default.List());
}

/**
 * Returns the key IDs of the keys that signed the cleartext message
 * @return {Array&lt;module:type/keyid&gt;} array of keyid objects
 */
CleartextMessage.prototype.getSigningKeyIds = function () {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.Signature.prototype" id="apidoc.module.openpgp.packet.Signature.prototype">module openpgp.packet.Signature.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.Signature.prototype.calculateTrailer" id="apidoc.element.openpgp.packet.Signature.prototype.calculateTrailer">
        function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>calculateTrailer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">calculateTrailer = function () {
  // calculating the trailer
  // V3 signatures don't have a trailer
  if (this.version === 3) {
    return new Uint8Array(0);
  }
  var first = new Uint8Array([4, 0xFF]); //Version, ?
  return _util2.default.concatUint8Array([first, _util2.default.writeNumber(this.signatureData.length, 4)]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.issuerKeyId = key.getKeyId();

// Add hashed subpackets
arr.push(this.write_all_sub_packets());

this.signatureData = _util2.default.concatUint8Array(arr);

var trailer = this.<span class="apidocCodeKeywordSpan">calculateTrailer</span>();

var toHash = null;

switch (this.version) {
  case 3:
    toHash = _util2.default.concatUint8Array([this.toSign(signatureType, data), new Uint8Array([signatureType]), _util2.default.
writeDate(this.created)]);
    break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Signature.prototype.isExpired" id="apidoc.element.openpgp.packet.Signature.prototype.isExpired">
        function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>isExpired
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isExpired = function () {
  if (!this.signatureNeverExpires) {
    return Date.now() &gt; this.created.getTime() + this.signatureExpirationTime * 1000;
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     if (this.subKeys[i].isValidEncryptionKey(this.primaryKey)) {
       return this.subKeys[i].subKey;
     }
   }
 }
 // if no valid subkey for encryption, evaluate primary key
 var primaryUser = this.getPrimaryUser();
 if (primaryUser &amp;&amp; primaryUser.selfCertificate &amp;&amp; !primaryUser.selfCertificate.<span class="apidocCodeKeywordSpan
">isExpired</span>() &amp;&amp; isValidEncryptionKeyPacket(this.primaryKey, primaryUser.selfCertificate)) {
   return this.primaryKey;
 }
 return null;
};

/**
* Encrypts all secret key and subkey packets
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Signature.prototype.postCloneTypeFix" id="apidoc.element.openpgp.packet.Signature.prototype.postCloneTypeFix">
        function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>postCloneTypeFix
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">postCloneTypeFix = function () {
  this.issuerKeyId = _keyid2.default.fromClone(this.issuerKeyId);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 var packet = newPacketFromTag(tagName);
 for (var attr in packetClone) {
   if (packetClone.hasOwnProperty(attr)) {
     packet[attr] = packetClone[attr];
   }
 }
 if (packet.postCloneTypeFix) {
   packet.<span class="apidocCodeKeywordSpan">postCloneTypeFix</span>();
 }
 return packet;
}

/**
* Convert tag name to class name
* @param {String} tag property name from {@link module:enums.packet}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Signature.prototype.read" id="apidoc.element.openpgp.packet.Signature.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  var _this = this;

  var i = 0;
  this.version = bytes[i++];
  // switch on version (3 and 4)
  var sigpos;
  var sigDataLength;

  (function () {
    switch (_this.version) {
      case 3:
        // One-octet length of following hashed material. MUST be 5.
        if (bytes[i++] !== 5) {
          _util2.default.print_debug("packet/signature.js\n" + 'invalid One-octet length of following hashed material.' + 'MUST
be 5. @:' + (i - 1));
        }

        sigpos = i;
        // One-octet signature type.

        _this.signatureType = bytes[i++];

        // Four-octet creation time.
        _this.created = _util2.default.readDate(bytes.subarray(i, i + 4));
        i += 4;

        // storing data appended to data which gets verified
        _this.signatureData = bytes.subarray(sigpos, i);

        // Eight-octet Key ID of signer.
        _this.issuerKeyId.read(bytes.subarray(i, i + 8));
        i += 8;

        // One-octet public-key algorithm.
        _this.publicKeyAlgorithm = bytes[i++];

        // One-octet hash algorithm.
        _this.hashAlgorithm = bytes[i++];
        break;
      case 4:
        _this.signatureType = bytes[i++];
        _this.publicKeyAlgorithm = bytes[i++];
        _this.hashAlgorithm = bytes[i++];

        var subpackets = function subpackets(bytes) {
          // Two-octet scalar octet count for following subpacket data.
          var subpacket_length = _util2.default.readNumber(bytes.subarray(0, 2));

          var i = 2;

          // subpacket data set (zero or more subpackets)
          while (i &lt; 2 + subpacket_length) {

            var len = _packet2.default.readSimpleLength(bytes.subarray(i, bytes.length));
            i += len.offset;

            this.read_sub_packet(bytes.subarray(i, i + len.len));

            i += len.len;
          }

          return i;
        };

        // hashed subpackets


        i += subpackets.call(_this, bytes.subarray(i, bytes.length), true);

        // A V4 signature hashes the packet body
        // starting from its first field, the version number, through the end
        // of the hashed subpacket data.  Thus, the fields hashed are the
        // signature version, the signature type, the public-key algorithm, the
        // hash algorithm, the hashed subpacket length, and the hashed
        // subpacket body.
        _this.signatureData = bytes.subarray(0, i);
        sigDataLength = i;

        // unhashed subpackets

        i += subpackets.call(_this, bytes.subarray(i, bytes.length), false);
        _this.unhashedSubpackets = bytes.subarray(sigDataLength, i);

        break;
      default:
        throw new Error('Version ' + _this.version + ' of the signature is unsupported.');
    }

    // Two-octet field holding left 16 bits of signed hash value.
  })();

  this.signedHashValue = bytes.subarray(i, i + 2);
  i += 2;

  this.signature = bytes.subarray(i, bytes.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Signature.prototype.read_sub_packet" id="apidoc.element.openpgp.packet.Signature.prototype.read_sub_packet">
        function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>read_sub_packet
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read_sub_packet = function (bytes) {
  var mypos = 0;

  function read_array(prop, bytes) {
    this[prop] = [];

    for (var i = 0; i &lt; bytes.length; i++) {
      this[prop].push(bytes[i]);
    }
  }

  // The leftwost bit denotes a "critical" packet, but we ignore it.
  var type = bytes[mypos++] &amp; 0x7F;
  var seconds;

  // subpacket type
  switch (type) {
    case 2:
      // Signature Creation Time
      this.created = _util2.default.readDate(bytes.subarray(mypos, bytes.length));
      break;
    case 3:
      // Signature Expiration Time in seconds
      seconds = _util2.default.readNumber(bytes.subarray(mypos, bytes.length));

      this.signatureNeverExpires = seconds === 0;
      this.signatureExpirationTime = seconds;

      break;
    case 4:
      // Exportable Certification
      this.exportable = bytes[mypos++] === 1;
      break;
    case 5:
      // Trust Signature
      this.trustLevel = bytes[mypos++];
      this.trustAmount = bytes[mypos++];
      break;
    case 6:
      // Regular Expression
      this.regularExpression = bytes[mypos];
      break;
    case 7:
      // Revocable
      this.revocable = bytes[mypos++] === 1;
      break;
    case 9:
      // Key Expiration Time in seconds
      seconds = _util2.default.readNumber(bytes.subarray(mypos, bytes.length));

      this.keyExpirationTime = seconds;
      this.keyNeverExpires = seconds === 0;

      break;
    case 11:
      // Preferred Symmetric Algorithms
      read_array.call(this, 'preferredSymmetricAlgorithms', bytes.subarray(mypos, bytes.length));
      break;
    case 12:
      // Revocation Key
      // (1 octet of class, 1 octet of public-key algorithm ID, 20
      // octets of
      // fingerprint)
      this.revocationKeyClass = bytes[mypos++];
      this.revocationKeyAlgorithm = bytes[mypos++];
      this.revocationKeyFingerprint = bytes.subarray(mypos, 20);
      break;

    case 16:
      // Issuer
      this.issuerKeyId.read(bytes.subarray(mypos, bytes.length));
      break;

    case 20:
      // Notation Data
      // We don't know how to handle anything but a text flagged data.
      if (bytes[mypos] === 0x80) {

        // We extract key/value tuple from the byte stream.
        mypos += 4;
        var m = _util2.default.readNumber(bytes.subarray(mypos, mypos + 2));
        mypos += 2;
        var n = _util2.default.readNumber(bytes.subarray(mypos, mypos + 2));
        mypos += 2;

        var name = _util2.default.Uint8Array2str(bytes.subarray(mypos, mypos + m)),
            value = _util2.default.Uint8Array2str(bytes.subarray(mypos + m, mypos + m + n));

        this.notation = this.notation || {};
        this.notation[name] = value;
      } else {
        _util2.default.print_debug("Unsupported notation flag " + bytes[mypos]);
      }
      break;
    case 21:
      // Preferred Hash Algorithms
      read_array.call(this, 'preferredHashAlgorithms', bytes.subarray(mypos, bytes.length));
      break;
    case 22:
      // Preferred Compression Algorithms
      read_array.call(this, 'preferredCompressionAlgorithms', bytes.subarray(mypos, bytes.length));
      break;
    case 23:
      // Key Server Preferences
      read_array.call(this, 'keyServerPreferencess', bytes.subarray(mypos, bytes.length));
      break;
    case 24:
      // Preferred Key Server
      this.preferredKeyServer = _util2.default.Uint8Array2str(bytes.subarray(mypos, bytes.length));
      break;
    case 25:
      // Primary User ID
      this.isPrimaryUserID = bytes[mypos++] !== 0;
      break;
    case 26:
      // Policy URI
      this.policyURI = _util2.default.Uint8Array2str(bytes.subarray(mypos, bytes.length));
      break;
    case 27:
      // Key Flags
      read_array.call(this, 'keyFlags', bytes.subarray(mypos, bytes.length));
      break;
    case 28:
      // Signer's User ID
      this.signersUserId += _util2.default.Uint8Array2str(bytes.subarray(mypos, bytes.length));
      break;
    case 29:
      // Reason for Revocation
      this.reasonForRevocationFlag = bytes[mypos++];
      this.reasonForRevocationString = _util2.default.Uint8Array2str(bytes.subarra ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  // subpacket data set (zero or more subpackets)
  while (i &lt; 2 + subpacket_length) {

    var len = _packet2.default.readSimpleLength(bytes.subarray(i, bytes.length));
    i += len.offset;

    this.<span class="apidocCodeKeywordSpan">read_sub_packet</span>(bytes.subarray(i, i + len.len));

    i += len.len;
  }

  return i;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Signature.prototype.sign" id="apidoc.element.openpgp.packet.Signature.prototype.sign">
        function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>sign
        <span class="apidocSignatureSpan">(key, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sign = function (key, data) {
  var signatureType = _enums2.default.write(_enums2.default.signature, this.signatureType),
      publicKeyAlgorithm = _enums2.default.write(_enums2.default.publicKey, this.publicKeyAlgorithm),
      hashAlgorithm = _enums2.default.write(_enums2.default.hash, this.hashAlgorithm);

  var arr = [new Uint8Array([4, signatureType, publicKeyAlgorithm, hashAlgorithm])];

  this.issuerKeyId = key.getKeyId();

  // Add hashed subpackets
  arr.push(this.write_all_sub_packets());

  this.signatureData = _util2.default.concatUint8Array(arr);

  var trailer = this.calculateTrailer();

  var toHash = null;

  switch (this.version) {
    case 3:
      toHash = _util2.default.concatUint8Array([this.toSign(signatureType, data), new Uint8Array([signatureType]), _util2.default
.writeDate(this.created)]);
      break;
    case 4:
      toHash = _util2.default.concatUint8Array([this.toSign(signatureType, data), this.signatureData, trailer]);
      break;
    default:
      throw new Error('Version ' + this.version + ' of the signature is unsupported.');
  }

  var hash = _crypto2.default.hash.digest(hashAlgorithm, toHash);

  this.signedHashValue = hash.subarray(0, 2);

  this.signature = _crypto2.default.signature.sign(hashAlgorithm, publicKeyAlgorithm, key.mpi, toHash);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
options = {
data: 'Hello, World!',                             // input as String (or Uint8Array)
privateKeys: privKeyObj // for signing
};

openpgp.<span class="apidocCodeKeywordSpan">sign</span>(options).then(function(signed) {
cleartext = signed.data; // '-----BEGIN PGP SIGNED MESSAGE ... END PGP SIGNATURE-----'
});
```

```js
options = {
message: openpgp.cleartext.readArmored(cleartext), // parse armored message
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Signature.prototype.toSign" id="apidoc.element.openpgp.packet.Signature.prototype.toSign">
        function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>toSign
        <span class="apidocSignatureSpan">(type, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSign = function (type, data) {
  var t = _enums2.default.signature;

  switch (type) {
    case t.binary:
    case t.text:
      return data.getBytes();

    case t.standalone:
      return new Uint8Array(0);

    case t.cert_generic:
    case t.cert_persona:
    case t.cert_casual:
    case t.cert_positive:
    case t.cert_revocation:
      var packet, tag;

      if (data.userid !== undefined) {
        tag = 0xB4;
        packet = data.userid;
      } else if (data.userattribute !== undefined) {
        tag = 0xD1;
        packet = data.userattribute;
      } else {
        throw new Error('Either a userid or userattribute packet needs to be ' + 'supplied for certification.');
      }

      var bytes = packet.write();

      if (this.version === 4) {
        return _util2.default.concatUint8Array([this.toSign(t.key, data), new Uint8Array([tag]), _util2.default.writeNumber(bytes
.length, 4), bytes]);
      } else if (this.version === 3) {
        return _util2.default.concatUint8Array([this.toSign(t.key, data), bytes]);
      }
      break;

    case t.subkey_binding:
    case t.subkey_revocation:
    case t.key_binding:
      return _util2.default.concatUint8Array([this.toSign(t.key, data), this.toSign(t.key, {
        key: data.bind
      })]);

    case t.key:
      if (data.key === undefined) {
        throw new Error('Key packet is required for this signature.');
      }
      return data.key.writeOld();

    case t.key_revocation:
      return this.toSign(t.key, data);
    case t.timestamp:
      return new Uint8Array(0);
    case t.third_party:
      throw new Error('Not implemented');
    default:
      throw new Error('Unknown signature type.');
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var trailer = this.calculateTrailer();

var toHash = null;

switch (this.version) {
  case 3:
    toHash = _util2.default.concatUint8Array([this.<span class="apidocCodeKeywordSpan">toSign</span>(signatureType, data), new Uint8Array
([signatureType]), _util2.default.writeDate(this.created)]);
    break;
  case 4:
    toHash = _util2.default.concatUint8Array([this.toSign(signatureType, data), this.signatureData, trailer]);
    break;
  default:
    throw new Error('Version ' + this.version + ' of the signature is unsupported.');
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Signature.prototype.verify" id="apidoc.element.openpgp.packet.Signature.prototype.verify">
        function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>verify
        <span class="apidocSignatureSpan">(key, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verify = function (key, data) {
  var signatureType = _enums2.default.write(_enums2.default.signature, this.signatureType),
      publicKeyAlgorithm = _enums2.default.write(_enums2.default.publicKey, this.publicKeyAlgorithm),
      hashAlgorithm = _enums2.default.write(_enums2.default.hash, this.hashAlgorithm);

  var bytes = this.toSign(signatureType, data),
      trailer = this.calculateTrailer();

  var mpicount = 0;
  // Algorithm-Specific Fields for RSA signatures:
  //      - multiprecision number (MPI) of RSA signature value m**d mod n.
  if (publicKeyAlgorithm &gt; 0 &amp;&amp; publicKeyAlgorithm &lt; 4) {
    mpicount = 1;
  }
  //    Algorithm-Specific Fields for DSA signatures:
  //      - MPI of DSA value r.
  //      - MPI of DSA value s.
  else if (publicKeyAlgorithm === 17) {
      mpicount = 2;
    }

  var mpi = [],
      i = 0;
  for (var j = 0; j &lt; mpicount; j++) {
    mpi[j] = new _mpi2.default();
    i += mpi[j].read(this.signature.subarray(i, this.signature.length));
  }

  this.verified = _crypto2.default.signature.verify(publicKeyAlgorithm, hashAlgorithm, mpi, key.mpi, _util2.default.concatUint8Array
([bytes, this.signatureData, trailer]));

  return this.verified;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```js
options = {
    message: openpgp.cleartext.readArmored(cleartext), // parse armored message
    publicKeys: openpgp.key.readArmored(pubkey).keys   // for verification
};

openpgp.<span class="apidocCodeKeywordSpan">verify</span>(options).then(function(verified) {
	validity = verified.signatures[0].valid; // true
	if (validity) {
		console.log('signed by key id ' + verified.signatures[0].keyid.toHex());
	}
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Signature.prototype.write" id="apidoc.element.openpgp.packet.Signature.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  var arr = [];
  switch (this.version) {
    case 3:
      arr.push(new Uint8Array([3, 5])); // version, One-octet length of following hashed material.  MUST be 5
      arr.push(new Uint8Array([this.signatureType]));
      arr.push(_util2.default.writeDate(this.created));
      arr.push(this.issuerKeyId.write());
      arr.push(new Uint8Array([_enums2.default.write(_enums2.default.publicKey, this.publicKeyAlgorithm), _enums2.default.write(
_enums2.default.hash, this.hashAlgorithm)]));
      break;
    case 4:
      arr.push(this.signatureData);
      arr.push(this.unhashedSubpackets ? this.unhashedSubpackets : _util2.default.writeNumber(0, 2));
      break;
  }
  arr.push(this.signedHashValue);
  arr.push(this.signature);
  return _util2.default.concatUint8Array(arr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Signature.prototype.write_all_sub_packets" id="apidoc.element.openpgp.packet.Signature.prototype.write_all_sub_packets">
        function <span class="apidocSignatureSpan">openpgp.packet.Signature.prototype.</span>write_all_sub_packets
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write_all_sub_packets = function () {
  var sub = _enums2.default.signatureSubpacket;
  var arr = [];
  var bytes;
  if (this.created !== null) {
    arr.push(write_sub_packet(sub.signature_creation_time, _util2.default.writeDate(this.created)));
  }
  if (this.signatureExpirationTime !== null) {
    arr.push(write_sub_packet(sub.signature_expiration_time, _util2.default.writeNumber(this.signatureExpirationTime, 4)));
  }
  if (this.exportable !== null) {
    arr.push(write_sub_packet(sub.exportable_certification, new Uint8Array([this.exportable ? 1 : 0])));
  }
  if (this.trustLevel !== null) {
    bytes = new Uint8Array([this.trustLevel, this.trustAmount]);
    arr.push(write_sub_packet(sub.trust_signature, bytes));
  }
  if (this.regularExpression !== null) {
    arr.push(write_sub_packet(sub.regular_expression, this.regularExpression));
  }
  if (this.revocable !== null) {
    arr.push(write_sub_packet(sub.revocable, new Uint8Array([this.revocable ? 1 : 0])));
  }
  if (this.keyExpirationTime !== null) {
    arr.push(write_sub_packet(sub.key_expiration_time, _util2.default.writeNumber(this.keyExpirationTime, 4)));
  }
  if (this.preferredSymmetricAlgorithms !== null) {
    bytes = _util2.default.str2Uint8Array(_util2.default.bin2str(this.preferredSymmetricAlgorithms));
    arr.push(write_sub_packet(sub.preferred_symmetric_algorithms, bytes));
  }
  if (this.revocationKeyClass !== null) {

    bytes = new Uint8Array([this.revocationKeyClass, this.revocationKeyAlgorithm]);
    bytes = _util2.default.concatUint8Array([bytes, this.revocationKeyFingerprint]);
    arr.push(write_sub_packet(sub.revocation_key, bytes));
  }
  if (!this.issuerKeyId.isNull()) {
    arr.push(write_sub_packet(sub.issuer, this.issuerKeyId.write()));
  }
  if (this.notation !== null) {
    for (var name in this.notation) {
      if (this.notation.hasOwnProperty(name)) {
        var value = this.notation[name];
        bytes = [new Uint8Array([0x80, 0, 0, 0])];
        // 2 octets of name length
        bytes.push(_util2.default.writeNumber(name.length, 2));
        // 2 octets of value length
        bytes.push(_util2.default.writeNumber(value.length, 2));
        bytes.push(_util2.default.str2Uint8Array(name + value));
        bytes = _util2.default.concatUint8Array(bytes);
        arr.push(write_sub_packet(sub.notation_data, bytes));
      }
    }
  }
  if (this.preferredHashAlgorithms !== null) {
    bytes = _util2.default.str2Uint8Array(_util2.default.bin2str(this.preferredHashAlgorithms));
    arr.push(write_sub_packet(sub.preferred_hash_algorithms, bytes));
  }
  if (this.preferredCompressionAlgorithms !== null) {
    bytes = _util2.default.str2Uint8Array(_util2.default.bin2str(this.preferredCompressionAlgorithms));
    arr.push(write_sub_packet(sub.preferred_compression_algorithms, bytes));
  }
  if (this.keyServerPreferences !== null) {
    bytes = _util2.default.str2Uint8Array(_util2.default.bin2str(this.keyServerPreferences));
    arr.push(write_sub_packet(sub.key_server_preferences, bytes));
  }
  if (this.preferredKeyServer !== null) {
    arr.push(write_sub_packet(sub.preferred_key_server, _util2.default.str2Uint8Array(this.preferredKeyServer)));
  }
  if (this.isPrimaryUserID !== null) {
    arr.push(write_sub_packet(sub.primary_user_id, new Uint8Array([this.isPrimaryUserID ? 1 : 0])));
  }
  if (this.policyURI !== null) {
    arr.push(write_sub_packet(sub.policy_uri, _util2.default.str2Uint8Array(this.policyURI)));
  }
  if (this.keyFlags !== null) {
    bytes = _util2.default.str2Uint8Array(_util2.default.bin2str(this.keyFlags));
    arr.push(write_sub_packet(sub.key_flags, bytes));
  }
  if (this.signersUserId !== null) {
    arr.push(write_sub_packet(sub.signers_user_id, _util2.default.str2Uint8Array(this.signersUserId)));
  }
  if (this.reasonForRevocationFlag !== null) {
    bytes = _util2.default.str2Uint8Array(String.fromCharCode(this.reasonForRevocationFlag) + this.reasonForRevocationString);
    arr.push(write_sub_packet(sub.reason_for_revocation, bytes));
  }
  if (this.features !== null) {
    bytes = _util2.default.str2Uint8Array(_util2.default ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    hashAlgorithm = _enums2.default.write(_enums2.default.hash, this.hashAlgorithm);

var arr = [new Uint8Array([4, signatureType, publicKeyAlgorithm, hashAlgorithm])];

this.issuerKeyId = key.getKeyId();

// Add hashed subpackets
arr.push(this.<span class="apidocCodeKeywordSpan">write_all_sub_packets</span>());

this.signatureData = _util2.default.concatUint8Array(arr);

var trailer = this.calculateTrailer();

var toHash = null;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.SymEncryptedAEADProtected" id="apidoc.module.openpgp.packet.SymEncryptedAEADProtected">module openpgp.packet.SymEncryptedAEADProtected</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected.SymEncryptedAEADProtected" id="apidoc.element.openpgp.packet.SymEncryptedAEADProtected.SymEncryptedAEADProtected">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>SymEncryptedAEADProtected
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymEncryptedAEADProtected() {
  this.tag = _enums2.default.packet.symEncryptedAEADProtected;
  this.version = VERSION;
  this.iv = null;
  this.encrypted = null;
  this.packets = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  throw new Error('No keys or passwords');
}

var sessionKey = _crypto2.default.generateSessionKey(_enums2.default.read(_enums2.default.symmetric, symAlgo));
msg = encryptSessionKey(sessionKey, _enums2.default.read(_enums2.default.symmetric, symAlgo), keys, passwords);

if (_config2.default.aead_protect) {
  symEncryptedPacket = new _packet2.default.<span class="apidocCodeKeywordSpan">SymEncryptedAEADProtected</span>();
} else if (_config2.default.integrity_protect) {
  symEncryptedPacket = new _packet2.default.SymEncryptedIntegrityProtected();
} else {
  symEncryptedPacket = new _packet2.default.SymmetricallyEncrypted();
}
symEncryptedPacket.packets = _this2.packets;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.SymEncryptedAEADProtected.prototype" id="apidoc.module.openpgp.packet.SymEncryptedAEADProtected.prototype">module openpgp.packet.SymEncryptedAEADProtected.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected.prototype.decrypt" id="apidoc.element.openpgp.packet.SymEncryptedAEADProtected.prototype.decrypt">
        function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedAEADProtected.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(sessionKeyAlgorithm, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (sessionKeyAlgorithm, key) {
  var _this = this;

  return _crypto2.default.gcm.decrypt(sessionKeyAlgorithm, this.encrypted, key, this.iv).then(function (decrypted) {
    _this.packets.read(decrypted);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
options = {
    message: openpgp.message.read(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.<span class="apidocCodeKeywordSpan">decrypt</span>(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
```

#### Encrypt and decrypt *String* data with PGP keys

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected.prototype.encrypt" id="apidoc.element.openpgp.packet.SymEncryptedAEADProtected.prototype.encrypt">
        function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedAEADProtected.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(sessionKeyAlgorithm, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (sessionKeyAlgorithm, key) {
  var _this2 = this;

  this.iv = _crypto2.default.random.getRandomValues(new Uint8Array(IV_LEN)); // generate new random IV
  return _crypto2.default.gcm.encrypt(sessionKeyAlgorithm, this.packets.write(), key, this.iv).then(function (encrypted) {
    _this2.encrypted = encrypted;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.<span class="apidocCodeKeywordSpan">encrypt</span>(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected.prototype.read" id="apidoc.element.openpgp.packet.SymEncryptedAEADProtected.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedAEADProtected.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  var offset = 0;
  if (bytes[offset] !== VERSION) {
    // The only currently defined value is 1.
    throw new Error('Invalid packet version.');
  }
  offset++;
  this.iv = bytes.subarray(offset, IV_LEN + offset);
  offset += IV_LEN;
  this.encrypted = bytes.subarray(offset, bytes.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedAEADProtected.prototype.write" id="apidoc.element.openpgp.packet.SymEncryptedAEADProtected.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedAEADProtected.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  return _util2.default.concatUint8Array([new Uint8Array([this.version]), this.iv, this.encrypted]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.SymEncryptedIntegrityProtected" id="apidoc.module.openpgp.packet.SymEncryptedIntegrityProtected">module openpgp.packet.SymEncryptedIntegrityProtected</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.SymEncryptedIntegrityProtected" id="apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.SymEncryptedIntegrityProtected">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>SymEncryptedIntegrityProtected
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymEncryptedIntegrityProtected() {
  this.tag = _enums2.default.packet.symEncryptedIntegrityProtected;
  this.version = VERSION;
<span class="apidocCodeCommentSpan">  /** The encrypted payload. */
</span>  this.encrypted = null; // string
  /**
   * If after decrypting the packet this is set to true,
   * a modification has been detected and thus the contents
   * should be discarded.
   * @type {Boolean}
   */
  this.modification = false;
  this.packets = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var sessionKey = _crypto2.default.generateSessionKey(_enums2.default.read(_enums2.default.symmetric, symAlgo));
  msg = encryptSessionKey(sessionKey, _enums2.default.read(_enums2.default.symmetric, symAlgo), keys, passwords);

  if (_config2.default.aead_protect) {
    symEncryptedPacket = new _packet2.default.SymEncryptedAEADProtected();
  } else if (_config2.default.integrity_protect) {
    symEncryptedPacket = new _packet2.default.<span class="apidocCodeKeywordSpan">SymEncryptedIntegrityProtected</span>();
  } else {
    symEncryptedPacket = new _packet2.default.SymmetricallyEncrypted();
  }
  symEncryptedPacket.packets = _this2.packets;

  return symEncryptedPacket.encrypt(_enums2.default.read(_enums2.default.symmetric, symAlgo), sessionKey);
}).then(function () {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.SymEncryptedIntegrityProtected.prototype" id="apidoc.module.openpgp.packet.SymEncryptedIntegrityProtected.prototype">module openpgp.packet.SymEncryptedIntegrityProtected.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.prototype.decrypt" id="apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.prototype.decrypt">
        function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedIntegrityProtected.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(sessionKeyAlgorithm, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (sessionKeyAlgorithm, key) {
  var decrypted = void 0;
  if (sessionKeyAlgorithm.substr(0, 3) === 'aes') {
    // AES optimizations. Native code for node, asmCrypto for browser.
    decrypted = aesDecrypt(sessionKeyAlgorithm, this.encrypted, key);
  } else {
    decrypted = _crypto2.default.cfb.decrypt(sessionKeyAlgorithm, key, this.encrypted, false);
  }

  // there must be a modification detection code packet as the
  // last packet and everything gets hashed except the hash itself
  var prefix = _crypto2.default.cfb.mdc(sessionKeyAlgorithm, key, this.encrypted);
  var bytes = decrypted.subarray(0, decrypted.length - 20);
  var tohash = _util2.default.concatUint8Array([prefix, bytes]);
  this.hash = _util2.default.Uint8Array2str(_crypto2.default.hash.sha1(tohash));
  var mdc = _util2.default.Uint8Array2str(decrypted.subarray(decrypted.length - 20, decrypted.length));

  if (this.hash !== mdc) {
    throw new Error('Modification detected.');
  } else {
    this.packets.read(decrypted.subarray(0, decrypted.length - 22));
  }

  return Promise.resolve();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
options = {
    message: openpgp.message.read(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.<span class="apidocCodeKeywordSpan">decrypt</span>(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
```

#### Encrypt and decrypt *String* data with PGP keys

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.prototype.encrypt" id="apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.prototype.encrypt">
        function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedIntegrityProtected.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(sessionKeyAlgorithm, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (sessionKeyAlgorithm, key) {
  var bytes = this.packets.write();
  var prefixrandom = _crypto2.default.getPrefixRandom(sessionKeyAlgorithm);
  var repeat = new Uint8Array([prefixrandom[prefixrandom.length - 2], prefixrandom[prefixrandom.length - 1]]);
  var prefix = _util2.default.concatUint8Array([prefixrandom, repeat]);
  var mdc = new Uint8Array([0xD3, 0x14]); // modification detection code packet

  var tohash = _util2.default.concatUint8Array([bytes, mdc]);
  var hash = _crypto2.default.hash.sha1(_util2.default.concatUint8Array([prefix, tohash]));
  tohash = _util2.default.concatUint8Array([tohash, hash]);

  if (sessionKeyAlgorithm.substr(0, 3) === 'aes') {
    // AES optimizations. Native code for node, asmCrypto for browser.
    this.encrypted = aesEncrypt(sessionKeyAlgorithm, prefix, tohash, key);
  } else {
    this.encrypted = _crypto2.default.cfb.encrypt(prefixrandom, sessionKeyAlgorithm, tohash, key, false);
    this.encrypted = this.encrypted.subarray(0, prefix.length + tohash.length);
  }

  return Promise.resolve();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.<span class="apidocCodeKeywordSpan">encrypt</span>(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.prototype.read" id="apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedIntegrityProtected.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  // - A one-octet version number. The only currently defined value is 1.
  if (bytes[0] !== VERSION) {
    throw new Error('Invalid packet version.');
  }

  // - Encrypted data, the output of the selected symmetric-key cipher
  //   operating in Cipher Feedback mode with shift amount equal to the
  //   block size of the cipher (CFB-n where n is the block size).
  this.encrypted = bytes.subarray(1, bytes.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.prototype.write" id="apidoc.element.openpgp.packet.SymEncryptedIntegrityProtected.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedIntegrityProtected.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  return _util2.default.concatUint8Array([new Uint8Array([VERSION]), this.encrypted]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.SymEncryptedSessionKey" id="apidoc.module.openpgp.packet.SymEncryptedSessionKey">module openpgp.packet.SymEncryptedSessionKey</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey.SymEncryptedSessionKey" id="apidoc.element.openpgp.packet.SymEncryptedSessionKey.SymEncryptedSessionKey">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>SymEncryptedSessionKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymEncryptedSessionKey() {
  this.tag = _enums2.default.packet.symEncryptedSessionKey;
  this.version = 4;
  this.sessionKey = null;
  this.sessionKeyEncryptionAlgorithm = null;
  this.sessionKeyAlgorithm = 'aes256';
  this.encrypted = null;
  this.s2k = new _s2k2.default();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      throw new Error('Could not find valid key packet for encryption in key ' + key.primaryKey.getKeyId().toHex());
    }
  });
}

if (passwords) {
  passwords.forEach(function (password) {
    var symEncryptedSessionKeyPacket = new _packet2.default.<span class="apidocCodeKeywordSpan">SymEncryptedSessionKey</span>();
    symEncryptedSessionKeyPacket.sessionKey = sessionKey;
    symEncryptedSessionKeyPacket.sessionKeyAlgorithm = symAlgo;
    symEncryptedSessionKeyPacket.encrypt(password);
    delete symEncryptedSessionKeyPacket.sessionKey; // delete plaintext session key after encryption
    packetlist.push(symEncryptedSessionKeyPacket);
  });
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.SymEncryptedSessionKey.prototype" id="apidoc.module.openpgp.packet.SymEncryptedSessionKey.prototype">module openpgp.packet.SymEncryptedSessionKey.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.decrypt" id="apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.decrypt">
        function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedSessionKey.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(passphrase)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (passphrase) {
  var algo = this.sessionKeyEncryptionAlgorithm !== null ? this.sessionKeyEncryptionAlgorithm : this.sessionKeyAlgorithm;

  var length = _crypto2.default.cipher[algo].keySize;
  var key = this.s2k.produce_key(passphrase, length);

  if (this.encrypted === null) {
    this.sessionKey = key;
  } else {
    var decrypted = _crypto2.default.cfb.normalDecrypt(algo, key, this.encrypted, null);

    this.sessionKeyAlgorithm = _enums2.default.read(_enums2.default.symmetric, decrypted[0]);

    this.sessionKey = decrypted.subarray(1, decrypted.length);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
options = {
    message: openpgp.message.read(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.<span class="apidocCodeKeywordSpan">decrypt</span>(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
```

#### Encrypt and decrypt *String* data with PGP keys

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.encrypt" id="apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.encrypt">
        function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedSessionKey.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(passphrase)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (passphrase) {
  var algo = this.sessionKeyEncryptionAlgorithm !== null ? this.sessionKeyEncryptionAlgorithm : this.sessionKeyAlgorithm;

  this.sessionKeyEncryptionAlgorithm = algo;

  var length = _crypto2.default.cipher[algo].keySize;
  var key = this.s2k.produce_key(passphrase, length);

  var algo_enum = new Uint8Array([_enums2.default.write(_enums2.default.symmetric, this.sessionKeyAlgorithm)]);

  var private_key;
  if (this.sessionKey === null) {
    this.sessionKey = _crypto2.default.getRandomBytes(_crypto2.default.cipher[this.sessionKeyAlgorithm].keySize);
  }
  private_key = _util2.default.concatUint8Array([algo_enum, this.sessionKey]);

  this.encrypted = _crypto2.default.cfb.normalEncrypt(algo, key, private_key, null);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.<span class="apidocCodeKeywordSpan">encrypt</span>(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.postCloneTypeFix" id="apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.postCloneTypeFix">
        function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedSessionKey.prototype.</span>postCloneTypeFix
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">postCloneTypeFix = function () {
  this.s2k = _s2k2.default.fromClone(this.s2k);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 var packet = newPacketFromTag(tagName);
 for (var attr in packetClone) {
   if (packetClone.hasOwnProperty(attr)) {
     packet[attr] = packetClone[attr];
   }
 }
 if (packet.postCloneTypeFix) {
   packet.<span class="apidocCodeKeywordSpan">postCloneTypeFix</span>();
 }
 return packet;
}

/**
* Convert tag name to class name
* @param {String} tag property name from {@link module:enums.packet}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.read" id="apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedSessionKey.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  // A one-octet version number. The only currently defined version is 4.
  this.version = bytes[0];

  // A one-octet number describing the symmetric algorithm used.
  var algo = _enums2.default.read(_enums2.default.symmetric, bytes[1]);

  // A string-to-key (S2K) specifier, length as defined above.
  var s2klength = this.s2k.read(bytes.subarray(2, bytes.length));

  // Optionally, the encrypted session key itself, which is decrypted
  // with the string-to-key object.
  var done = s2klength + 2;

  if (done &lt; bytes.length) {
    this.encrypted = bytes.subarray(done, bytes.length);
    this.sessionKeyEncryptionAlgorithm = algo;
  } else {
    this.sessionKeyAlgorithm = algo;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.write" id="apidoc.element.openpgp.packet.SymEncryptedSessionKey.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.SymEncryptedSessionKey.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  var algo = this.encrypted === null ? this.sessionKeyAlgorithm : this.sessionKeyEncryptionAlgorithm;

  var bytes = _util2.default.concatUint8Array([new Uint8Array([this.version, _enums2.default.write(_enums2.default.symmetric, algo
)]), this.s2k.write()]);

  if (this.encrypted !== null) {
    bytes = _util2.default.concatUint8Array([bytes, this.encrypted]);
  }
  return bytes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.SymmetricallyEncrypted" id="apidoc.module.openpgp.packet.SymmetricallyEncrypted">module openpgp.packet.SymmetricallyEncrypted</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted.SymmetricallyEncrypted" id="apidoc.element.openpgp.packet.SymmetricallyEncrypted.SymmetricallyEncrypted">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>SymmetricallyEncrypted
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SymmetricallyEncrypted() {
  this.tag = _enums2.default.packet.symmetricallyEncrypted;
  this.encrypted = null;
<span class="apidocCodeCommentSpan">  /** Decrypted packets contained within.
   * @type {module:packet/packetlist} */
</span>  this.packets = null;
  this.ignore_mdc_error = _config2.default.ignore_mdc_error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  msg = encryptSessionKey(sessionKey, _enums2.default.read(_enums2.default.symmetric, symAlgo), keys, passwords);

  if (_config2.default.aead_protect) {
    symEncryptedPacket = new _packet2.default.SymEncryptedAEADProtected();
  } else if (_config2.default.integrity_protect) {
    symEncryptedPacket = new _packet2.default.SymEncryptedIntegrityProtected();
  } else {
    symEncryptedPacket = new _packet2.default.<span class="apidocCodeKeywordSpan">SymmetricallyEncrypted</span>();
  }
  symEncryptedPacket.packets = _this2.packets;

  return symEncryptedPacket.encrypt(_enums2.default.read(_enums2.default.symmetric, symAlgo), sessionKey);
}).then(function () {
  msg.packets.push(symEncryptedPacket);
  symEncryptedPacket.packets = new _packet2.default.List(); // remove packets after encryption
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.SymmetricallyEncrypted.prototype" id="apidoc.module.openpgp.packet.SymmetricallyEncrypted.prototype">module openpgp.packet.SymmetricallyEncrypted.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted.prototype.decrypt" id="apidoc.element.openpgp.packet.SymmetricallyEncrypted.prototype.decrypt">
        function <span class="apidocSignatureSpan">openpgp.packet.SymmetricallyEncrypted.prototype.</span>decrypt
        <span class="apidocSignatureSpan">(sessionKeyAlgorithm, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decrypt = function (sessionKeyAlgorithm, key) {
  var decrypted = _crypto2.default.cfb.decrypt(sessionKeyAlgorithm, key, this.encrypted, true);
  // for modern cipher (blocklength != 64 bit, except for Twofish) MDC is required
  if (!this.ignore_mdc_error &amp;&amp; (sessionKeyAlgorithm === 'aes128' || sessionKeyAlgorithm === 'aes192' || sessionKeyAlgorithm === '
aes256')) {
    throw new Error('Decryption failed due to missing MDC in combination with modern cipher.');
  }
  this.packets.read(decrypted);

  return Promise.resolve();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
options = {
    message: openpgp.message.read(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.<span class="apidocCodeKeywordSpan">decrypt</span>(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
```

#### Encrypt and decrypt *String* data with PGP keys

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted.prototype.encrypt" id="apidoc.element.openpgp.packet.SymmetricallyEncrypted.prototype.encrypt">
        function <span class="apidocSignatureSpan">openpgp.packet.SymmetricallyEncrypted.prototype.</span>encrypt
        <span class="apidocSignatureSpan">(algo, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">encrypt = function (algo, key) {
  var data = this.packets.write();

  this.encrypted = _crypto2.default.cfb.encrypt(_crypto2.default.getPrefixRandom(algo), algo, data, key, true);

  return Promise.resolve();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.<span class="apidocCodeKeywordSpan">encrypt</span>(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted.prototype.read" id="apidoc.element.openpgp.packet.SymmetricallyEncrypted.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.SymmetricallyEncrypted.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  this.encrypted = bytes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.SymmetricallyEncrypted.prototype.write" id="apidoc.element.openpgp.packet.SymmetricallyEncrypted.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.SymmetricallyEncrypted.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  return this.encrypted;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.Trust" id="apidoc.module.openpgp.packet.Trust">module openpgp.packet.Trust</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.Trust.Trust" id="apidoc.element.openpgp.packet.Trust.Trust">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>Trust
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Trust() {
  this.tag = _enums2.default.packet.trust;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.Trust.prototype" id="apidoc.module.openpgp.packet.Trust.prototype">module openpgp.packet.Trust.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.Trust.prototype.read" id="apidoc.element.openpgp.packet.Trust.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.Trust.prototype.</span>read
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function () {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.UserAttribute" id="apidoc.module.openpgp.packet.UserAttribute">module openpgp.packet.UserAttribute</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.UserAttribute.UserAttribute" id="apidoc.element.openpgp.packet.UserAttribute.UserAttribute">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>UserAttribute
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function UserAttribute() {
  this.tag = _enums2.default.packet.userAttribute;
  this.attributes = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.UserAttribute.prototype" id="apidoc.module.openpgp.packet.UserAttribute.prototype">module openpgp.packet.UserAttribute.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.UserAttribute.prototype.equals" id="apidoc.element.openpgp.packet.UserAttribute.prototype.equals">
        function <span class="apidocSignatureSpan">openpgp.packet.UserAttribute.prototype.</span>equals
        <span class="apidocSignatureSpan">(usrAttr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equals = function (usrAttr) {
  if (!usrAttr || !(usrAttr instanceof UserAttribute)) {
    return false;
  }
  return this.attributes.every(function (attr, index) {
    return attr === usrAttr.attributes[index];
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case _enums2.default.signature.cert_persona:
case _enums2.default.signature.cert_casual:
case _enums2.default.signature.cert_positive:
  if (!user) {
    _util2.default.print_debug('Dropping certification signatures without preceding user packet');
    continue;
  }
  if (packetlist[i].issuerKeyId.<span class="apidocCodeKeywordSpan">equals</span>(primaryKeyId)) {
    if (!user.selfCertifications) {
      user.selfCertifications = [];
    }
    user.selfCertifications.push(packetlist[i]);
  } else {
    if (!user.otherCertifications) {
      user.otherCertifications = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.UserAttribute.prototype.read" id="apidoc.element.openpgp.packet.UserAttribute.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.UserAttribute.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  var i = 0;
  while (i &lt; bytes.length) {
    var len = _packet2.default.readSimpleLength(bytes.subarray(i, bytes.length));
    i += len.offset;

    this.attributes.push(_util2.default.Uint8Array2str(bytes.subarray(i, i + len.len)));
    i += len.len;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.UserAttribute.prototype.write" id="apidoc.element.openpgp.packet.UserAttribute.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.UserAttribute.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  var arr = [];
  for (var i = 0; i &lt; this.attributes.length; i++) {
    arr.push(_packet2.default.writeSimpleLength(this.attributes[i].length));
    arr.push(_util2.default.str2Uint8Array(this.attributes[i]));
  }
  return _util2.default.concatUint8Array(arr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.Userid" id="apidoc.module.openpgp.packet.Userid">module openpgp.packet.Userid</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.Userid.Userid" id="apidoc.element.openpgp.packet.Userid.Userid">
        function <span class="apidocSignatureSpan">openpgp.packet.</span>Userid
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Userid() {
  this.tag = _enums2.default.packet.userid;
<span class="apidocCodeCommentSpan">  /** A string containing the user id. Usually in the form
   * John Doe &lt;john@example.com&gt;
   * @type {String}
   */
</span>  this.userid = '';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var packetlist = new _packet2.default.List();

  packetlist.push(secretKeyPacket);

  options.userIds.forEach(function (userId, index) {

var userIdPacket = new _packet2.default.<span class="apidocCodeKeywordSpan">Userid</span>();
userIdPacket.read(_util2.default.str2Uint8Array(userId));

var dataToSign = {};
dataToSign.userid = userIdPacket;
dataToSign.key = secretKeyPacket;
var signaturePacket = new _packet2.default.Signature();
signaturePacket.signatureType = _enums2.default.signature.cert_generic;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.Userid.prototype" id="apidoc.module.openpgp.packet.Userid.prototype">module openpgp.packet.Userid.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.Userid.prototype.read" id="apidoc.element.openpgp.packet.Userid.prototype.read">
        function <span class="apidocSignatureSpan">openpgp.packet.Userid.prototype.</span>read
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (bytes) {
  this.userid = _util2.default.decode_utf8(_util2.default.Uint8Array2str(bytes));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.Userid.prototype.write" id="apidoc.element.openpgp.packet.Userid.prototype.write">
        function <span class="apidocSignatureSpan">openpgp.packet.Userid.prototype.</span>write
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">write = function () {
  return _util2.default.str2Uint8Array(_util2.default.encode_utf8(this.userid));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
options = {
data: new Uint8Array([0x01, 0x01, 0x01]), // input as Uint8Array (or String)
passwords: ['secret stuff'],              // multiple passwords possible
armor: false                              // don't ASCII armor (for Uint8Array output)
};

openpgp.encrypt(options).then(function(ciphertext) {
encrypted = ciphertext.message.packets.<span class="apidocCodeKeywordSpan">write</span>(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
message: openpgp.message.read(encrypted), // parse encrypted bytes
password: 'secret stuff',                 // decrypt with password
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.packet.clone" id="apidoc.module.openpgp.packet.clone">module openpgp.packet.clone</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.packet.clone.clonePackets" id="apidoc.element.openpgp.packet.clone.clonePackets">
        function <span class="apidocSignatureSpan">openpgp.packet.clone.</span>clonePackets
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clonePackets(options) {
  if (options.publicKeys) {
    options.publicKeys = options.publicKeys.map(function (key) {
      return key.toPacketlist();
    });
  }
  if (options.privateKeys) {
    options.privateKeys = options.privateKeys.map(function (key) {
      return key.toPacketlist();
    });
  }
  if (options.privateKey) {
    options.privateKey = options.privateKey.toPacketlist();
  }
  if (options.key) {
    options.key = options.key.toPacketlist();
  }
  if (options.message) {
    //could be either a Message or CleartextMessage object
    if (options.message instanceof message.Message) {
      options.message = options.message.packets;
    } else if (options.message instanceof cleartext.CleartextMessage) {
      options.message.signature = options.message.signature.packets;
    }
  }
  if (options.signature &amp;&amp; options.signature instanceof signature.Signature) {
    options.signature = options.signature.packets;
  }
  if (options.signatures) {
    options.signatures = options.signatures.map(function (sig) {
      return verificationObjectToClone(sig);
    });
  }
  return options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
AsyncProxy.prototype.delegate = function (method, options) {
  var _this = this;

  var id = this.getID();

  return new Promise(function (_resolve, reject) {
    // clone packets (for web worker structured cloning algorithm)
    _this.worker.postMessage({ id: id, event: method, options: _packet2.default.clone.<span class="apidocCodeKeywordSpan">clonePackets
</span>(options) }, _util2.default.getTransferables.call(_util2.default, options));

    // remember to handle parsing cloned packets from worker
    _this.tasks[id] = { resolve: function resolve(data) {
        return _resolve(_packet2.default.clone.parseClonedPackets(data, method));
      }, reject: reject };
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.packet.clone.parseClonedPackets" id="apidoc.element.openpgp.packet.clone.parseClonedPackets">
        function <span class="apidocSignatureSpan">openpgp.packet.clone.</span>parseClonedPackets
        <span class="apidocSignatureSpan">(options, method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseClonedPackets(options, method) {
  if (options.publicKeys) {
    options.publicKeys = options.publicKeys.map(packetlistCloneToKey);
  }
  if (options.privateKeys) {
    options.privateKeys = options.privateKeys.map(packetlistCloneToKey);
  }
  if (options.privateKey) {
    options.privateKey = packetlistCloneToKey(options.privateKey);
  }
  if (options.key) {
    options.key = packetlistCloneToKey(options.key);
  }
  if (options.message &amp;&amp; (method === 'sign' || method === 'verify')) {
    // sign and verify support only CleartextMessage
    options.message = packetlistCloneToCleartextMessage(options.message);
  } else if (options.message) {
    options.message = packetlistCloneToMessage(options.message);
  }
  if (options.signatures) {
    options.signatures = options.signatures.map(packetlistCloneToSignatures);
  }
  if (options.signature) {
    options.signature = packetlistCloneToSignature(options.signature);
  }
  return options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return new Promise(function (_resolve, reject) {
    // clone packets (for web worker structured cloning algorithm)
    _this.worker.postMessage({ id: id, event: method, options: _packet2.default.clone.clonePackets(options) }, _util2.default.getTransferables
.call(_util2.default, options));

    // remember to handle parsing cloned packets from worker
    _this.tasks[id] = { resolve: function resolve(data) {
        return _resolve(_packet2.default.clone.<span class="apidocCodeKeywordSpan">parseClonedPackets</span>(data, method));
      }, reject: reject };
  });
};

},{"../crypto":24,"../packet":47,"../util.js":70}]},{},[37])(37)
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.signature" id="apidoc.module.openpgp.signature">module openpgp.signature</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.signature.Signature" id="apidoc.element.openpgp.signature.Signature">
        function <span class="apidocSignatureSpan">openpgp.signature.</span>Signature
        <span class="apidocSignatureSpan">(packetlist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Signature(packetlist) {
  if (!(this instanceof Signature)) {
    return new Signature(packetlist);
  }
  this.packets = packetlist || new _packet2.default.List();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new CleartextMessage(text, signature);
  }
  // normalize EOL to canonical form &lt;CR&gt;&lt;LF&gt;
  this.text = text.replace(/\r/g, '').replace(/[\t ]+\n/g, "\n").replace(/\n/g, "\r\n");
  if (signature &amp;&amp; !(signature instanceof sigModule.Signature)) {
    throw new Error('Invalid signature input');
  }
  this.signature = signature || new sigModule.<span class="apidocCodeKeywordSpan">Signature</span>(new _packet2.default.List());
}

/**
 * Returns the key IDs of the keys that signed the cleartext message
 * @return {Array&lt;module:type/keyid&gt;} array of keyid objects
 */
CleartextMessage.prototype.getSigningKeyIds = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.signature.read" id="apidoc.element.openpgp.signature.read">
        function <span class="apidocSignatureSpan">openpgp.signature.</span>read
        <span class="apidocSignatureSpan">(input)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read(input) {
  var packetlist = new _packet2.default.List();
  packetlist.read(input);
  return new Signature(packetlist);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
openpgp.encrypt(options).then(function(ciphertext) {
    encrypted = ciphertext.message.packets.write(); // get raw encrypted packets as Uint8Array
});
```

```js
options = {
    message: openpgp.message.<span class="apidocCodeKeywordSpan">read</span>(encrypted), // parse encrypted bytes
    password: 'secret stuff',                 // decrypt with password
    format: 'binary'                          // output as Uint8Array
};

openpgp.decrypt(options).then(function(plaintext) {
    return plaintext.data // Uint8Array([0x01, 0x01, 0x01])
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.signature.readArmored" id="apidoc.element.openpgp.signature.readArmored">
        function <span class="apidocSignatureSpan">openpgp.signature.</span>readArmored
        <span class="apidocSignatureSpan">(armoredText)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readArmored(armoredText) {
  var input = _armor2.default.decode(armoredText).data;
  return read(input);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var options, encrypted;

var pubkey = '-----BEGIN PGP PUBLIC KEY BLOCK ... END PGP PUBLIC KEY BLOCK-----';
var privkey = '-----BEGIN PGP PRIVATE KEY BLOCK ... END PGP PRIVATE KEY BLOCK-----'; //encrypted private key
var passphrase = 'secret passphrase'; //what the privKey is encrypted with

var privKeyObj = openpgp.key.<span class="apidocCodeKeywordSpan">readArmored</span>(privkey).keys[0];
privKeyObj.decrypt(passphrase);

options = {
    data: 'Hello, World!',                             // input as String (or Uint8Array)
    publicKeys: openpgp.key.readArmored(pubkey).keys,  // for encryption
    privateKeys: privKeyObj // for signing (optional)
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.signature.Signature" id="apidoc.module.openpgp.signature.Signature">module openpgp.signature.Signature</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.signature.Signature.Signature" id="apidoc.element.openpgp.signature.Signature.Signature">
        function <span class="apidocSignatureSpan">openpgp.signature.</span>Signature
        <span class="apidocSignatureSpan">(packetlist)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Signature(packetlist) {
  if (!(this instanceof Signature)) {
    return new Signature(packetlist);
  }
  this.packets = packetlist || new _packet2.default.List();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return new CleartextMessage(text, signature);
  }
  // normalize EOL to canonical form &lt;CR&gt;&lt;LF&gt;
  this.text = text.replace(/\r/g, '').replace(/[\t ]+\n/g, "\n").replace(/\n/g, "\r\n");
  if (signature &amp;&amp; !(signature instanceof sigModule.Signature)) {
    throw new Error('Invalid signature input');
  }
  this.signature = signature || new sigModule.<span class="apidocCodeKeywordSpan">Signature</span>(new _packet2.default.List());
}

/**
 * Returns the key IDs of the keys that signed the cleartext message
 * @return {Array&lt;module:type/keyid&gt;} array of keyid objects
 */
CleartextMessage.prototype.getSigningKeyIds = function () {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.signature.Signature.prototype" id="apidoc.module.openpgp.signature.Signature.prototype">module openpgp.signature.Signature.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.signature.Signature.prototype.armor" id="apidoc.element.openpgp.signature.Signature.prototype.armor">
        function <span class="apidocSignatureSpan">openpgp.signature.Signature.prototype.</span>armor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">armor = function () {
  return _armor2.default.encode(_enums2.default.armor.signature, this.packets.write());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  storeKeys(this.storage, this.privateKeysItem, keys);
};

function storeKeys(storage, itemname, keys) {
  var armoredKeys = [];
  if (keys.length) {
    for (var i = 0; i &lt; keys.length; i++) {
      armoredKeys.push(keys[i].<span class="apidocCodeKeywordSpan">armor</span>());
    }
    storage.setItem(itemname, JSON.stringify(armoredKeys));
  } else {
    storage.removeItem(itemname);
  }
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.openpgp.util" id="apidoc.module.openpgp.util">module openpgp.util</a></h1>


    <h2>
        <a href="#apidoc.element.openpgp.util.Uint8Array2str" id="apidoc.element.openpgp.util.Uint8Array2str">
        function <span class="apidocSignatureSpan">openpgp.util.</span>Uint8Array2str
        <span class="apidocSignatureSpan">(bin)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Uint8Array2str(bin) {
  if (!Uint8Array.prototype.isPrototypeOf(bin)) {
    throw new Error('Uint8Array2str: Data must be in the form of a Uint8Array');
  }

  var result = [],
      bs = 16384,
      j = bin.length;

  for (var i = 0; i &lt; j; i += bs) {
    result.push(String.fromCharCode.apply(String, bin.subarray(i, i + bs &lt; j ? i + bs : j)));
  }
  return result.join('');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (entree) {
  var hex = md5(_util2.default.<span class="apidocCodeKeywordSpan">Uint8Array2str</span>(entree));
  var bin = _util2.default.str2Uint8Array(_util2.default.hex2bin(hex));
  return bin;
};

var _util = _dereq_('../../util.js');

var _util2 = _interopRequireDefault(_util);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.bin2str" id="apidoc.element.openpgp.util.bin2str">
        function <span class="apidocSignatureSpan">openpgp.util.</span>bin2str
        <span class="apidocSignatureSpan">(bin)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bin2str(bin) {
  var result = [];
  for (var i = 0; i &lt; bin.length; i++) {
    result[i] = String.fromCharCode(bin[i]);
  }
  return result.join('');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function bnToMPI() {
var ba = this.toByteArray();
var size = (ba.length - 1) * 8 + nbits(ba[0]);
var result = "";
result += String.fromCharCode((size &amp; 0xFF00) &gt;&gt; 8);
result += String.fromCharCode(size &amp; 0xFF);
result += _util2.default.<span class="apidocCodeKeywordSpan">bin2str</span>(ba);
return result;
}
/* END of addition */

// (protected) true if probably prime (HAC 4.24, Miller-Rabin)
function bnpMillerRabin(t) {
var n1 = this.subtract(BigInteger.ONE);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.calc_checksum" id="apidoc.element.openpgp.util.calc_checksum">
        function <span class="apidocSignatureSpan">openpgp.util.</span>calc_checksum
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function calc_checksum(text) {
  var checksum = {
    s: 0,
    add: function add(sadd) {
      this.s = (this.s + sadd) % 65536;
    }
  };
  for (var i = 0; i &lt; text.length; i++) {
    checksum.add(text[i]);
  }
  return checksum.s;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return _util2.default.concatUint8Array(arr);
};

PublicKeyEncryptedSessionKey.prototype.encrypt = function (key) {
  var data = String.fromCharCode(_enums2.default.write(_enums2.default.symmetric, this.sessionKeyAlgorithm));

  data += _util2.default.Uint8Array2str(this.sessionKey);
  var checksum = _util2.default.<span class="apidocCodeKeywordSpan">calc_checksum</span>(this.sessionKey);
  data += _util2.default.Uint8Array2str(_util2.default.writeNumber(checksum, 2));

  var mpi = new _mpi2.default();
  mpi.fromBytes(_crypto2.default.pkcs1.eme.encode(data, key.mpi[0].byteLength()));

  this.encrypted = _crypto2.default.publicKeyEncrypt(this.publicKeyAlgorithm, key.mpi, mpi);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.collectBuffers" id="apidoc.element.openpgp.util.collectBuffers">
        function <span class="apidocSignatureSpan">openpgp.util.</span>collectBuffers
        <span class="apidocSignatureSpan">(obj, collection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function collectBuffers(obj, collection) {
  if (!obj) {
    return;
  }
  if (this.isUint8Array(obj) &amp;&amp; collection.indexOf(obj.buffer) === -1) {
    collection.push(obj.buffer);
    return;
  }
  if (Object.prototype.isPrototypeOf(obj)) {
    for (var key in obj) {
      // recursively search all children
      this.collectBuffers(obj[key], collection);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *   See: https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage
 * @param  {Object} obj           the options object to be passed to the web worker
 * @return {Array&lt;ArrayBuffer&gt;}   an array of binary data to be passed
 */
getTransferables: function getTransferables(obj) {
  if (_config2.default.zero_copy &amp;&amp; Object.prototype.isPrototypeOf(obj)) {
    var transferables = [];
    this.<span class="apidocCodeKeywordSpan">collectBuffers</span>(obj, transferables);
    return transferables.length ? transferables : undefined;
  }
},

collectBuffers: function collectBuffers(obj, collection) {
  if (!obj) {
    return;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.concatUint8Array" id="apidoc.element.openpgp.util.concatUint8Array">
        function <span class="apidocSignatureSpan">openpgp.util.</span>concatUint8Array
        <span class="apidocSignatureSpan">(arrays)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function concatUint8Array(arrays) {
  var totalLength = 0;
  arrays.forEach(function (element) {
    if (!Uint8Array.prototype.isPrototypeOf(element)) {
      throw new Error('concatUint8Array: Data must be in the form of a Uint8Array');
    }

    totalLength += element.length;
  });

  var result = new Uint8Array(totalLength);
  var pos = 0;
  arrays.forEach(function (element) {
    result.set(element, pos);
    pos += element.length;
  });

  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {String} binary compressed packet
 */
Compressed.prototype.write = function () {
  if (this.compressed === null) {
    this.compress();
  }

  return _util2.default.<span class="apidocCodeKeywordSpan">concatUint8Array</span>(new Uint8Array([_enums2.default.write(_enums2
.default.compression, this.algorithm)]), this.compressed);
};

/**
 * Decompression method for decompressing the compressed data
 * read by read_packet
 */
Compressed.prototype.decompress = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.copyUint8Array" id="apidoc.element.openpgp.util.copyUint8Array">
        function <span class="apidocSignatureSpan">openpgp.util.</span>copyUint8Array
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function copyUint8Array(array) {
  if (!Uint8Array.prototype.isPrototypeOf(array)) {
    throw new Error('Data must be in the form of a Uint8Array');
  }

  var copy = new Uint8Array(array.length);
  copy.set(array);
  return copy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.decode_utf8" id="apidoc.element.openpgp.util.decode_utf8">
        function <span class="apidocSignatureSpan">openpgp.util.</span>decode_utf8
        <span class="apidocSignatureSpan">(utf8)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decode_utf8(utf8) {
  if (typeof utf8 !== 'string') {
    throw new Error('Parameter "utf8" is not of type string');
  }
  try {
    return decodeURIComponent(escape(utf8));
  } catch (e) {
    return utf8;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Returns literal data packets as native JavaScript string
* with normalized end of line to \n
* @return {String} literal data as text
*/
Literal.prototype.getText = function () {
 // decode UTF8
 var text = _util2.default.<span class="apidocCodeKeywordSpan">decode_utf8</span>(_util2.default.Uint8Array2str(this.data));
 // normalize EOL to \n
 return text.replace(/\r\n/g, '\n');
};

/**
* Set the packet data to value represented by the provided string of bytes.
* @param {Uint8Array} bytes The string of bytes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.detectNode" id="apidoc.element.openpgp.util.detectNode">
        function <span class="apidocSignatureSpan">openpgp.util.</span>detectNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function detectNode() {
  return typeof window === 'undefined';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var _util = _dereq_('../util.js');

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; }

var nodeCrypto = _util2.default.<span class="apidocCodeKeywordSpan">detectNode</span>() &amp;&amp; _dereq_('crypto');

exports.default = {
/**
 * Retrieve secure random byte array of the specified length
 * @param {Integer} length Length in bytes to generate
 * @return {Uint8Array} Random byte array
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.encode_utf8" id="apidoc.element.openpgp.util.encode_utf8">
        function <span class="apidocSignatureSpan">openpgp.util.</span>encode_utf8
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encode_utf8(str) {
  return unescape(encodeURIComponent(str));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* will be normalized to \r\n and by default text is converted to UTF8
* @param {String} text Any native javascript string
*/
Literal.prototype.setText = function (text) {
 // normalize EOL to \r\n
 text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').replace(/\n/g, '\r\n');
 // encode UTF8
 this.data = this.format === 'utf8' ? _util2.default.str2Uint8Array(_util2.default.<span class="apidocCodeKeywordSpan">
encode_utf8</span>(text)) : _util2.default.str2Uint8Array(text);
};

/**
* Returns literal data packets as native JavaScript string
* with normalized end of line to \n
* @return {String} literal data as text
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.equalsUint8Array" id="apidoc.element.openpgp.util.equalsUint8Array">
        function <span class="apidocSignatureSpan">openpgp.util.</span>equalsUint8Array
        <span class="apidocSignatureSpan">(array1, array2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function equalsUint8Array(array1, array2) {
  if (!Uint8Array.prototype.isPrototypeOf(array1) || !Uint8Array.prototype.isPrototypeOf(array2)) {
    throw new Error('Data must be in the form of a Uint8Array');
  }

  if (array1.length !== array2.length) {
    return false;
  }

  for (var i = 0; i &lt; array1.length; i++) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  source = source[attr];
  if (source) {
    if (!dest[attr]) {
      dest[attr] = source;
    } else {
      source.forEach(function (sourceSig) {
        if (!sourceSig.isExpired() &amp;&amp; (!checkFn || checkFn(sourceSig)) &amp;&amp; !dest[attr].some(function (destSig
) {
          return _util2.default.<span class="apidocCodeKeywordSpan">equalsUint8Array</span>(destSig.signature, sourceSig.signature
);
        })) {
          dest[attr].push(sourceSig);
        }
      });
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.getLeftNBits" id="apidoc.element.openpgp.util.getLeftNBits">
        function <span class="apidocSignatureSpan">openpgp.util.</span>getLeftNBits
        <span class="apidocSignatureSpan">(string, bitcount)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLeftNBits(string, bitcount) {
  var rest = bitcount % 8;
  if (rest === 0) {
    return string.substring(0, bitcount / 8);
  }
  var bytes = (bitcount - rest) / 8 + 1;
  var result = string.substring(0, bytes);
  return this.shiftRight(result, 8 - rest); // +String.fromCharCode(string.charCodeAt(bytes -1) &lt;&lt; (8-rest) &amp; 0xFF);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// s1 = ((s**-1)*(sha-1(m)+(s1*x) mod q)
function sign(hashalgo, m, g, p, q, x) {
  // If the output size of the chosen hash is larger than the number of
  // bits of q, the hash result is truncated to fit by taking the number
  // of leftmost bits equal to the number of bits of q.  This (possibly
  // truncated) hash function result is treated as a number and used
  // directly in the DSA signature algorithm.
  var hashed_data = _util2.default.<span class="apidocCodeKeywordSpan">getLeftNBits</span>(_util2.default.Uint8Array2str(_hash2.
default.digest(hashalgo, _util2.default.str2Uint8Array(m))), q.bitLength());
  var hash = new _jsbn2.default(_util2.default.hexstrdump(hashed_data), 16);
  // FIPS-186-4, section 4.6:
  // The values of r and s shall be checked to determine if r = 0 or s = 0.
  // If either r = 0 or s = 0, a new value of k shall be generated, and the
  // signature shall be recalculated. It is extremely unlikely that r = 0
  // or s = 0 if signatures are generated properly.
  var k, s1, s2;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.getNodeBuffer" id="apidoc.element.openpgp.util.getNodeBuffer">
        function <span class="apidocSignatureSpan">openpgp.util.</span>getNodeBuffer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNodeBuffer() {
  if (!this.detectNode()) {
    return;
  }

  return _dereq_('buffer').Buffer;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var _asmcryptoLite2 = _interopRequireDefault(_asmcryptoLite);

function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; }

var webCrypto = _util2.default.getWebCrypto(); // no GCM support in IE11, Safari 9
var nodeCrypto = _util2.default.getNodeCrypto();
var Buffer = _util2.default.<span class="apidocCodeKeywordSpan">getNodeBuffer</span>();

var ivLength = exports.ivLength = 12; // size of the IV in bytes
var TAG_LEN = 16; // size of the tag in bytes
var ALGO = 'AES-GCM';

/**
* Encrypt plaintext input.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.getNodeCrypto" id="apidoc.element.openpgp.util.getNodeCrypto">
        function <span class="apidocSignatureSpan">openpgp.util.</span>getNodeCrypto
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNodeCrypto() {
  if (!this.detectNode() || !_config2.default.use_native) {
    return;
  }

  return _dereq_('crypto');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var _asmcryptoLite = _dereq_('asmcrypto-lite');

var _asmcryptoLite2 = _interopRequireDefault(_asmcryptoLite);

function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; }

var webCrypto = _util2.default.getWebCrypto(); // no GCM support in IE11, Safari 9
var nodeCrypto = _util2.default.<span class="apidocCodeKeywordSpan">getNodeCrypto</span>();
var Buffer = _util2.default.getNodeBuffer();

var ivLength = exports.ivLength = 12; // size of the IV in bytes
var TAG_LEN = 16; // size of the tag in bytes
var ALGO = 'AES-GCM';

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.getTransferables" id="apidoc.element.openpgp.util.getTransferables">
        function <span class="apidocSignatureSpan">openpgp.util.</span>getTransferables
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTransferables(obj) {
  if (_config2.default.zero_copy &amp;&amp; Object.prototype.isPrototypeOf(obj)) {
    var transferables = [];
    this.collectBuffers(obj, transferables);
    return transferables.length ? transferables : undefined;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

afterEach(function() {
  openpgp.config.zero_copy = zero_copyVal;
});

it('should return undefined when zero_copy is false', function() {
  openpgp.config.zero_copy = false;
  expect(openpgp.util.<span class="apidocCodeKeywordSpan">getTransferables</span>(obj)).to.be.undefined;
});
it('should return undefined for no input', function() {
  expect(openpgp.util.getTransferables()).to.be.undefined;
});
it('should return undefined for an empty oject', function() {
  expect(openpgp.util.getTransferables({})).to.be.undefined;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.getWebCrypto" id="apidoc.element.openpgp.util.getWebCrypto">
        function <span class="apidocSignatureSpan">openpgp.util.</span>getWebCrypto
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getWebCrypto() {
  if (!_config2.default.use_native) {
    return;
  }

  return typeof window !== 'undefined' &amp;&amp; window.crypto &amp;&amp; window.crypto.subtle;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var _asmcryptoLite = _dereq_('asmcrypto-lite');

var _asmcryptoLite2 = _interopRequireDefault(_asmcryptoLite);

function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; }

var webCrypto = _util2.default.<span class="apidocCodeKeywordSpan">getWebCrypto</span>(); // no GCM support in IE11, Safari 9
var nodeCrypto = _util2.default.getNodeCrypto();
var Buffer = _util2.default.getNodeBuffer();

var ivLength = exports.ivLength = 12; // size of the IV in bytes
var TAG_LEN = 16; // size of the tag in bytes
var ALGO = 'AES-GCM';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.getWebCryptoAll" id="apidoc.element.openpgp.util.getWebCryptoAll">
        function <span class="apidocSignatureSpan">openpgp.util.</span>getWebCryptoAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getWebCryptoAll() {
  if (!_config2.default.use_native) {
    return;
  }

  if (typeof window !== 'undefined') {
    if (window.crypto) {
      return window.crypto.subtle || window.crypto.webkitSubtle;
    }
    if (window.msCrypto) {
      return window.msCrypto.subtle;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.dmq1 = null;
this.u = null;
  }

  // Generate a new random private key B bits long, using public expt E

  function generate(B, E) {
var webCrypto = _util2.default.<span class="apidocCodeKeywordSpan">getWebCryptoAll</span>();

//
// Native RSA keygen using Web Crypto
//

if (webCrypto) {
  var Euint32 = new Uint32Array([parseInt(E, 16)]); // get integer of exponent
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.get_hashAlgorithmString" id="apidoc.element.openpgp.util.get_hashAlgorithmString">
        function <span class="apidocSignatureSpan">openpgp.util.</span>get_hashAlgorithmString
        <span class="apidocSignatureSpan">(algo)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function get_hashAlgorithmString(algo) {
  switch (algo) {
    case 1:
      return "MD5";
    case 2:
      return "SHA1";
    case 3:
      return "RIPEMD160";
    case 8:
      return "SHA256";
    case 9:
      return "SHA384";
    case 10:
      return "SHA512";
    case 11:
      return "SHA224";
  }
  return "unknown";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.hex2bin" id="apidoc.element.openpgp.util.hex2bin">
        function <span class="apidocSignatureSpan">openpgp.util.</span>hex2bin
        <span class="apidocSignatureSpan">(hex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hex2bin(hex) {
  var str = '';
  for (var i = 0; i &lt; hex.length; i += 2) {
    str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
  }
  return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Use JS fallbacks

hash_fns = {
  /** @see module:crypto/hash/md5 */
  md5: _md2.default,
  /** @see module:rusha */
  sha1: function sha1(data) {
    return _util2.default.str2Uint8Array(_util2.default.<span class="apidocCodeKeywordSpan">hex2bin</span>(rusha.digest(data)));
  },
  /** @see module:crypto/hash/sha.sha224 */
  sha224: _sha2.default.sha224,
  /** @see module:asmcrypto */
  sha256: _asmcryptoLite2.default.SHA256.bytes,
  /** @see module:crypto/hash/sha.sha384 */
  sha384: _sha2.default.sha384,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.hexdump" id="apidoc.element.openpgp.util.hexdump">
        function <span class="apidocSignatureSpan">openpgp.util.</span>hexdump
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hexdump(str) {
  var r = [];
  var e = str.length;
  var c = 0;
  var h;
  var i = 0;
  while (c &lt; e) {
    h = str.charCodeAt(c++).toString(16);
    while (h.length &lt; 2) {
      h = "0" + h;
    }
    r.push(" " + h);
    i++;
    if (i % 32 === 0) {
      r.push("\n           ");
    }
  }
  return r.join('');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.hexidump" id="apidoc.element.openpgp.util.hexidump">
        function <span class="apidocSignatureSpan">openpgp.util.</span>hexidump
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hexidump(str) {
  var r = [];
  var e = str.length;
  var c = 0;
  var h;
  while (c &lt; e) {
    h = str[c++].toString(16);
    while (h.length &lt; 2) {
      h = "0" + h;
    }
    r.push("" + h);
  }
  return r.join('');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            [[0xE0,0xE1,0xE2,0xE3,0xE5,0xE6,0xE7,0xE8,0xEA,0xEB,0xEC,0xED,0xEF,0xF0,0xF1,0xF2,0xF4,0xF5,0xF6,0xF7,0xF9,0xFA,0xFB
,0xFC,0xFE,0xFE,0x01,0x01,0x03,0x04,0x05,0x06],[0xE5,0x1A,0xA0,0xB1,0x35,0xDB,0xA5,0x66,0x93,0x9C,0x3B,0x63,0x59,0xA9,0x80,0xC5],[
0x8C,0xD9,0x42,0x3D,0xFC,0x45,0x9E,0x54,0x71,0x55,0xC5,0xD1,0xD5,0x22,0xE5,0x40]],
            [[0x08,0x09,0x0A,0x0B,0x0D,0x0E,0x0F,0x10,0x12,0x13,0x14,0x15,0x17,0x18,0x19,0x1A,0x1C,0x1D,0x1E,0x1F,0x21,0x22,0x23
,0x24,0x26,0x27,0x28,0x29,0x2B,0x2C,0x2D,0x2E],[0x06,0x9A,0x00,0x7F,0xC7,0x6A,0x45,0x9F,0x98,0xBA,0xF9,0x17,0xFE,0xDF,0x95,0x21],[
0x08,0x0E,0x95,0x17,0xEB,0x16,0x77,0x71,0x9A,0xCF,0x72,0x80,0x86,0x04,0x0A,0xE3]],
            [[0x30,0x31,0x32,0x33,0x35,0x36,0x37,0x38,0x3A,0x3B,0x3C,0x3D,0x3F,0x40,0x41,0x42,0x44,0x45,0x46,0x47,0x49,0x4A,0x4B
,0x4C,0x4E,0x4F,0x50,0x51,0x53,0x54,0x55,0x56],[0x72,0x61,0x65,0xC1,0x72,0x3F,0xBC,0xF6,0xC0,0x26,0xD7,0xD0,0x0B,0x09,0x10,0x27],[
0x7C,0x17,0x00,0x21,0x1A,0x39,0x91,0xFC,0x0E,0xCD,0xED,0x0A,0xB3,0xE5,0x76,0xB0]]];

it('128 bit key', function (done) {
  for (var i = 0; i &lt; testvectors128.length; i++) {
    var res = test_aes(testvectors128[i][1],testvectors128[i][0],testvectors128[i][2]);
    expect(res, 'block ' + util.<span class="apidocCodeKeywordSpan">hexidump</span>(testvectors128[i][1]) +
                ' and key '+util.hexidump(testvectors128[i][0]) +
                ' should be '+util.hexidump(testvectors128[i][2])).to.be.true;
  }
  done();
});

it('192 bit key', function (done) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.hexstrdump" id="apidoc.element.openpgp.util.hexstrdump">
        function <span class="apidocSignatureSpan">openpgp.util.</span>hexstrdump
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hexstrdump(str) {
  if (str === null) {
    return "";
  }
  var r = [];
  var e = str.length;
  var c = 0;
  var h;
  while (c &lt; e) {
    h = str.charCodeAt(c++).toString(16);
    while (h.length &lt; 2) {
      h = "0" + h;
    }
    r.push("" + h);
  }
  return r.join('');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      var PS = '';
      for (i = 0; i &lt; emLen - tLen - 3; i++) {
        PS += String.fromCharCode(0xff);
      }
      // Concatenate PS, the hash prefix T, and other padding to form the
      // encoded message EM as EM = 0x00 || 0x01 || PS || 0x00 || T.
      var EM = String.fromCharCode(0x00) + String.fromCharCode(0x01) + PS + String.fromCharCode(0x00) + T;
      return new _jsbn2.default(_util2.default.<span class="apidocCodeKeywordSpan">hexstrdump</span>(EM), 16);
    }
  }
};

},{"../util.js":70,"./hash":20,"./public_key/jsbn.js":29,"./random.js":31}],26:[function
(_dereq_,module,exports){
// GPG4Browsers - An OpenPGP implementation in javascript
// Copyright (C) 2011 Recurity Labs GmbH
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.isArray" id="apidoc.element.openpgp.util.isArray">
        function <span class="apidocSignatureSpan">openpgp.util.</span>isArray
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isArray(data) {
  return Array.prototype.isPrototypeOf(data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Normalize parameter to an array if it is not undefined.
* @param  {Object} param              the parameter to be normalized
* @return {Array&lt;Object&gt;|undefined}   the resulting array or undefined
*/
function toArray(param) {
 if (param &amp;&amp; !_util2.default.<span class="apidocCodeKeywordSpan">isArray</span>(param)) {
   param = [param];
 }
 return param;
}

/**
* Creates a message obejct either from a Uint8Array or a string.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.isEmailAddress" id="apidoc.element.openpgp.util.isEmailAddress">
        function <span class="apidocSignatureSpan">openpgp.util.</span>isEmailAddress
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isEmailAddress(data) {
  if (!this.isString(data)) {
    return false;
  }
  var re = /^(([^&lt;&gt;()[\]\\.,;:\s@\"]+(\.[^&lt;&gt;()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([
a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  return re.test(data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
if (_util2.default.isUserId(id)) {
  return id; // user id is already in correct format... no conversion necessary
}
// name and email address can be empty but must be of the correct type
id.name = id.name || '';
id.email = id.email || '';
if (!_util2.default.isString(id.name) || id.email &amp;&amp; !_util2.default.<span class="apidocCodeKeywordSpan">isEmailAddress
</span>(id.email)) {
  throw new Error('Invalid user id format');
}
id.name = id.name.trim();
if (id.name.length &gt; 0) {
  id.name += ' ';
}
return id.name + '&lt;' + id.email + '&gt;';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.isString" id="apidoc.element.openpgp.util.isString">
        function <span class="apidocSignatureSpan">openpgp.util.</span>isString
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isString(data) {
  return typeof data === 'string' || String.prototype.isPrototypeOf(data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {Message}             new message with decrypted content
 */
Message.prototype.decrypt = function (privateKey, sessionKey, password) {
  var _this = this;

  return Promise.resolve().then(function () {
var keyObj = sessionKey || _this.decryptSessionKey(privateKey, password);
if (!keyObj || !_util2.default.isUint8Array(keyObj.data) || !_util2.default.<span class="apidocCodeKeywordSpan">isString</span>(
keyObj.algorithm)) {
  throw new Error('Invalid session key for decryption.');
}

var symEncryptedPacketlist = _this.packets.filterByTag(_enums2.default.packet.symmetricallyEncrypted, _enums2.default.packet.symEncryptedIntegrityProtected
, _enums2.default.packet.symEncryptedAEADProtected);

if (symEncryptedPacketlist.length === 0) {
  return;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.isUint8Array" id="apidoc.element.openpgp.util.isUint8Array">
        function <span class="apidocSignatureSpan">openpgp.util.</span>isUint8Array
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isUint8Array(data) {
  return Uint8Array.prototype.isPrototypeOf(data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {Message}             new message with decrypted content
 */
Message.prototype.decrypt = function (privateKey, sessionKey, password) {
  var _this = this;

  return Promise.resolve().then(function () {
var keyObj = sessionKey || _this.decryptSessionKey(privateKey, password);
if (!keyObj || !_util2.default.<span class="apidocCodeKeywordSpan">isUint8Array</span>(keyObj.data) || !_util2.default.isString(
keyObj.algorithm)) {
  throw new Error('Invalid session key for decryption.');
}

var symEncryptedPacketlist = _this.packets.filterByTag(_enums2.default.packet.symmetricallyEncrypted, _enums2.default.packet.symEncryptedIntegrityProtected
, _enums2.default.packet.symEncryptedAEADProtected);

if (symEncryptedPacketlist.length === 0) {
  return;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.isUserId" id="apidoc.element.openpgp.util.isUserId">
        function <span class="apidocSignatureSpan">openpgp.util.</span>isUserId
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isUserId(data) {
  if (!this.isString(data)) {
    return false;
  }
  return (/&lt;/.test(data) &amp;&amp; /&gt;$/.test(data)
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
function formatUserIds(options) {
if (!options.userIds) {
  return options;
}
options.userIds = toArray(options.userIds); // normalize to array
options.userIds = options.userIds.map(function (id) {
  if (_util2.default.isString(id) &amp;&amp; !_util2.default.<span class="apidocCodeKeywordSpan">isUserId</span>(id)) {
    throw new Error('Invalid user id format');
  }
  if (_util2.default.isUserId(id)) {
    return id; // user id is already in correct format... no conversion necessary
  }
  // name and email address can be empty but must be of the correct type
  id.name = id.name || '';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.print_debug" id="apidoc.element.openpgp.util.print_debug">
        function <span class="apidocSignatureSpan">openpgp.util.</span>print_debug
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function print_debug(str) {
  if (_config2.default.debug) {
    console.log(str);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    case 32:
      // 4096 bit // prefer sha224
      if (usersetting &gt; 10 &amp;&amp; usersetting &lt; 8) {
        return 8; // prefer sha256
      }
      return usersetting;
    default:
      _util2.default.<span class="apidocCodeKeywordSpan">print_debug</span>("DSA select hash algorithm: returning null for
an unknown length of q");
      return null;
  }
}
this.select_hash_algorithm = select_hash_algorithm;

function verify(hashalgo, s1, s2, m, p, q, g, y) {
  var hashed_data = _util2.default.getLeftNBits(_util2.default.Uint8Array2str(_hash2.default.digest(hashalgo, _util2.default.str2Uint8Array
(m))), q.bitLength());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.print_debug_hexstr_dump" id="apidoc.element.openpgp.util.print_debug_hexstr_dump">
        function <span class="apidocSignatureSpan">openpgp.util.</span>print_debug_hexstr_dump
        <span class="apidocSignatureSpan">(str, strToHex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function print_debug_hexstr_dump(str, strToHex) {
  if (_config2.default.debug) {
    str = str + this.hexstrdump(strToHex);
    console.log(str);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.promisify" id="apidoc.element.openpgp.util.promisify">
        function <span class="apidocSignatureSpan">openpgp.util.</span>promisify
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function promisify(fn) {
  return function () {
    var args = arguments;
    return new Promise(function (resolve) {
      var result = fn.apply(null, args);
      resolve(result);
    });
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.promisifyIE11Op" id="apidoc.element.openpgp.util.promisifyIE11Op">
        function <span class="apidocSignatureSpan">openpgp.util.</span>promisifyIE11Op
        <span class="apidocSignatureSpan">(cryptoOp, errmsg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function promisifyIE11Op(cryptoOp, errmsg) {
  return new Promise(function (resolve, reject) {
    cryptoOp.onerror = function () {
      reject(new Error(errmsg));
    };
    cryptoOp.oncomplete = function (e) {
      resolve(e.target.result);
    };
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      name: 'SHA-1' // not required for actual RSA keys, but for crypto api 'sign' and 'verify'
    }
  };

  keys = webCrypto.generateKey(keyGenOpt, true, ['sign', 'verify']);
  if (typeof keys.then !== 'function') {
    // IE11 KeyOperation
    keys = _util2.default.<span class="apidocCodeKeywordSpan">promisifyIE11Op</span>(keys, 'Error generating RSA key pair.&amp;#
x27;);
  }
}

return keys.then(exportKey).then(function (key) {
  if (key instanceof ArrayBuffer) {
    // parse raw ArrayBuffer bytes to jwk/json (WebKit/Safari/IE11 quirk)
    return decodeKey(JSON.parse(String.fromCharCode.apply(null, new Uint8Array(key))));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.readDate" id="apidoc.element.openpgp.util.readDate">
        function <span class="apidocSignatureSpan">openpgp.util.</span>readDate
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readDate(bytes) {
  var n = this.readNumber(bytes);
  var d = new Date();
  d.setTime(n * 1000);
  return d;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Literal.prototype.read = function (bytes) {
  // - A one-octet field that describes how the data is formatted.
  var format = _enums2.default.read(_enums2.default.literal, bytes[0]);

  var filename_len = bytes[1];
  this.filename = _util2.default.decode_utf8(_util2.default.Uint8Array2str(bytes.subarray(2, 2 + filename_len)));

  this.date = _util2.default.<span class="apidocCodeKeywordSpan">readDate</span>(bytes.subarray(2 + filename_len, 2 + filename_len
 + 4));

  var data = bytes.subarray(6 + filename_len, bytes.length);

  this.setBytes(data, format);
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.readNumber" id="apidoc.element.openpgp.util.readNumber">
        function <span class="apidocSignatureSpan">openpgp.util.</span>readNumber
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readNumber(bytes) {
  var n = 0;

  for (var i = 0; i &lt; bytes.length; i++) {
    n &lt;&lt;= 8;
    n += bytes[i];
  }

  return n;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (type &lt; 192) {
  len = bytes[0];
  offset = 1;
} else if (type &lt; 255) {
  len = (bytes[0] - 192 &lt;&lt; 8) + bytes[1] + 192;
  offset = 2;
} else if (type === 255) {
  len = _util2.default.<span class="apidocCodeKeywordSpan">readNumber</span>(bytes.subarray(1, 1 + 4));
  offset = 5;
}

return {
  len: len,
  offset: offset
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.shiftRight" id="apidoc.element.openpgp.util.shiftRight">
        function <span class="apidocSignatureSpan">openpgp.util.</span>shiftRight
        <span class="apidocSignatureSpan">(value, bitcount)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shiftRight(value, bitcount) {
  var temp = this.str2bin(value);
  if (bitcount % 8 !== 0) {
    for (var i = temp.length - 1; i &gt;= 0; i--) {
      temp[i] &gt;&gt;= bitcount % 8;
      if (i &gt; 0) {
        temp[i] |= temp[i - 1] &lt;&lt; 8 - bitcount % 8 &amp; 0xFF;
      }
    }
  } else {
    return value;
  }
  return this.bin2str(temp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/* END of addition */

// (protected) true if probably prime (HAC 4.24, Miller-Rabin)
function bnpMillerRabin(t) {
var n1 = this.subtract(BigInteger.ONE);
var k = n1.getLowestSetBit();
if (k &lt;= 0) return false;
var r = n1.<span class="apidocCodeKeywordSpan">shiftRight</span>(k);
t = t + 1 &gt;&gt; 1;
if (t &gt; lowprimes.length) t = lowprimes.length;
var a = nbi();
var j,
    bases = [];
for (var i = 0; i &lt; t; ++i) {
  //Pick bases at random, instead of starting at 2
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.str2Uint8Array" id="apidoc.element.openpgp.util.str2Uint8Array">
        function <span class="apidocSignatureSpan">openpgp.util.</span>str2Uint8Array
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function str2Uint8Array(str) {
  if (typeof str !== 'string' &amp;&amp; !String.prototype.isPrototypeOf(str)) {
    throw new Error('str2Uint8Array: Data must be in the form of a string');
  }

  var result = new Uint8Array(str.length);
  for (var i = 0; i &lt; str.length; i++) {
    result[i] = str.charCodeAt(i);
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Use JS fallbacks

hash_fns = {
  /** @see module:crypto/hash/md5 */
  md5: _md2.default,
  /** @see module:rusha */
  sha1: function sha1(data) {
    return _util2.default.<span class="apidocCodeKeywordSpan">str2Uint8Array</span>(_util2.default.hex2bin(rusha.digest(data)));
  },
  /** @see module:crypto/hash/sha.sha224 */
  sha224: _sha2.default.sha224,
  /** @see module:asmcrypto */
  sha256: _asmcryptoLite2.default.SHA256.bytes,
  /** @see module:crypto/hash/sha.sha384 */
  sha384: _sha2.default.sha384,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.str2bin" id="apidoc.element.openpgp.util.str2bin">
        function <span class="apidocSignatureSpan">openpgp.util.</span>str2bin
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function str2bin(str) {
  var result = [];
  for (var i = 0; i &lt; str.length; i++) {
    result[i] = str.charCodeAt(i);
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Shifting a string to n bits right
 * @param {String} value The string to shift
 * @param {Integer} bitcount Amount of bits to shift (MUST be smaller
 * than 9)
 * @return {String} Resulting string.
 */
shiftRight: function shiftRight(value, bitcount) {
  var temp = this.<span class="apidocCodeKeywordSpan">str2bin</span>(value);
  if (bitcount % 8 !== 0) {
    for (var i = temp.length - 1; i &gt;= 0; i--) {
      temp[i] &gt;&gt;= bitcount % 8;
      if (i &gt; 0) {
        temp[i] |= temp[i - 1] &lt;&lt; 8 - bitcount % 8 &amp; 0xFF;
      }
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.writeDate" id="apidoc.element.openpgp.util.writeDate">
        function <span class="apidocSignatureSpan">openpgp.util.</span>writeDate
        <span class="apidocSignatureSpan">(time)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeDate(time) {
  var numeric = Math.round(time.getTime() / 1000);

  return this.writeNumber(numeric, 4);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {Uint8Array} Uint8Array representation of the packet
 */
Literal.prototype.write = function () {
  var filename = _util2.default.str2Uint8Array(_util2.default.encode_utf8(this.filename));
  var filename_length = new Uint8Array([filename.length]);

  var format = new Uint8Array([_enums2.default.write(_enums2.default.literal, this.format)]);
  var date = _util2.default.<span class="apidocCodeKeywordSpan">writeDate</span>(this.date);
  var data = this.getBytes();

  return _util2.default.concatUint8Array([format, filename_length, filename, date, data]);
};

},{"../enums.js":35,"../util.js":70}],49:[function(_dereq_,module,exports){
// GPG4Browsers - An OpenPGP implementation in javascript
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.openpgp.util.writeNumber" id="apidoc.element.openpgp.util.writeNumber">
        function <span class="apidocSignatureSpan">openpgp.util.</span>writeNumber
        <span class="apidocSignatureSpan">(n, bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function writeNumber(n, bytes) {
  var b = new Uint8Array(bytes);
  for (var i = 0; i &lt; bytes; i++) {
    b[i] = n &gt;&gt; 8 * (bytes - i - 1) &amp; 0xFF;
  }

  return b;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else if (length &gt; 191 &amp;&amp; length &lt; 8384) {
    /*
     * let a = (total data packet length) - 192 let bc = two octet
     * representation of a let d = b + 192
     */
    return new Uint8Array([(length - 192 &gt;&gt; 8) + 192, length - 192 &amp; 0xFF]);
  } else {
    return _util2.default.concatUint8Array([new Uint8Array([255]), _util2.default.<span class="apidocCodeKeywordSpan">writeNumber
</span>(length, 4)]);
  }
},

/**
 * Writes a packet header version 4 with the given tag_type and length to a
 * string
 *
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>